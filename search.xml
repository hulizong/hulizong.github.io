<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows+docker 运行.NetCore]]></title>
    <url>%2F2019%2F08%2F02%2FWindows%2Bdocker%20%E8%BF%90%E8%A1%8C.NetCore%2F</url>
    <content type="text"><![CDATA[今天我们来说下如何在windows下使用docker运行.net core，既然是docker，那么我们首先得在windows上安装docker。 在Windows安装 docker 有两种选择： 1、docker for windows 2、docker toolbox 区别： docker for windows-64位Windows 10、必须开启 Hyper-V docker toolbox -有virtualbox即可 今天只给大家介绍 docker for windows安装 地址：https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe 我们下载按照步骤一步步安装就ok了，安装之后打开可能会出现一个错误，如果没有出现那肯定万事大吉咯！ Hyper-V 没开不能启动： 以管理员身份打开 PowerShell 控制台。 运行以下命令： 1Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All 现在我们再来启动即可，在右下角也会有一个图标，悬浮上去显示 docker desk is running，表示已经安装成功（这个会提示我们登录，不过登录不登录问题都不是太大，登录之后可以连接到(Docker Hub） 接下来正式进入我们今天的主题，如何而使用 docker for windows 来运行 .netcore（Start） 首先我们创建一个.net core web项目 然后我们去项目根目录去看，会发现有一个Dockerfile的文件，同样我们需要在项目当中修改Dockerfile文件的属性，修改为较新则复制。 我们可以运行一下.net core看一下出来的页面效果，到现在我们需要的.net core的事例已经准备好了，我们现在开始在docker 中部署了。 我们打开PowerShell ，输入 docker info 出现下面的界面的样子证明docker 一切正常。 我们进入到我们刚刚创建的.net core 项目的根目录，然后开始构建docker镜像，要注意命令后面的那个 . ，意思是当前目录 1docker build -t demotest . 然后我们发现在执行到第六步的时候报错了，说什么在该路径找不到该文件 我也卡在这里卡了很久，最后发现路径拼接起来不对。我们仔细检查下Dockerfile文件的第六步发现文件路径是dockertest/dockertest.csproj，再结合我们当前路径是E:\Docker\dockertest \dockertest，组合一来看，多了一个dockertest，然后我们修改Dockerfile文件中的路径去掉这个多的dockertest/ 然后我们再来执行docker build -t demotest .然后发现我们在第10步的时候又出错了，说这个程序不包含适合入口点的静态’Main’方法，我们继续检查下Dockerfile文件，发现第9步那个工作路径 是/src/dockertest，我们拼接一下发现，又多了一个/dockertest，我们接着继续去掉这个，然后继续运行docker build -t demotest . 这一次终于不负众望。它完整的运行完成了所有的步骤并且提示了 123Successfully built eaa8cea8fcf4Successfully tagged demotest:latest 我们来看看构建镜像是否真的成功了吧 1docker images 我们发现了这一个，是我们刚刚创建的demotest,既然镜像我们已经创建成功了，那我们正式运行起来看看是否可用。 1docekr run --name=demotest -p7778:80-d demotest--name：指定容器名称-p：指定容器端口-d：指定容器 后台运行 然后出现了一串字符串，说明我们启动成功了，然后我们查看一下我们正在运行的容器 1docker ps 然后我们去浏览器输入ip+7778，看到如下页面证明这次docker for windows +.net core 成功运行了。 那么到这里我们的第一的windows+docker运行.netcore算是正式完工了，然后在给大家介绍一些较为常用的docker命令（命令） 123456789101112131415161718192021docker build -t demotest . 构建 demotest镜像docker images 查看当前所有的镜像docker inspect demotest 查看 运行容器的详情docker ps 查看当前运行的容器docker ps -a 查看当前所有的容器docker stop demotest 停止运行demotest容器docker start demotest 开启运行demotest容器docker rm demotest 删除demotest容器docker rmi demotest 删除demotest镜像docker rm $(docker ps -aq) 删除所有容器docker rmi $(docker images -q) 删除所有镜像]]></content>
      <categories>
        <category>Docker知识分享</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识详解系列目录]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[摘要：这个系列是本人在学习与复习当中所遇到或尚且未知的一些知识点，目前逐步学习并详细解读。 目录索引：一、c#类型详解上 二、基础类型详解下 三、抽象类与接口 四、委托与事件-委托详解（一） 五、委托与事件-事件详解（二） 六、委托与事件-委托事件案例（三） 七、面向对象三大特性—–封装、继承、多态 八、泛型程序设计详解（一） 九、泛型协变与抗变（二） 十、数组（ArrayPool数组池、Span结构） 十一、集合（正在编写中） 十二、LINQ（正在编写中） 十三、错误异常处理（正在编写中） 十四、异步编程（正在编写中） 十五、反射、元数据和动态编程（正在编写中） 十六、托管和非托管内存（正在编写中） 总结：** 本人知识尚且有限，一旦出现误解或者少解还请各位慷慨解囊。** ** 清风飒爽柳姿还在，一片轻云漫飞天。涟漪泛湖荷叶拂舟，一曲和音绕指柔。对镜描妆素面朝天，一记浅笑去无痕。凭栏怅望凝眸思量，一片清秋气自爽。和音题文，一把辛酸暂埋藏，寻音倚歌，一帘惆怅浅卷起。但凭楼兰，倾泻柔情，不慢不躁，雅致清秋，莫使伤愁锁清秋。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c#类型详解]]></title>
    <url>%2F2019%2F07%2F31%2FC%23%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、类型成员类成员定义有（public、private、internal、protected）。 Public–对任何类和成员都是公开的，无限制 Private–是私有的，仅能由类内部代码访问，如果没有声明，默认使用此关键字 Internal–仅能在所属命名空间内部访问 Protected–可以由类或者其派生类中的代码访问 类成员–字段、方法、属性 12345678910public class MyClass &#123; public int MyInt = 2019;//字段 public static string MyMain() &#123; return &quot;这是方法&quot;; &#125; public int MyProperty &#123; get; set; &#125;//属性&#125; 字段–一个只读、可读/写的数据值 方法–对类型或对象状态数据操作的一个过程实现 属性–它可以像方法一样操作类或对象的状态数据，但看上去却像字段一样的书写方式 二、类型操作（隐式转换、显示转换、装箱、拆箱）隐式转换–对于内置数值类型，如果要存储的值无需截断或四舍五入即可适应变量，则可以进行隐式转换、小精度数据转大精度也可进行隐式转换 123Int Num=100;Long Bignum= Num;&lt;/pre&gt; 显示转换–显示转换也称为强制转换，强制转换是显式告知编译器你打算进行转换且你知道可能会发生数据丢失的一种方式。 12345Double Num=100.1;Int a;a=int.Parse(Num);&lt;/pre&gt; 显示转换存在一定的风险性，如若出现失误可能会抛出异常或者影响整个结果的精确性。假如在不知a的类型的情况下进行显示转换，但是转换失败则会引起程序抛出异常。 1var a = &quot;yi&quot;; int b = int.Parse(a);&lt;/pre&gt; 这是可以尝试使用TryParse，这里返回的是一个bool，转换成功则True 1var a = &quot;yi&quot;; int b; int.TryParse(a, out b);&lt;/pre&gt; 类型操作转换–装箱、拆箱 123456789public void Test() &#123; //装箱 int a = 1; object obj = a; //拆箱 object obj2 = 2; int b = (int)obj2;&#125; 首先我们得了解，值类型是分配在线程栈中的，不受垃圾回收机制管理。而引用类型分配在托管堆中的。 装箱–简单来说值类型转换引用类型是装箱，详细来说是。先在托管内存中分配内存，然后将值类型的值复制到内存堆中，然后返回新对象的地址，这一过程为装箱。 拆箱–拆箱并不是装箱的逆过程，简单说也是引用类型转换为值类型为拆箱，详细来说拆箱是获取为装箱部分的指针，然后将未装箱部分的值复制到堆栈中。 三、类型转换(Is,As)类型转换操作符–is、as as–是将一个对象从一种类型转换为另一种类型，如果转换成功则返回该类型，否则返回null 123A a=new A();B b= A as B;//转换正常则返回B类型，转换失败则返回null&lt;/pre&gt; is–是判断一种类型转换为另一种类型，如果转换成功则返回True，否则返回False。 123456A a=new A();If(B is A)//返回True False &#123;&#125; 保险起见可以先用is对类型转换进行判断然后再使用as进行类型转换。当然这样的话可能会造成更新的性能消耗。 更简单的一次验证并安全的操作： 123A a=new A();B b= A as B; if(B!=null)&#123;&#125; else&#123;&#125; 四、类型分类一切皆对象，每一个对象都对应一个类，所有的类都有一个基类–Object-System.Object 然后其下又可分为值类型(基本数据类型)、引用类型。 值类型：整型、浮点型、字符型、布尔型、结构体、枚举 引用类型：数组、字符串、类、接口、委托 关于类型的详解将在下一节中详细讲出。 五、扩展延伸（抽象类、类）在这里我们详细讲解下类以及抽象类。同时与接口直接的区别和相同。 类-抽象类： 1、都可被继承 2、抽象类不能被实例化，只是用来继承的，普通类可以实例化 3、抽象类只含有方法声明，没有方法体。并且只能存在于抽象类中 4、继承抽象类的子类必须实现抽象方法，除非子类也是抽象类 5、抽象类中可以包含抽象方法和实例方法 接口-抽象类： 相同 1、都可被继承 2、都可以有声明不实现的方法 3、都不可被实例化 4、子类必须实现其声明的方法 不同： 1、一个类可以继承多个接口，但是仅能继承一个抽象类 2、抽象类可包含实例方法，接口不可包含 3、接口支持回调，抽象类不支持 既然有类、抽象类、接口，那么他们分别在什么时候使用呢？ 类不用说了吧，普通情况下使用即可。 抽象类–如果需要设计大的功能单元，则使用抽象类。抽象类主要用于关系密切的对象。 接口–如果设计小而简练的功能块的话可以使用接口，接口适合为不想关的类提供通用功能 举个例子：一个围栏之间有很多的小动物，猪、狗、鸡、猫。针对这个我们设计一段程序，猪、狗、鸡、猫其都是动物，根据抽象类-设计大的功能单元。我们可以设计一个动物类的抽象类。然后在各自继承下去写自己的具体类（猪类、狗类、鸡类、猫类）。那么我们要研究他们的叫声，这里设计小的功能模块。我们就可以使用接口来设计一个叫声。然后每个每个东西去实现不同的叫声（猪叫、狗叫、鸡叫、猫叫）。设计实现大的功能单元我们选择抽象类，设计实现小而简练的功能块我们选择使用接口。 总结:c#基础知识详解系列]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础类型详解下]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[前言在上一节中，我们讲到在c#中所有的类都继承一个基类–System.Object。然后其下又分为俩大类–值类型及引用类型。这一节我们详细讲解值类型和引用类型包含了那些东西及内存的分配 堆和栈在我们讲解类型前，我们得先去了解堆和栈是什么，及其区别。我们可以先知道值类型和引用类型的引用都是分配在栈中的，而引用类型的对象分配在堆中的。我们详细看看堆和栈有啥区别及其原理吧 堆（heap）–堆的分配空间是自下到上的，已占用的空间在自由空间下面，C#中引用类型的对象及分配在堆中的，内存的分配是连续的。内存对象释放是受垃圾回收机制管理的，所有在引用对象释放时会消耗更多的性能。效率相对于栈来说是较低的。 栈（stack）–栈的分配空间是自上到下的，遵循先进先出的原则，依次释放分配的内存空间。分配的内存空间是连续的，C#中的值类型及引用类型的引用都是存放在栈中的。 当一个类的实例创建对象的的时候，这个对象的不同的成员将被分配到不用的内存空间，值类型及引用类型的引用分配到栈中，引用类型对象分配到堆中，静态成员被分配到全局数据区。这个时候栈上的指针会指向堆中实际的对象，在对象使用完成后，指针和对象会切开联系，从而使对象进入冬眠期，因为栈具有自我维护性，内存管理通过操作系统完成，而堆中的冬眠对象将有垃圾回收机制进行回收，释放对象所占的内存。 值类型及引用类型值类型： 结构体：struct（直接派生于System.ValueType） 数值类型：整型、浮点型、decimal型、bool型 枚举：enum（派生于System.Enum） 引用类型： 数组：Array（派生于System.Array） 类：class（派生于System.Object） 接口：interface 委托：delegate（派生于System.Delegate） 字符串：string(System.String) 在此特别强调：.Net中所有的元素在使用前都必须初始化，在调用new创建实例的时候，编译器会隐式的调用无参构造函数进行初始化。所有的值类型的值都为0（char为’0’），所有引用类型为null。 在此可调用IsValueType来判断类型是否为值类型 1234567StringBuilder strSql = new StringBuilder(); if (strSql.GetType().IsValueType) &#123;&#125; 引用类型中尤为注意的事string类型，它具有一特效–恒定不变性，什么意思呢？也就是说string类型一旦赋值，一旦在Heap堆中分配了内存存储对象，则再也无法改变其对象的内容。我们看下面这个例子 123String a=”aaa”;a=”bbb”; 在这个例子中先是对象a创建在堆中分配内存存储’aaa’，然后又给a对象重新赋值’bbb’,其中并不是修改堆内存中对象aaa为bbb，实则是重新创建了一个堆内存对象存储’bbb’，然后把它的引用地址指向a，原来的堆内存对象’aaa’还继续保存在堆内存中，不曾修改。只有当GC垃圾回收机制处理回收，才会消失。]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
</search>
