<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——迭代器模式]]></title>
    <url>%2F2019%2F10%2F09%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 今天我们一起看看行为模式中的迭代器模式，迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。在系统开发中简单说可以理解成遍历。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层或者内部表示。 迭代器模式介绍一、来由 在系统开发中，集合对象内部表示各不相同。底层构造也尽不相同。对于这些对象，我们希望在不暴露其底层和内部表示的同时，可以使外部客户访问其中元素。迭代器模式就为这一需求提供了极其优雅的实现。 二、意图 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 三、案例图 四、迭代器模式代码示例我们从上面的案例图可见，迭代器模式主要包含以下四个部分： 抽象迭代器：**定义了访问和遍历元素的接口，然后在其子类中实现这些方法。** 具体迭代器：**实现抽象迭代器接口，完成对集合对象的遍历。同时对遍历时的位置进行跟踪。** 抽象聚合类：**主要用于储存对象，创建相应的迭代器对象的接口。带有一个createIterator()方法用于创建迭代器对象。** 具体聚合类：**实现创建相应的迭代器对象的接口，实现createIterator()方法，并且返回与该具体聚合相对应的具体迭代器ConcreteIterator实例。** 介绍完迭代器模式之后，接下来我们具体来看看迭代器模式的具体实现吧。具体如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118namespace Iterator_Pattern&#123; class IteratorPattern &#123; &#125; /// &lt;summary&gt; /// 抽象聚合类、包含一个创建迭代器对象的方法 /// &lt;/summary&gt; public interface IListAggregate &#123; Iterator GetIterator(); &#125; /// &lt;summary&gt; /// 抽象迭代器、包含访问和遍历元素的方法 /// &lt;/summary&gt; public interface Iterator &#123; /// &lt;summary&gt; /// 是否有下一个元素 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; bool IsNext(); /// &lt;summary&gt; /// 获取当前元素位置 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; object GetCurrentIndex(); /// &lt;summary&gt; /// 获取下一个元素 /// &lt;/summary&gt; void Next(); /// &lt;summary&gt; /// 获取第一个元素、相当于重置 /// &lt;/summary&gt; void Start(); &#125; /// &lt;summary&gt; /// 具体聚合类 /// &lt;/summary&gt; public class ConcreteListAggregate : IListAggregate &#123; string[] list; public ConcreteListAggregate() &#123; list = new string[] &#123; "张三", "李四", "王五", "赵六" &#125;; &#125; /// &lt;summary&gt; /// 创建迭代器对象 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public Iterator GetIterator() &#123; return new ConcreteIterator(this); &#125; /// &lt;summary&gt; /// 获取对象长度 /// &lt;/summary&gt; public int Length &#123; get &#123; return list.Length; &#125; &#125; /// &lt;summary&gt; /// 获取指定位置元素 /// &lt;/summary&gt; /// &lt;param name="index"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public object GetItem(int index) &#123; return list[index]; &#125; &#125; public class ConcreteIterator : Iterator &#123; private ConcreteListAggregate _list; private int _index; public ConcreteIterator(ConcreteListAggregate list) &#123; _list = list; _index = 0; &#125; public object GetCurrentIndex() &#123; return _list.GetItem(_index); &#125; public bool IsNext() &#123; if (_index&lt;_list.Length) &#123; return true; &#125; return false; &#125; public void Next() &#123; if (_index&lt;_list.Length) &#123; _index++; &#125; &#125; public void Start() &#123; _index = 0; &#125; &#125;&#125; 1234567891011121314151617181920namespace Iterator_Pattern&#123; class Program &#123; static void Main(string[] args) &#123; //获取迭代器对象 IListAggregate listAggregate = new ConcreteListAggregate(); Iterator iterator = listAggregate.GetIterator(); while (iterator.IsNext()) &#123; var result = iterator.GetCurrentIndex(); Console.WriteLine(result); iterator.Next(); &#125; &#125; &#125;&#125; 使用场景及优缺点一、使用场景1、访问聚合对象的内容不需要暴露其内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为了遍历不同的聚合结构对象提供统一的接口 二、优点1、访问聚合对象内容时无需暴露其内部表示。 2、迭代器模式为不同的聚合结构对象提供了统一的接口。 3、在同一个聚合对象上可以实现多种遍历。 4、增加新的聚合类和迭代类较为方便，无需修改之前的代码 三、缺点1、迭代器模式将存储数据和遍历数据的责任进行了分离。增加新的聚合类型的时候需要增加新的迭代器类。存在成对增加的。增加了系统的复杂性。 总结 迭代器模式到这里就介绍完了。迭代器模式就是通过迭代器类将集合对象的遍历行为进行区分开来。这样一来就可以不暴露集合对象的内部表示了。又可以使外部能正常的使用访问其元素。这个模式并不复杂。把握好其中每个角色的职责，进行连贯就好了。在.Net中我们也可以发现一个现成的迭代器模式。这也是最好的教程案例。I**Enumerable作为了一个抽象聚合类、IEnumerator作为一个抽象迭代器。在System.Collections命名空间之下。有兴趣深究的可以去研究下。** ** 一个人如若不能使自己的人生辉煌，但也没有理由使它黯淡;人生可以平凡，但不可以庸俗、堕落;人生不在乎掠取多少，而在于追求过程的完美与卓越!**]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——命令模式]]></title>
    <url>%2F2019%2F09%2F26%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 今天我们一起来看行为型设计模式中的命令模式、何为命令模式呢？先谈命令——我现在需要对某一条信息进行删除，我进行点击删除按钮。后台执行删除的命令、对信息进行删除。那么我们要讲的命令模式又是什么呢？命令模式就是把一个操作或者行为抽象为一个对象。然后通过对命令的抽象化来使得发出命令的职责和执行命令的职责分隔开。简单来说命令模式就是解决命令的请求者和命令的执行者之间的耦合关系的。 命令模式介绍一、来由 在我们开发软件系统的时候，命令的请求者和命令的执行者是属于紧耦合的状态。但是对于某些特殊场合这么一种紧耦合的状态就不合适了。例如对行为命令的”日志记录、撤销/恢复、命令的队列”等操作就不太合适了。那么在这些情况下如何对这些命令进行统一的管理呢？实现其松耦合呢？ 二、意图 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。 三、案例图 四、命令模式代码示例我们看上面的案例图可以看到命令模式是包含了以下五个部分的： 客户角色：创建具体的命令对象并确定命令对象的接收者 命令请求者：命令模式中最重要的角色、持有命令对象、实现对命令的控制、要求命令对象执行请求 命令接收者：真正的命令的执行者、实现具体功能 命令角色：声明所有的命令的一个抽象类 具体命令角色：命令接口实现对象、持有命令接收者、调用接收者完成命令的执行 在我们日常软件开发过程中必定会涉及到信息的增删改查、一般的信息进行操作也就罢了。但是对于一些重要的信息进行操作的时候我们是否就需要对其进行控制了。比如对其操作的日志的记录。对操作命令的撤销恢复。这里我们看看如何使用命令模式来对命令进行控制操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100namespace Command_Pattern&#123; class CommandPattern &#123; &#125; #region 命令接收者——具体操作 =================== /// &lt;summary&gt; /// 执行命令 /// &lt;/summary&gt; public class InfoReceiver &#123; public void Delete() &#123; Console.WriteLine("删除了第一条信息!"); &#125; public void Update() &#123; Console.WriteLine("更新了第二天信息!"); &#125; &#125; #endregion #region 命令请求者——控制命令 =================== /// &lt;summary&gt; /// 控制命令调用请求 /// &lt;/summary&gt; public class InfoInvoke &#123; /// &lt;summary&gt; /// 记录上一个命令 /// &lt;/summary&gt; private Command lastCommand =null; /// &lt;summary&gt; /// 接收当前命令 /// &lt;/summary&gt; private Command _command = null; public InfoInvoke(Command command=null) &#123; this._command = command; &#125; public string ExecuteInvoke() &#123; if (_command==null&amp;&amp; lastCommand==null) return ("无命令执行!"); if (_command == null) &#123; Console.WriteLine($"记录此操作记录&#123;_command.GetType().Name&#125;的撤销操作!"); _command = lastCommand; return ("执行撤销操作!"); &#125; Console.WriteLine($"记录此操作记录&#123;_command.GetType().Name&#125;!"); _command.Execute(); return ("执行成功!"); &#125; &#125; #endregion #region 命令角色——抽象命令 ===================== /// &lt;summary&gt; /// 抽象命令 持有命令接收者，调用接收者执行命令 /// &lt;/summary&gt; public abstract class Command &#123; protected InfoReceiver _infoReceiver; public Command(InfoReceiver infoReceiver) &#123; this._infoReceiver = infoReceiver; &#125; public abstract void Execute(); &#125; #endregion #region 具体命令角色——调用接收者 =============== /// &lt;summary&gt; /// 实现抽象角色 /// &lt;/summary&gt; public class InfoCommandDelete : Command &#123; public InfoCommandDelete(InfoReceiver infoReceiver) : base(infoReceiver) &#123; &#125; public override void Execute() &#123; _infoReceiver.Delete(); &#125; &#125; #endregion #region 具体命令角色——调用接收者 =============== /// &lt;summary&gt; /// 实现抽象角色 /// &lt;/summary&gt; public class InfoCommandUpdate : Command &#123; public InfoCommandUpdate(InfoReceiver infoReceiver) : base(infoReceiver) &#123; &#125; public override void Execute() &#123; _infoReceiver.Update(); &#125; &#125; #endregion&#125; 12345678910111213141516171819namespace Command_Pattern&#123; class Program &#123; static void Main(string[] args) &#123; ///初始化命令接收者和命令请求者还有具体命令 InfoReceiver infoReceiver = new InfoReceiver(); InfoCommandDelete infoCommandDelete = new InfoCommandDelete(infoReceiver); InfoInvoke infoInvoke = new InfoInvoke(infoCommandDelete); var result=infoInvoke.ExecuteInvoke(); Console.WriteLine(result); &#125; &#125;&#125; 使用场景及优缺点在命令模式中重点就是实现将“行为请求者”和“行为实现者”之间进行解耦。而在命令请求者角色中可以对具体命令角色做一定的控制、同时也可以保存其额外的状态信息。 一、使用场景1、认为是命令的地方都可以使用命令模式 2、系统支持命令的撤销/恢复、重新执行等操作的时候可以考虑使用命令模式 3、命令的发送者和命令执行者有不同的生命周期，不要求命令发送必须立马执行 4、命令需要进行管理控制时 二、优点1、降低了系统的耦合性 2、新的命令可以很容易添加到系统中 3、可以将命令组合在一起形成合成命令 4、可以设计实现撤销、重新执行的操作 三、缺点1、使用命令模式可能导致有过多的具体命令类、这样会使系统变得不切实际。 总结 到这里我们就介绍完了命令模式。总的来说命令模式是将”行为请求者”和”行为实现者”进行了解耦。解耦之后就方便对命令进行控制管理（操作信息日志记录、撤销/恢复操作、重新操作、命令队列等等）。同时对新的命令加入也方便了一些（方便对命令扩展）。 一个人如若不能使自己的人生辉煌，但也没有理由使它黯淡;人生可以平凡，但不可以庸俗、堕落;人生不在乎掠取多少，而在于追求过程的完美与卓越!]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.Net_Core 3.0 gRPC部署问题解决]]></title>
    <url>%2F2019%2F09%2F25%2FNet_Core%203.0%20gRPC%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[前言 .Net Core3.0终于如约而至的来了。在3.0中增加了许多东西、也有了许多的变化。今天我们看的就是在3.0中使用gRPC并遇到的问题。gRPC现在可以非常方便简洁的在.Net Core中使用了，今天我也是尝试了一下，但是不幸了是遇到了一些阻碍。我们一起看看是啥问题吧。 gRPC介绍 gRPC 是google开源的一个高性能、跨语言的RPC框架，基于HTTP2协议，采用ProtoBuf 定义的IDL。 优点： 1. 现代高性能轻量级的RPC框架 2.协定优先 API 开发，默认使用协议缓冲区，允许与语言无关的实现 3.可以实现多语言的工具 4.protobuf二进制序列化，性能好/效率高 5.基于Http2.0 在ASP.NET Core 3.0中使用gRPC也有许多文章进行了介绍，我也是看了这些文章进行的学习。大家也是可以自行去查找的。 部署问题 按照在ASP.NET Core 3.0中使用gRPC的文章中的教程一步一步的创建项目，编写代码。一套流程走下来那是行云流水。编写完之后在本地就开始进行测试。先跑起来服务端。在跑客户端。看到客户端上的消息返回。成功了。第一次就成功，果然是更加简单了。其中有两点需要注意的是因为在3.0中使用的gRPC是基于Http2.0的。而它又需要HTTPS，尽管说没有明确规定必须使用HTTPS，但是为了安全在浏览器实现上都要求了HTTPS，所以现在的HTTP/2和HTTPS基本都是一对。 所以我们在本地运行的时候会出现一个弹框，询问我们是否信任证书。下面我的问题也就和这个有关了。本地运行一切正常。我就想搬到服务器上去试试看行不行。结果接过上去服务端是跑起来了，结果客户端运行起来就报错了。 12Unhandled exception. System.Net.Http.HttpRequestException: The SSL connection could not be established, see inner exception. ---&gt; System.Security.Authentication.AuthenticationException: The remote certificate is invalid according to the validation procedure. 解决方案1、修改https为http（不行、大错特错） 这个报错我就有点纳闷了，我首先检查环境，发现都是对的。就有点纳闷了。然后看是连接失败。我就尝试修改https为http。结果还是错误的。这个方法就被抛弃了。（修改之后会导致客户端和服务端的SSL/TLS 配置不匹配。.Net Core客户端必须在https服务器地址中使用才能正确的使用安全连接） 2、信任证书（可行） 仔细查看错误，发现最后标明是证书无效。这是想起我们在本地第一次运行的时候弹窗提示我们是否信任证书。好像就是这个关系了。照这个路子想下去。找到在如何安装 ASP.NET Core HTTPS 开发证书。然后我们再试试、果然就可以了。 1dotnet dev-certs https --trust 3、忽略无效证书（可行） 后面又发现了一种解决方案，既然是证书无效导致的问题，那么忽略无效证书是不是可以呢？然后我们换一台服务器，继续尝试一下。在代码中加上忽略无效证书的代码。然后再次进行尝试发现也是可以的。不过这里需要注意的是这个忽略无效证书在开发过程中使用即可，换到生产环境还是替换成有效证书 123456var httpClientHandler = new HttpClientHandler(); // Return `true` to allow certificates that are untrusted/invalidhttpClientHandler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator; var httpClient = new HttpClient(httpClientHandler); var channel = GrpcChannel.ForAddress("https://localhost:5001",new GrpcChannelOptions &#123; HttpClient = httpClient &#125;); var client = new Greeter.GreeterClient(channel); 总结 在我们使用在.Net Core 3.0中使用gRPC的时候，需要注意的时候保持客户端和服务端的SSL/TLS配置的匹配，基于HTTP2.0，使用https进行连接。证书的问题也就是在开发环境时出现解决，在正式生产环境中我们还是需要使用有效证书的。 *平凡人生要用平凡的心去对待，你的人生将会更精彩。 *]]></content>
      <categories>
        <category>.Net Core</category>
      </categories>
      <tags>
        <tag>.Net Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——模板方法模式]]></title>
    <url>%2F2019%2F09%2F24%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 我们学习了解完了创建型设计模式和结构型设计模式，今天我们开始学习并了解行为型设计模式。今天我们首先来看这么一个设计模式——模板方法模式。这个模式我们在平常开发中总会不自觉的使用到。就像我们平时一样的各种网站模板、建立模板、PPT模板等等。啥意思呢？简单，也就是把共同的东西拿出来，你需要具体去实现你自己的那么就另外加上自己的特有行为就是了。我们一起来看看详细的解释介绍吧。 模板方法模式介绍一、来由在我们平时的系统开发中，经常会遇到一些方法，出现大部分一样的代码。也就是常常有一些稳定的框架结构，但是其中的一些细小的操作却是在变化。我们现在如何在稳定框架结构的前提下去实现不同的细节呢？ 二、意图定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 三、案例图 四、模板方法模式代码示例看上面的案例图，看出模板方法模式由两个部分组成： 抽象类：定义了一个模板方法，其中包含执行的步骤。还有固定方法和抽象方法 具体类：实现抽象方法具体行为 我们来看看下面这个代码示例，帮助我们更进一步了解其实现。 就拿我们写文章来说，步骤都是打开编辑器——写文章——保存发布。不同的就是我们写的文章的主题内容不一样罢了。我们一起看起代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263namespace Template_Method_Pattern&#123; class TemplateMethodPattern &#123; &#125; #region /// &lt;summary&gt; /// 抽象类型 /// &lt;/summary&gt; public abstract class WriteArticle &#123; /// &lt;summary&gt; /// 这个就是模板方法，定义了写文章的顺序。这里不能使用抽象和Virtual，防止其子类修改执行顺序。 /// &lt;/summary&gt; public void Article() &#123; OpenEditor(); Write(); Release(); Console.WriteLine("文章完成了并发布了!"); &#125; /// &lt;summary&gt; /// 打开编辑器 /// &lt;/summary&gt; public void OpenEditor() &#123; Console.WriteLine("打开编辑器"); &#125; /// &lt;summary&gt; /// 开始写文章，其子类具体实现文章内容 /// &lt;/summary&gt; public abstract void Write(); /// &lt;summary&gt; /// 发布文章 /// &lt;/summary&gt; public void Release() &#123; Console.WriteLine("发布文章"); &#125; &#125; #endregion /// &lt;summary&gt; /// 技术文章 /// &lt;/summary&gt; public class TchnologyArticle : WriteArticle &#123; public override void Write() &#123; Console.WriteLine("设计模式相关的文章"); &#125; &#125; /// &lt;summary&gt; /// 生活文章 /// &lt;/summary&gt; public class LifeArticle : WriteArticle &#123; public override void Write() &#123; Console.WriteLine("生活文章"); &#125; &#125;&#125; 12345678910111213class Program&#123; static void Main(string[] args) &#123; //技术文章 WriteArticle writeTchnology = new TchnologyArticle(); writeTchnology.Article(); //生活文章 WriteArticle writeLife = new LifeArticle(); writeLife.Article(); &#125;&#125; 使用场景及优缺点一、使用场景1、许多的子类都包含相同的方法，逻辑共通 2、重要复杂的方法可以考虑作为模板方法 二、优点1、共用部分方法实现代码复用、编译维护 2、固定父类顺序，扩展子类实现。灵活变化、符合开闭原则 3、行为由父类控制、实现子类控制 三、缺点1、没实现一个不同的需求就会增加一个子类，这样会导致类的个数增加，增加系统的大小 2、需要开发人员花费更多的时间去整理和清理其中的关系 总结 到这里模板方法模式就介绍完了。总的来说就是模板方法模式定义了功能的实现步骤，然后抽象类对步骤进行控制，需要扩展的延迟到其子类进行扩展。从而子类可以复用父类的代码。当然这也还是基于继承来实现代码复用的一种方法。在我们开发的时候有一些系统定义的东西不符合我们的需求。他们在开发中也是固定好了一定的骨架，其中一些方法留了出来，方便我们开发人员自己重新定义。这么一个模板方法模式在我们日常开发中可能经常用到。有时候自己都不知觉的就使用到了。这也是一个较为简单且基础的模式。 平凡人生要用平凡的心去对待，你的人生将会更精彩。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——代理模式]]></title>
    <url>%2F2019%2F09%2F11%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 今天讲的是结构型设计模式中的最后一个，这个模式也就是代理模式，在前段时间我写的一篇关于正向代理和反向代理的文章。虽说此代理非彼代理。但是代理一词还是具有相似的含义的。这里我们继续使用文章中的代购一个例子来讲述一下代理模式吧，人不方便去购买哪些物品，这时就有一个中间人，他来购买。他代替我去购买。他也就充当了那个代理的职责。我们继续往下看吧。 代理模式介绍一、来由 在软件系统的开放中，有一些对象存在，但是直接访问会给使用者带来一些麻烦，或者使用起来不那么方便，这是就是需要一个代理对象来中间起到关键作用。通过这个代理对象进行访问，以来解决这些问题。这也就是代理模式。 二、意图 为其他对象提供一种代理以控制对这个对象的访问。 三、案例图 四、代理模式代码示例看上面的案例图，我们发现代理模式包含以下部分：抽象角色：定义代理角色和真实角色的公共接口，这样来说使用真实角色的地方就可以使用代理角色。 代理角色：包含对真实角色的引用，这样可以操作真实角色，代理角色不仅仅只是调用真实角色，也会执行其他的操作。 真实角色：定义了代理角色所代表的真实角色。 这里我们使用的是一个代理进行代购的案例来进行讲述，让我们一起看看如何实现的吧：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768namespace Proxy_Pattern&#123; class ProxyPattern &#123; &#125; #region 抽象角色——抽象需要做的事情的方法 public abstract class Buy &#123; public abstract void BuyFun(string Name); &#125; #endregion #region 真实角色——实现抽象的方法 public class RealBuy : Buy &#123; public override void BuyFun(string Name) &#123; Console.WriteLine($"帮我购买&#123;Name&#125;"); &#125; &#125; #endregion #region 代理角色——代购 public class ProxyBuy : Buy &#123; public RealBuy realBuy; public ProxyBuy() &#123; realBuy = new RealBuy(); &#125; public override void BuyFun(string Name) &#123; var flag= this.AllowBuy(Name); if (!flag) &#123; Console.WriteLine("违禁品不允许购买"); &#125; else &#123; realBuy.BuyFun(Name); Recording(Name); &#125; &#125; /// &lt;summary&gt; /// 代理模式中的额外操作。例如购买的东西，不可能啥东西都买。需要对购买的东西进行检查 /// &lt;/summary&gt; /// &lt;param name="Name"&gt;购买的东西&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool AllowBuy(string Name) &#123; if (Name!="违禁品") &#123; return true; &#125; return false; &#125; /// &lt;summary&gt; /// 对购买的东西进行记录 /// &lt;/summary&gt; /// &lt;param name="Name"&gt;&lt;/param&gt; public void Recording(string Name) &#123; Console.WriteLine($"这次代购购买了&#123;Name&#125;"); &#125; &#125; #endregion&#125; 123456789101112131415namespace Proxy_Pattern&#123; class Program &#123; static void Main(string[] args) &#123; //初始化代理对象 Buy buy = new ProxyBuy(); //代理对象进行处理事务 buy.BuyFun("化妆品"); buy.BuyFun("违禁品"); &#125; &#125;&#125; 使用场景及优缺点 不管是使用怎样的代理，都是在软件系统中增加一个中间层次，这种方式对于解决一些复杂问题或者对象之间的问题提供了较大方便。代理模式又划分了许多的类型，待会下面我们会一一介绍的。代理模式并不要求保持各个类之间的接口的一致性，代理模式的重点是间接控制，中间层次管理。 一、使用场景根据代理模式的职责我们可以分为以下的使用场景：远程代理： 为两个不同地址的对象信息代理，典型例子就是客户端与服务之间。客户端调用服务。 虚拟代理： 根据需要创建一个资源消耗较大的对象，使得对象在需要的时候才会被调用。 Copy-on-Write 代理： 属于虚拟代理的一种，把复制或者克隆拖延到客户端需要的时候才执行。 保护（Protect or Access）代理： 控制对象的访问，提供不同级别使用的不同的访问权限。 Cache代理： 为一个目标的结果提供一个临时的保存空间，以便于多个客户端可以使用这些结果 防火墙（Firewall）代理： 保护目标不受恶意侵犯 智能引用（Smart Reference）代理： 当一个对象被调用引用的时候，提供一些额外的操作，可以把调用的次数或调用的位置记录下来。 二、优点1、增加了中间代理层，降低了客户端与对象之间的耦合度 2、中间的代理对对象增加了保护层次，同时也可以增加一些额外的操作例如权限控制、智能化 3、职责清晰明了。抽象—真实—代理三、缺点1、由于增加了代理对象，有些情况可能会造成代理之间的请求变慢 2、由于增加了代理对象，增加了一些额外的工作，造成了系统的复杂度总结 到这里设计模式中的结构型的各个设计模式我就介绍完了。最后一个代理模式，理解起来也是相对简单的。重点理解代理一词。再回首、看看我们也将看完了设计模式三个部分中的两个部分。创建型——解决对象创建的问题，对象之间解耦的问题。结构型——主要解决的是类和对象之间的结构问题。这里又包括类结构和对象结构问题。这里我们再来回顾一下结构型设计模式及其重点吧 适配器模式——注重转换接口，使接口匹配、达到复用的目的 桥接模式——注重接口和实现的分离，注重多维度的变化。 装饰模式——注重稳定接口的前提下对对象进行扩展 组合模式——注重将一对多转换为一对一，树型结构层次的关系 外观模式——简化接口和客户端之间的调用依赖关系 享元模式——注重最小单元对象的共享 代理模式——增加中间层次实现控制 不要为它的结束而哭，应当为它的开始而笑。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——享元模式]]></title>
    <url>%2F2019%2F09%2F10%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 今天我们继续讲述设计模式，今天提及的是享元模式，享——共享。之前不是出现了一系列共享的东西吗？为啥呀，还不就是有些东西每个人都需要，但是每个人都去买一个又有点浪费。所以出现共享。话费一定的经济可以使用，使用完成之后又归还。这就是享。分享共享。今天讲的享元模式跟这相类似。享元模式——通俗来说也就是共享最小单元的一种模式。我们就一起看看到底啥是这享元模式吧。 享元模式介绍一、来由 在软件系统开发中，我们肯定会出现重复使用同一个对象的情况，每次使用都new一个对象出来。这样的话对于内存来说就需要多次反复的申请内存了。这样使用内存也就越来越多，这会出现大问题的。那么能不能创建new一个对象。然后使用的时候就共同使用一个就好了。这也就是享元模式的含义所在了——共享一个对象。 二、意图 运用共享技术有效地支持大量细粒度的对象。 三、案例图 四、享元模式代码示例 看上面的案例图我们可以发现享元模式主要包含以下部分： 享元工厂角色：这个角色主要负责创建和管理享元角色。判断是否存在符合要求的享元对象，如果存在则直接拿取，如果不存在的话就会创建一个享元对象并保存。 抽象享元角色：这个角色是所有享元角色的基类。提供需要实现的公共接口 具体享元角色：继承于抽象享元角色。实现其抽象的接口。 客户端：负责调用并处理逻辑，且保存多有享元对象的状态 在我们平时使用的编辑器中，会出现很多的字，这些字也是会一直重复出现的。那么我们现在就试着使用享元模式来对这些字进行处理。这里暂且使用字母代替： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263namespace Flyweight_Pattern&#123; class FlyweightPattern &#123; &#125; #region 抽象享元角色——抽象公共接口 public abstract class Flyweight &#123; /// &lt;summary&gt; /// 表述输出的位置 /// &lt;/summary&gt; /// &lt;param name="externalstate"&gt;外在的状态，随着环境改变而改变&lt;/param&gt; public abstract void OutInput(int externalstate); &#125; #endregion #region 具体享元角色——实现其具体 public class SpecificFlyweight : Flyweight &#123; private string Innerstate; /// &lt;summary&gt; /// 内部状态接收 /// &lt;/summary&gt; /// &lt;param name="innerstate"&gt;内部状态&lt;/param&gt; public SpecificFlyweight(string innerstate) &#123; this.Innerstate = innerstate; &#125; /// &lt;summary&gt; /// 实现方法 /// &lt;/summary&gt; /// &lt;param name="externalstate"&gt;外部状态&lt;/param&gt; public override void OutInput(int externalstate) &#123; Console.WriteLine($"内部状态：&#123;Innerstate&#125;————外部状态：&#123;externalstate&#125;"); &#125; &#125; #endregion #region 享元工厂角色——对享元角色进行创建及管理的 public class FlyweightFactory &#123; public Dictionary&lt;string, SpecificFlyweight&gt; keyValuePairs = new Dictionary&lt;string, SpecificFlyweight&gt;(); public SpecificFlyweight GetFlyweight(string Key) &#123; SpecificFlyweight specific = null; if (!keyValuePairs.ContainsKey("A")) &#123; Console.WriteLine("暂时未遇见该Key"); keyValuePairs.Add(Key, new SpecificFlyweight(Key)); Console.WriteLine("现已保存该Key"); &#125; else &#123; specific = keyValuePairs[Key] as SpecificFlyweight; &#125; return specific; &#125; &#125; #endregion&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243namespace Flyweight_Pattern&#123; class Program &#123; static void Main(string[] args) &#123; ///初始化享元工厂 FlyweightFactory factory = new FlyweightFactory(); while (true) &#123; Console.WriteLine("请输入字符的位置："); var indexstring = Console.ReadLine(); if (int.TryParse(indexstring, out int index)) &#123; Console.WriteLine("请输入字符:"); string str = Console.ReadLine(); ///判断字符是否创建 Flyweight flyweight = factory.GetFlyweight(str); //如果存在则输出信息 if (flyweight != null) &#123; flyweight.OutInput(index); &#125; &#125; else &#123; Console.WriteLine("请输入数字!"); &#125; Console.WriteLine("结束请输入N"); if (Console.ReadLine()=="N") &#123; break; &#125; &#125; Console.WriteLine("已结束"); Console.ReadLine(); &#125; &#125;&#125; 使用场景及优缺点 这里我们需要注意的是划分好外部状态和内部状态，否则混淆之后可能引起线程安全问题。同时必不可少的是一个工厂对象进行控制。 这里我们解释下在享元模式中的内在状态和外在状态： 内在状态：不随环境的变化而变化，上面例子中不管位置如何变化,A就是A。字母A就是内在状态。 外在状态：会随着环境的变化而变化，上面例子中位置变化所以输出的位置也是不一致的。字母A的位置就是外在状态 一、使用场景 对于享元模式来说其使用场景可分以下四点： 1、系统需要大量相似对象 2、创建这些对象需要花费大量资源 3、状态可分为内在状态和外在状态，可以根据内在状态分为各种组。 4、需要缓冲池的场景 二、优点1、享元模式的优点最主要的是极大的减少了系统中对象的创建，降低了内存使用提高了效率 三、缺点任何东西来说都是有利有弊的，我们看下享元模式又存在哪些弊端呢 1、为了使一些对象共享，对对象区分了内在状态和外在状态，使系统逻辑变为复杂了，使系统更加难于理解了。 总结 今天的享元模式就暂时介绍的这么多，享元模式精髓也就是达到对象的共享，达到共享的话就需要抽出一部分东西达到相似。所以这又区分了内在状态和外在状态。内在状态不随环境变化而变化，属于可共享的。而外在状态随着环境改变而改变，所以不能共享的。在.Net开发中，我们经常使用到的额String类型的实现就采用了享元模式的设计。在string中具有相同字符序列的String对象不会重复创建。具体细节想要研究的可以自行查询资料。在我们使用设计模式的时候有一些点还是需要多次强调及注意的。基于原则设计。视情况采用设计模式。不要为了使用设计模式而去使用设计模式。一切都是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 勇敢的面对不一定成功，但你不面对就一定不成功。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——外观模式]]></title>
    <url>%2F2019%2F08%2F24%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 今天一起来看看外观模式，外观模式也是我们介绍的结构型设计模式的第五个模式了。外观外表，有句话是这么说的人靠衣装 佛靠金装。打扮的好，整理的好。外观靠上去整整齐齐，精气神一下就上来了。在开发中依然如此。客户端完成一个功能，可能需要调用许多的接口来配合。按照开发逻辑一个一个依次对接下来。客户端代码复杂，看上去一团糟。不说其他的，就表面上看起来就不怎么好吧。那么不如我们把调用的接口进行再次的封装。统一规范。这样整理下来。客户端就明了多了。 外观模式介绍一、来由 在软件系统开发中，我们经常会遇到客户端与内部子系统进行负责耦合的情况。从而导致客户端随着子系统的变化而变化。为了解决客户端与子系统直接的高耦合，并且简化接口的调用。也就有了外观模式。 二、意图** 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。** 三、案例图 四、外观模式代码示例 看上面我们发现外观模式包含以下角色： ** 外观角色： 在客户端调用外观角色的方法，其中与一个或多个子系统相关联。在运行情况下，客户端请求传递到外观角色然后传递给对应的子系统。** ** 子系统： 在软件系统中包含一个或者多个子系统，子系统可以单独被客户端调用，子系统不知道外观角色的存在。相对而言，也可以当外观角色为客户端。** 我们看这么一个案例，通过案例我们来详细了解外观模式到底是怎么一回事以及如何运行的。例如我们现在有的软件系统。新用户在输入手机号填入验证码就登录注册都搞定了。同时还附加了一些第一次登录注册的奖励。如果不按外观模式来的话，我们在登录按钮后面的客户端依次调用了注册、登录、赠送奖励等等方法。那么我们看看外观模式如何解决呢： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace Facade_Pattern&#123; #region 外观角色 public class FacadePattern &#123; private RegisteredClass registeredClass; private LoginClass loginClass; private SendClass sendClass; public FacadePattern() &#123; registeredClass = new RegisteredClass(); loginClass = new LoginClass(); sendClass = new SendClass(); &#125; public void LoginFirst() &#123; registeredClass.Registered(); loginClass.Login(); sendClass.Send(); &#125; &#125; #endregion #region 子系统 public class RegisteredClass &#123; public void Registered() &#123; Console.WriteLine("注册成功"); &#125; &#125; public class LoginClass &#123; public void Login() &#123; Console.WriteLine("登录成功"); &#125; &#125; public class SendClass &#123; public void Send() &#123; Console.WriteLine("赠送成功"); &#125; &#125; #endregion&#125; 12345678910class Program&#123; static void Main(string[] args) &#123; //第一次注册登录 FacadePattern facadePattern = new FacadePattern(); facadePattern.LoginFirst(); &#125;&#125; 使用场景及优缺点 在软件开发中，外观模式提供了一个统一的接口，用来访问那么一群接口，相当与外观模式是一个高层接口，使子系统使用更加方便，避免了客户端与子系统之间的紧耦合。客户端直接通过调用外观角色就可以调用子系统中的方法了。 一、使用场景1、为复杂的模块或子模块提供外界访问的模块 2、提供子系统的独立性 3、在层次分明的结构下可以使用外观模式提供入口。三层架构就是这样的 二、优点1、减少了系统间的相互依赖 2、提高了灵活性，简化了接口，使用更加方便了 三、缺点1、不符合开闭原则，如果要修改较为麻烦 总结 到这里外观模式就介绍完了，外观模式为一个或者多个子系统提供一个统一的接口，该模式定义了一个高层，使得使用子系统更加方便容易。并且外观模式可以解决层次分离结构，降低客户端与子系统之间的耦合。对于外观模式侧重点是整个系统的一种架构设计，与之相比我们可以看看结构型的四种设计模式。适配器模式——注重接口转换，达到适配使用。桥接模式——注重分离现象与实现，并联合。装饰模式——注重动态的增加职责功能。组合模式——注重部分—整体，对对象进行扩展。 人都有以第一印象定好坏的习惯,认为一个人好时，就会爱屋及乌，认为一个人不好时，就会全盘否认。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——装饰模式]]></title>
    <url>%2F2019%2F08%2F24%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 今天介绍的是结构型设计模式中的——装饰模式（Decorator Pattern），也是装饰器模式。装饰也就是装点修饰。例如我们对手机进行装饰，买了一个新的手机，先贴个钢化膜。在带一个壳。偶尔还在背面贴点贴纸。装一些挂件。这些等等行为也就是装饰。生活中的装饰是如此，那么编程中的装饰模式又是如何呢？ 装饰模式介绍一、来由 在我们平常的软件系统中，经常会面临着向现有的对象添加一些新的功能或者新的职责，但是呢？又不能修改现有的类。以往常用的可能是继承来解决次问题。但是采用继承来说，随着扩展功能的增加，子类会变化的很膨胀。那么装饰器模式呢就解决这么一个问题，装饰器模式允许向一个现有的对象添加新的功能职责，同时又不改变其结构。将其功能职责划分。 二、意图 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 三、案例图 四、装饰模式代码示例看上述案例图，装饰模式包含以下部分组成： 抽象构件角色： 给出一个抽象接口，以规范准备接收新加的责任 具体构件角色： 继承抽象构件角色，定义一个将要接收新加责任的类 装饰角色： 继承抽象构件角色，包含一个构件角色对象的实例，并且实现抽象构件角色的接口 具体装饰角色： 继承装饰角色，负责新加责任。 我们继续看手机的案例，今天新买了一个手机，需要新加钢化膜，手机壳，然后才是一个我想要的手机。在这儿之后突然又想加一个挂件增加美感。我们看下如何使用装饰模式来实现手机装饰的问题吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100namespace Decorator_Pattern&#123; class DecoratorPattern &#123; &#125; #region 抽象构件角色——抽象手机（抽象一个接口，准备接收新增的责任）========= /// &lt;summary&gt; /// 手机抽象类 /// &lt;/summary&gt; public abstract class Phone &#123; public abstract void Write(); &#125; #endregion #region 具体抽象构件角色——具体手机（实现抽象接口）=============================== public class HuaweiV9Phone : Phone &#123; public override void Write() &#123; Console.WriteLine("对荣耀V9手机开始装饰"); &#125; &#125; #endregion #region 装饰抽象角色——继承抽象构件角色，包含一个抽象构件角色对象的实例 /// &lt;summary&gt; /// 装饰角色 /// &lt;/summary&gt; public abstract class Decorator : Phone &#123; public Phone _phone; protected Decorator(Phone phone) &#123; this._phone = phone; &#125; public override void Write() &#123; if (_phone!=null) &#123; _phone.Write(); &#125; &#125; &#125; #endregion #region 具体装饰角色——手机加上钢化膜 /// &lt;summary&gt; /// 具体装饰角色 /// &lt;/summary&gt; public class Membrane : Decorator &#123; public Membrane(Phone phone) : base(phone) &#123; &#125; public override void Write() &#123; base.Write(); AddMembrane(); &#125; public void AddMembrane() &#123; Console.WriteLine("手机加上了钢化膜!"); &#125; &#125; #endregion #region 具体装饰角色——手机加上壳 /// &lt;summary&gt; /// 具体装饰角色 /// &lt;/summary&gt; public class Shell : Decorator &#123; public Shell(Phone phone) : base(phone) &#123; &#125; public override void Write() &#123; base.Write(); AddShell(); &#125; public void AddShell() &#123; Console.WriteLine("手机加上了壳!"); &#125; &#125; #endregion #region 具体装饰角色——手机挂件 /// &lt;summary&gt; /// 具体装饰角色 /// &lt;/summary&gt; public class Pendant : Decorator &#123; public Pendant(Phone phone) : base(phone) &#123; &#125; public override void Write() &#123; base.Write(); AddPendant(); &#125; public void AddPendant() &#123; Console.WriteLine("手机加上了挂件!"); &#125; &#125; #endregion&#125; 123456789101112131415161718192021222324252627class Program&#123; static void Main(string[] args) &#123; //现在获得了一个手机 Phone phone = new HuaweiV9Phone(); //裸机一个，先贴个膜 Decorator membrane = new Membrane(phone); membrane.Write(); Console.WriteLine(); //还是觉得不顺眼，再加个外壳看看 Decorator membraneShell = new Shell(membrane); //现在我同时有钢化膜和外壳了 membraneShell.Write(); Console.WriteLine( ); //这时候我觉得还是不要外壳了。我需要同时又钢化膜和手机挂件 Decorator membranePendant = new Pendant(membrane); membranePendant.Write(); Console.WriteLine(); Console.ReadLine(); &#125;&#125; 使用场景及优缺点一、使用场景1、需要扩展类的功能或者为类增加新增的责任 2、需要动态增加功能或者撤销功能 二、优点1、装饰类与被装饰类可以独立发展，不会互相耦合， 极易扩展、符合开闭原则 2、装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。 三、缺点1、增加系统复杂度，更加易于出错，难于排查错误。增大了学习与理解的难度。 总结 装饰模式到这里就短暂的介绍完了。在平常中，装饰模式使用的情况较多。一般来说，我们扩展一个类经常选择继承的方式，但是由于继承是为类引入静态的特征。并且随着功能增加的越来越多，子类会越来越膨胀。装饰模式是可以替代继承方式的。前面结构型的设计模式也学习了适配器模式与桥接模式。再加上今天学习的装饰模式。我们都需要细细分析其区别及使用场景，以便于后期使用时不至于混淆其用法。要用的恰到好处。 只有经历过地狱般的折磨，才有征服天堂的力量。只有流过血的手指才能弹出世间的绝唱。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——组合模式]]></title>
    <url>%2F2019%2F08%2F24%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 今天介绍的是结构型设计模式中的第四个模式，也就是组合模式（Composite Pattern）。组合模式也好理解，就拿我们电脑的文件及文件夹来说吧，这就是一个较好的组合模式的例子。一个目录下面包含文件及文件夹，文件夹下面也包含文件或文件夹。在这样一层层下来，我们可以想象。他似乎像极了那个树状图。而组合模式是依据树型结构来组合对象。用来表示部分—整体层次关系。 组合模式介绍一、来由 在我们软件系统开发中，会遇到简单对象与复杂对象一起使用的情况，就好比刚刚说的文件目录一样，可以包含文件和文件夹，文件夹下面也可以包含文件和文件夹。但是由于简单对象和复杂对象在功能使用上还是有一定的区别的，可能会造成客户端调用时较为麻烦。这时候就需要将简单对象和复杂对象统一一致对待。然而组合模式也就是解决这一麻烦的。 二、意图 将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 三、案例图 四、组合模式代码示例 看上面案例图，可以发现组合模式一般包含以下部分： 抽象构件角色： 这是一个抽象角色，它给参加组合的对象定义了公共的接口和行为，在透明式的组合模式中，包含了对所有子对象的管理。但是在安全式的组合模式中，这里不定义管理子对象的方法，而是由树枝构件定义给出。 树叶构件: 树叶构件意味着没有下级对象，定义了参加组合对象的原始行为。 树枝构件: 代表有下级对象（树枝或树叶都有可能），给出管理其子类的对象。 在组合模式中，细分为两种形式。1、透明式组合模式。2、安全式组合模式。这里我们可以看看何为透明式何为安全式： 透明式： 抽象构件角色定义公共的接口和行为，这里呢就包括对本对象的操作也包含其子对象的操作的。但是树叶构件对象没有其子类。但是依然继承其功能接口和行为。这里在接口和行为上，无论调用树枝构件还是树叶构件都是一样的。这就属于透明式了。 安全式： 由上面透明式讲的，树叶构件也会包含操作自己和子对象的接口和行为，但是没有其子对象怎么办呢？当然是可以空着不写，但会空。但是万一实现调用了呢？对吧，还是有一定的安全隐患的。那么安全式也就是说抽象构件包含操作本身对象的接口和行为，那么树叶构件也就包含操作本身对象的接口和行为了。树枝构件则实现操作自身对象的接口和行为的同时，还需要实现操作其子类的对象的接口和行为。 就按开始所讲的文件目录的案例，我们通过代码一起看看，在代码中如何实现组合模式的，这样也可以更方便快捷的了解记忆： 透明式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162namespace Composite_Pattern&#123; /// &lt;summary&gt; /// 透明式组合模式 /// &lt;/summary&gt; class CompositePattern &#123; &#125; #region 抽象构件角色——抽象文件目录============ public abstract class Files &#123; /// &lt;summary&gt; /// 增加子对象 /// &lt;/summary&gt; public abstract void Add(Files files = null, string Name = null); /// &lt;summary&gt; /// 删除子对象 /// &lt;/summary&gt; public abstract void Remove(Files files=null, string Name = null); /// &lt;summary&gt; /// 操作本身对象 /// &lt;/summary&gt; public abstract void Open(string Name); &#125; #endregion #region 树叶构件——文件类型======================== /// &lt;summary&gt; /// TXT文本 /// &lt;/summary&gt; public sealed class BookTxt : Files &#123; public override void Add(Files files=null, string Name = null) &#123; throw new NotImplementedException("不存在添加子类操作"); &#125; public override void Remove(Files files=null, string Name = null) &#123; throw new NotImplementedException("不存在删除子类操作"); &#125; public override void Open(string Name) &#123; Console.WriteLine($"打开一个名为【&#123;Name&#125;】txt文本"); &#125; &#125; #endregion #region 树枝构件——文件夹类型================= public class SubFiles : Files &#123; public override void Add(Files files=null, string Name = null) &#123; if (files != null) &#123; Console.WriteLine($"添加一个名为【&#123;Name&#125;】的文件夹"); &#125; else &#123; Console.WriteLine($"添加一个名为【&#123;Name&#125;】的txt文本"); &#125; &#125; public override void Remove(Files files=null, string Name = null) &#123; if (files != null ) &#123; Console.WriteLine($"删除一个名为【&#123;Name&#125;】的文件夹"); &#125; else &#123; Console.WriteLine($"删除一个名为【&#123;Name&#125;】的txt文本"); &#125; &#125; public override void Open(string Name) &#123; Console.WriteLine($"打开当前名为【&#123;Name&#125;】文件夹文件夹"); &#125; &#125; #endregion &#125; 12345678910111213class Program &#123; static void Main(string[] args) &#123; //操作树叶本身文件 Files bookTxt = new BookTxt(); bookTxt.Open("文本文件一"); //新增文件夹 Files subFiles = new SubFiles(); subFiles.Open("文件一"); subFiles.Add(new SubFiles(), "文件二"); //删除文件 subFiles.Remove(Name: "文本文件二"); Console.ReadLine(); &#125; &#125; 安全式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465namespace Composite_Pattern1&#123; /// &lt;summary&gt; /// 安全式组合模式 /// &lt;/summary&gt; class CompositePattern &#123; &#125; #region 抽象构件角色——抽象文件目录============ public abstract class Files &#123; /// &lt;summary&gt; /// 操作本身对象 /// &lt;/summary&gt; public abstract void Open(string Name); &#125; #endregion #region 树叶构件——文件类型======================== /// &lt;summary&gt; /// TXT文本 /// &lt;/summary&gt; public sealed class BookTxt : Files &#123; public override void Open(string Name) &#123; Console.WriteLine($"打开一个名为【&#123;Name&#125;】txt文本"); &#125; &#125; #endregion #region 抽象树枝构件——安全模式，开始定义子类对象操作接口和行为================= public abstract class SubFiles : Files &#123; public abstract void Add(Files files = null, string Name = null); public abstract void Remove(Files files = null, string Name = null); public override void Open(string Name) &#123; Console.WriteLine($"打开当前名为【&#123;Name&#125;】文件夹"); &#125; &#125; #endregion #region 具体树枝构件——具体实现类 public class AbSubFiles : SubFiles &#123; public override void Add(Files files = null, string Name = null) &#123; if (files != null) &#123; Console.WriteLine($"添加一个名为【&#123;Name&#125;】的文件夹"); &#125; else &#123; Console.WriteLine($"添加一个名为【&#123;Name&#125;】的txt文本"); &#125; &#125; public override void Remove(Files files = null, string Name = null) &#123; if (files != null) &#123; Console.WriteLine($"删除一个名为【&#123;Name&#125;】的文件夹"); &#125; else &#123; Console.WriteLine($"删除一个名为【&#123;Name&#125;】的txt文本"); &#125; &#125; public override void Open(string Name) &#123; Console.WriteLine($"打开当前名为【&#123;Name&#125;】文件夹"); &#125; &#125; #endregion &#125; 1234567891011121314class Program1 &#123; static void Main(string[] args) &#123; //操作树叶本身文件 BookTxt bookTxt = new BookTxt(); bookTxt.Open("文本文件一"); //新增文件夹 AbSubFiles subFiles = new AbSubFiles(); subFiles.Open("文件一"); subFiles.Add(new AbSubFiles(), "文件二"); //删除文件 subFiles.Remove(Name: "文本文件二"); Console.ReadLine(); &#125; &#125; 使用场景及优缺点一、使用场景1、部分——整体的环境。例如树型菜单，文件管理 2、用户希望对简单对象与复杂对象拥有一致的操作时 二、优点1、组合模式使得处理简单对象和复杂对象有一致的操作，无需关心处理的简单对象还是复杂对象 2、更简单快捷的加入新的节点 三、缺点1、使得设计复杂，难于理清层次 2、在使用透明式的时候违背了接口分离原则，但是在使用安全式的时候又违背了依赖倒置原则 总结 到这里组合模式就介绍完了。这里需要提及的是在使用透明式组合模式时，树叶构件继承了操作子类的接口和行为，但是它并没有子类。在接口分离原则中提到——客户不应被强迫依赖它不使用的方法。所以这里违背了其原则，但是都遵循了依赖倒置原则，依赖于抽象。在实现安全式组合模式时，在客户端调用时依赖于具体实现，也就违背了依赖倒置原则，但是却将树叶操作与树枝构件操作分离，符合接口分离原则。在实现组合模式中不同形式实现有不同的问题。这就需要根据我们实际情况去衡量该如何使用了。 只有经历过地狱般的折磨，才有征服天堂的力量。只有流过血的手指才能弹出世间的绝唱。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——桥接模式]]></title>
    <url>%2F2019%2F08%2F23%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 今天讲解的是结构型设计模式中的第二种——桥接模式。桥接——是指依据[OSI]网络模型的链路层的地址，对网络数据包进行转发的过程，工作在OSI的第二层。一般的交换机，网桥就有桥接作用。这是百科解释。那么今天讲的桥接模式是什么呢？桥接是一个纽带，近年的港珠澳大桥。就充当起三地连接的纽带。那么在设计模式中的桥接模式呢？也是一样，其中组成也是通过桥接、纽带连接。然后组合成所需要的东西的。我们具体看看其桥接模式的具体意义吧。 桥接模式介绍一、来由 在我们面对系统程序开发设计的时候，有时候会面临着一些类会存在两个维度的变化，在有多种可能会变化的情况下，用继承会造成较为复杂的程序后果、扩展起来不那么灵活。那么如何去面对多个角度的分类并且多个角度都可能变化的情况呢？这就需要桥接模式了。 二、意图** 将抽象部分与实现部分分离，使它们都可以独立地变化。** 三、案例图 四、桥接模式代码示例 看上面案例图显示，我们可以知道桥接模式包括以下部分： 一、抽象化角色： 抽象化给出定义，包含一个对实现化对象的引用 二、具体抽象化角色： 扩展实现抽象化角色 三、实现化角色： 这个角色给出实现化角色的接口，但不具体实现。这个 角色与抽象化角色不一定需要相同。相反可以完全不同。相当于抽象化 角色对应的是一个维度，而实现化角色对应的是第二个维度。 四、具体实现化角色： 扩展实现实现化角色 我们看这么一个案例。世人皆知手机有安卓和IOS类型。那么对于软件来说也是需要适配两种类型的。同时呢软件也是在不断迭代更新的。就这样而言。对于一个手机软件。我们暂且看两个维度。一、迭代更新版本。二、适用于手机类型。如果采用继承的方式解决此类型问题将会大大的加大系统的复杂度。这里我们就可以采用桥接模式。我们一起看看代码如何实现其设计的吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192namespace Bridge_Pattern&#123; class BridgePattern &#123; &#125; #region 抽象化角色——迭代更新的版本（包含对实现化角色对象的引用）======== public abstract class Version &#123; /// &lt;summary&gt; /// 实现对实现化对象的引用，通过组合实现软件迭代更新并适用于不同平台的功能 /// &lt;/summary&gt; protected PhoneType _phoneType; /// &lt;summary&gt; /// 构造函数注入，实现化对象的初始化 /// &lt;/summary&gt; /// &lt;param name="phoneType"&gt;&lt;/param&gt; public Version(PhoneType phoneType) &#123; this._phoneType = phoneType; &#125; /// &lt;summary&gt; /// 创建软件版本 /// &lt;/summary&gt; public abstract void Create(); &#125; #endregion #region 实现化角色——适用于手机类型============================================= public abstract class PhoneType &#123; /// &lt;summary&gt; /// 适配手机类型 /// &lt;/summary&gt; public abstract void SetType(); &#125; #endregion #region 具体抽象化角色——具体实际迭代更新的版本=========== /// &lt;summary&gt; /// 版本1.0 /// &lt;/summary&gt; public class OneVersion : Version &#123; public OneVersion(PhoneType phoneType) :base(phoneType) &#123; &#125; public override void Create() &#123; Console.WriteLine("当前版本1.0"); this._phoneType.SetType(); &#125; &#125; /// &lt;summary&gt; /// 当前版本2.1 /// &lt;/summary&gt; public class TwoVersion : Version &#123; public TwoVersion(PhoneType phoneType) : base(phoneType) &#123; &#125; public override void Create() &#123; Console.WriteLine("当前版本2.0"); this._phoneType.SetType(); &#125; &#125; #endregion #region 具体实现化角色——具体实际使用类型=================== /// &lt;summary&gt; /// 安卓系统 /// &lt;/summary&gt; public class AndroidPhoneType : PhoneType &#123; public override void SetType() &#123; Console.WriteLine("当前是Android类型"); &#125; &#125; /// &lt;summary&gt; /// ios系统 /// &lt;/summary&gt; public class IOSPhoneType : PhoneType &#123; public override void SetType() &#123; Console.WriteLine("当前是IOS类型"); &#125; &#125; #endregion&#125; 1234567891011121314151617class Program&#123; static void Main(string[] args) &#123; ///1.0版本软件 安卓系统 AndroidPhoneType androidPhoneType = new AndroidPhoneType(); OneVersion oneVersion = new OneVersion(androidPhoneType); oneVersion.Create(); ///2.0 版本软件 IOS系统 IOSPhoneType iOSPhoneType = new IOSPhoneType(); TwoVersion twoVersion = new TwoVersion(iOSPhoneType); twoVersion.Create(); Console.ReadLine(); &#125;&#125; 使用场景及优缺点一、使用场景1、如果系统需要在抽象化角色和实现化角色之间构建增加一些灵活性，避免采用继承类的形式。可以采用桥接模式建立关联关系 2、如果系统不希望采用继承形式或者继承形式会导致系统极为复杂，可以考虑采用桥接模式 3、如果一个类存在两个维度，且两个维度都常变化扩展，使用桥接模式再适合不过了 二、优点1、将抽象接口与实现解耦分离 2、抽象与实现相互分离，易扩展 3、实现的细节对用户透明 三、缺点1、增加了系统的理解难度及设计难度 总结 桥接模式。意如其名。就是将一个类中两个维度进行分离开来。将抽象接口与实现解耦。然后通过组合桥接关联在一起。组合使用。其两个对象都是抽象，然后其子类具体实践。由抽象接口对实现化角色的对象的引用来关联。桥接模式适合用于两个维度常变化的类。把多角度分离出来，然后让他们独立变化，减少耦合。 ** 天再高又怎样，踮起脚尖就更接近阳光。**]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——适配器模式]]></title>
    <url>%2F2019%2F08%2F22%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 前面完成了创建型的设计模式的分享，创建型的设计模式解决的是对象创建的问题。今天开始介绍结构型的设计模式，其中结构型设计模式包括：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。结构型设计模式解决的是类与对象的组合关系。今天讲结构型对象中的第一个——适配器模式。适配器模式——顾名思义嘛。在我们平常的理解中，适配器是干啥用的呢？不就是将两个原本不匹配的东西转换为匹配罢了。适配器是接口转换器，比如电源适配器，USB接口转换器等等。 适配器模式介绍一、来由 在系统程序中，我们可能会面临需求的增加或者改变，或者是应用环境的改变。常常需要将一些已经存在的类放在新的需求或者新的环境中应用。但是新的环境要求使用到的接口与现在存在的类或对象不完全匹配。那么如何去面对这样的迁移变化呢？ 二、意图 将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 三、案例图四、适配器模式代码示例 在适配器模式中一般包含以下部分的存在： 客户端： 与目标接口配合协同使用 目标接口： 与客户端协同使用 被适配角色： 表示一个已经存在了并使用的接口 适配器： 整个模式核心存在，将被适配角色转换为目标需要的接口。 接下来我们看下这个示例，前段时间笔记本那个耳机圆孔接口坏掉了。这个时候我只有手机那种圆孔耳机。但是我也需要在电脑上面使用，那怎么办呢？我不想多花钱去买一个usb耳机，也没有时间去把电脑修好。简单、我去网上买一个耳机的Usb转换器。然后就可以在电脑上使用了。在这事例中，目标接口是电脑USB耳机，被适配角色是手机圆孔耳机，适配器就是圆孔耳机转换为USB的过程、电脑则是客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859namespace Adapter_Pattern&#123; class AdapterPattern &#123; &#125; #region 目标角色——需要电脑usb耳机========================= /// &lt;summary&gt; /// 客户端需要的接口 /// &lt;/summary&gt; interface ComputerHeadsetTarget &#123; void GetComputerHeadset(); &#125; #endregion #region 被适配角色——现在存在的手机耳机===================== /// &lt;summary&gt; /// 目前已经存在的接口 /// &lt;/summary&gt; public class Adaptee &#123; public void PhoneHeadset() &#123; Console.WriteLine("我现在拥有的是手机耳机。"); &#125; &#125; #endregion #region 对象适配器——将手机耳机转换成电脑需要的usb耳机========== /// &lt;summary&gt; /// 对象适配器实现 /// &lt;/summary&gt; public class ObjectAdapter : ComputerHeadsetTarget &#123; Adaptee Adaptee = new Adaptee(); public void GetComputerHeadset() &#123; Adaptee.PhoneHeadset(); Console.WriteLine("现在加入耳机Usb转换器"); Console.WriteLine("输出：电脑使用的usb耳机"); &#125; &#125; #endregion #region 类适配器——将手机耳机转换成电脑需要的usb耳机=========== /// &lt;summary&gt; /// 类适配器的实现 /// &lt;/summary&gt; public class ClassAdapter : Adaptee,ComputerHeadsetTarget &#123; public void GetComputerHeadset() &#123; this.PhoneHeadset(); Console.WriteLine("现在加入耳机Usb转换器"); Console.WriteLine("输出：电脑使用的usb耳机"); &#125; &#125; #endregion&#125; 123456789101112131415161718class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("我现在需要电脑usb耳机"); ///对象适配器 ObjectAdapter objectAdapter = new ObjectAdapter(); objectAdapter.GetComputerHeadset(); Console.WriteLine("我现在需要电脑usb耳机"); ///类适配器 ClassAdapter classAdapter = new ClassAdapter(); classAdapter.GetComputerHeadset(); Console.ReadLine(); &#125; &#125; 使用场景及优缺点 这适配器模式主要用于一些希望被复用的类，但是这些类中的接口又与新的环境不完全匹配的情况下。老代码遗留修改中、类库迁移中用处较多。 在上面示例中写了适配器的两种实现方式，对象适配器和类适配器。对于类适配器来说既继承了目标接口类又继承了已存在接口类。在C#编程中尽量采用多组合少继承的形式进行代码编写。多继承提高了类之间的耦合性。所以对于类适配器一般情况尽量少使用。而对于对象适配器来说采用的是对象组合的方式。 一、使用场景1、系统需要复用现在的类，但是类中接口与现在环境不完全匹配 2、想要建立一个可以复用的类，用于彼此之间没有太大关联的一些类。 二、优点对象适配器： 1、可以再不修改原来的类的基础上复用原来的类，符合开闭原则 2、采用的”对象组合”，降低类之间的耦合性 类适配器： 1、可以再不修改原来的类的基础上复用原来的类，符合开闭原则 2、可以重新定义被适配角色类中一部分行为，在类适配器中被适配角色类为基类 3、仅是引用一个对象，不需要额外的字段引用实例 三、缺点对象适配器： 1、重新定义被适配角色类中部分行为困难 类适配器： 1、对于被适配角色类的子类中的一些方法就不能进行转换了，因为没有引用其实例，仅继承基类。所以只能调用基类中的方法。 2、采用了多继承的方式。提高了类之间的耦合性 总结 大家会不会觉得Adapter这个单词这么熟悉呢？我刚看的时候也觉得蛮熟悉的样子。应该大多数人都写过DBHelper这个数据库辅助类吧，在数据库连接操作过程中存在着DataSet 对象和 DataAdaper 对象。 DataAdaper 也就是数据适配器，负责把DataSet与真实数据源连接起来。 DataAdaper 获得数据，然后将数据填充到 DataSet对象中。针对于数据库与DataSet之间的一种适配。这也是.NET中一种适配器模式的实现。 天再高又怎样，踮起脚尖就更接近阳光]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——原型模式]]></title>
    <url>%2F2019%2F08%2F21%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 前面几章我们介绍了创建型设计模式的部分内容，今天我要说的是创建型设计模式中最后一个——原型模式，原型模式是创建型模式中的一种较为特殊的模式，有个最大的特点是克隆一个现有的对象，在我们日常软件系统开发中，某些对象的创建new即为复杂，而且我们需要使用多个相同的实例，这样如果我们依旧使用new去进行创建。就会增加系统的复杂度和增加代码之间的耦合度。但是我们使用前面介绍的工厂模式的话，随着产品类型的增多，子类也会随之增多。维护代码的难度也就会越来越大，所以这里暂时不适合使用工厂模式。由于实例都是一样的，类型相同。但是实例的参数和状态可能不同。这里有一个对象，然后再结合我们今天要讲述的原型模式。可以通过一个原型对象，克隆拷贝出许多其他相同的对象来。 原型模式介绍一、来由 在面对软件系统设计的过程中，会面临着”复杂对象”的创建，然而对象可能会由于需求的变动而进行变动。那么我们又需要保持接口的稳定性。这时如何保证应对这种变化呢？ 创建型模式一般是用来创建一个新的对象，然后我们使用这个对象完成一些对象的操作，我们通过原型模式可以快速的创建一个对象而不需要提供专门的new()操作就可以快速完成对象的创建，这无疑是一种非常有效的方式，快速的创建一个新的对象。 二、意图 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。 三、案例图 四、原型模式代码示例 在原型模式中包含的组成部分较少： 抽象原型类： 原型类，声明一需要实现的接口及clone自身的方法 具体原型类： 实现其余接口及clone自身的方法 我们来看这么一个示例，我记得小时候上课的时候有时候就想着出去玩，就望着窗户发呆。又出不去。就想自己可以分身就好了。就可以一个留在教室学习，一个出去玩耍，学习可以一次性学习多门功课，玩耍可以一次玩多个游戏。这样就什么都没有耽误，多好呀。当然也只是想想，实现这个暂时是不可能的了。虽然说现实中没办法实现了。刚好今天讲原型模式，就借用这个示例来讲解原型模式到底是如何使用的吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465namespace Prototype_Pattern&#123; class PrototypePattern &#123; &#125; #region 抽象原型类=========== public abstract class Prototype &#123; /// &lt;summary&gt; /// 当前自己的状态 /// &lt;/summary&gt; public abstract void Status(); /// &lt;summary&gt; /// 当前自己在做的事情 /// &lt;/summary&gt; public abstract void Action(string things); /// &lt;summary&gt; /// 拷贝自身的方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public abstract Prototype Clone(); &#125; #endregion #region 具体原型类——读书学习 ============= public class LearnPrototype : Prototype &#123; public override void Status() &#123; Console.WriteLine("当前状态：好好学习"); &#125; public override void Action(string things) &#123; Console.WriteLine(things); &#125; public override Prototype Clone() &#123; return (LearnPrototype)this.MemberwiseClone(); &#125; &#125; #endregion #region 具体原型类——外出玩耍 ============= public class PlayPrototype : Prototype &#123; public override void Status() &#123; Console.WriteLine("当前状态：开心玩耍"); &#125; public override void Action(string things) &#123; Console.WriteLine( things); &#125; public override Prototype Clone() &#123; return (PlayPrototype)this.MemberwiseClone(); &#125; &#125; #endregion&#125; 123456789101112131415161718192021222324class Program&#123; static void Main(string[] args) &#123; //学习 Prototype learnPrototype = new LearnPrototype(); learnPrototype.Status(); learnPrototype.Action("一号在学习：语文"); Prototype learnPrototype1 = learnPrototype.Clone(); learnPrototype.Status(); learnPrototype.Action("二号在学习：数学"); //玩耍 Prototype playPrototype = new PlayPrototype(); playPrototype.Status(); playPrototype.Action("一号在玩耍：游戏王"); Prototype playPrototype1 = playPrototype.Clone(); learnPrototype.Status(); learnPrototype.Action("二号在玩耍：四驱赛车"); &#125;&#125; 使用场景及优缺点一、使用场景1、在处于资源优化的时候，减少new类的初始化的数量以减少资源消耗 2、一个对象多个利用修改，将一个对象提供给多个调用者使用。 二、优点1、原型模式向客户端隐藏了创建对象的复杂性，提供Clone进行浅拷贝 2、原型类允许动态的增加或减少产品类 3、产品类不需要先确定产品的等级结构，原型模式适用于任何等级结构 三、缺点1、每一个类都需要配备一个克隆方法 2、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 总结 到这里创建型的五个设计模式我们就暂时的介绍完毕了。 在学习设计模式的时候需要多思考，多斟酌。最好在重构之时考虑加入设计模式。保证设计模式发挥最大的用处。到这里创建型模式讲完了。单例模式关注的是对象实例个数的问题。控制对象仅有一个实例，全局访问调用。工厂模式和抽象工厂模式解决的是”单个对象”及”一系列对象”的问题。而建造者模式关注解决的是”对象部分”的问题。今天讲的原型模式可以算的上一个特殊的工厂模式。原型模式一般极少单独使用，一般是配合工厂模式一起使用的。接下来的时间中给大家带来的是结构型的设计模式解析 平凡人生要用平凡的心去对待，你的人生将会更精彩。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——建造者模式]]></title>
    <url>%2F2019%2F08%2F20%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 在本篇文章中，我们重点介绍建造者模式（Builder Pattern），建造者模式顾名思义，与建造创建相关。事实也是如此建造者模式也是创建型中的一种。在我们平常生活中会有比较复杂的东西的组成过程。比如电脑组成、手机组成、电视组成、等等。就拿电脑组成来说。可以由主板、Cpu、显卡等等组成。但是组成的算法步骤是一样的。只是不同的东西组装起来结果不一样而已。 建造者模式介绍一、来由 在软件编程的过程我们是否也会遇到类似电脑组装这类的问题呢？当然是会的。组装一个电脑我们就一次，那岂不是要累死了。类似于这种组装算法固定但是各个部分又不稳定经常变化的情况。并且对象组装较为复杂。为了面对解决这种情况。所以有建造者模式。建造者模式到底是如何解决问题的呢？我们一起看看吧。 二、意图 *将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 * 三、 案例图 四、建造者模式代码示例 在建造者模式中一般包含如下成分： 抽象建造者： 抽象建造者为创建复杂产品对象的各个部分指定抽象创建接口 具体建造者： 继承抽象建造者，实现抽象创建接口。指定创建的类型。创建各个具体的部分。 产品角色： 复杂产品对象，将各个部分组成产品的接口 指挥者： 调用各个部分，按固定的算法创建。不涉及到具体产品类的信息。仅负责各个部分完整的创建 就组装电脑来说，我们一起看看建造者模式如何实现这一复杂对象的创建设计。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119namespace Builder_Pattern&#123; public class BuilderPattern &#123; &#125; #region 产品角色——电脑的组成 ============ public class Computer &#123; private string Type = null; public Computer(string type) &#123; this.Type = type; &#125; private List&lt;string&gt; computer = new List&lt;string&gt;(); public void Add(string part) &#123; computer.Add(part); &#125; public void Show() &#123; Console.WriteLine("电脑组装正式开始："); foreach (var item in computer) &#123; Console.WriteLine("配件——" + item + "已装好"); &#125; Console.WriteLine(Type + "电脑组装完成了"); &#125; &#125; #endregion #region 抽象创建者——电脑中的各个部分的抽象接口============ public abstract class Builder &#123; /// &lt;summary&gt; /// Cpu抽象创建 /// &lt;/summary&gt; public abstract void CreateCpu(); /// &lt;summary&gt; /// 主板抽象创建 /// &lt;/summary&gt; public abstract void CreateMotherboard(); /// &lt;summary&gt; /// 显卡抽象创建 /// &lt;/summary&gt; public abstract void CreateGraphicsCard(); /// &lt;summary&gt; /// 获取组装好的电脑 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public abstract Computer GetComputer(); &#125; #endregion #region 具体产品创建者——联想电脑各个部分创建接口========= public class LenovoBuilder : Builder &#123; Computer lenovo = new Computer("联想"); public override void CreateCpu() &#123; lenovo.Add("联想CPU"); &#125; public override void CreateMotherboard() &#123; lenovo.Add("联想主板"); &#125; public override void CreateGraphicsCard() &#123; lenovo.Add("联想显卡"); &#125; public override Computer GetComputer() &#123; return lenovo; &#125; &#125; #endregion #region 具体产品创建者——惠普电脑各个部分创建接口========= public class HPBuilder : Builder &#123; Computer hp = new Computer("惠普"); public override void CreateCpu() &#123; hp.Add("惠普CPU"); &#125; public override void CreateMotherboard() &#123; hp.Add("惠普主板"); &#125; public override void CreateGraphicsCard() &#123; hp.Add("惠普显卡"); &#125; public override Computer GetComputer() &#123; return hp; &#125; &#125; #endregion #region 指挥者——固定的组装算法=================== /// &lt;summary&gt; /// 指挥者，其中的Construct是组装的较为固定算法 /// &lt;/summary&gt; public class Commander &#123; public void Construct(Builder builder) &#123; builder.CreateMotherboard(); builder.CreateCpu(); builder.CreateGraphicsCard(); &#125; &#125; #endregion&#125; 1234567891011121314151617181920212223242526class Program &#123; static void Main(string[] args) &#123; //实例化指挥者 Commander commander = new Commander(); //指定具体产品 Builder builder = new LenovoBuilder(); //组装构建产品 commander.Construct(builder); //构建完成展示产品 Computer computer = builder.GetComputer(); computer.Show(); //指定具体产品 builder = new HPBuilder(); //组装构建产品 commander.Construct(builder); //构建完成展示产品 computer = builder.GetComputer(); computer.Show(); Console.ReadLine(); &#125; &#125; 使用场景及优缺点 在建造者模式中，将一个复杂对象的组成与组件的创建分离开。专门的具体建造者来负责组件的创建、然后由指挥者来规定固定组成、最后完成组装。这一个过程下来。把复杂对象的创建拆分成多个步骤。而其组件也是经常变化的。这样一来组件的变化仅需修改增加组件的创建即可。不影响其他的扩展。这里由于建造者模式最终创建的产品差异较大，所以并没有抽象一个产品类。前面一章中讲的抽象工厂模式中解决的是”一系列产品对象”的问题。而本章中建造者模式解决的是”产品部分”的问题。抽象工厂模式关心的是整体，注重产品的创建，不关心细节的组成。而建造者模式关心的是细节，注重产品的创建的同时也关系产品组成细节的问题。 一、使用场景1、当创建一个复杂对象且组成的算法独立与其组成部分的时候。 2、 多个部件或配件可以装配到一个对象但产生的对象不同时。 3、创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。 二、优点1、使用者客户端不必关心产品的组成及细节部分。 2、具体建造者与其他类相对独立，易于扩展。不易对其他模块造成影响 3、便于控制细节 三、缺点1、产品必须有共同点，使用范围限制 2、如果内部变化较为复杂，会有较多的具体建造者类 总结 到这里介绍完了建造者模式，建造者模式与工厂模式相比，建造者模式更像生产的一个复合产品，并且复杂的部件不同所构成的不同，而工厂模式仅是产品。同时建造者模式关注复杂产品细节的创建。但是工厂模式仅关心产品的创建，不在乎其细节的创建。 做自己生命的主角，而不是别人生命中的看客。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——工厂模式]]></title>
    <url>%2F2019%2F08%2F18%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 上一篇我们介绍了单例模式，今天给大家讲一个比较简单的模式——工厂模式（Factory Method），工厂模式又是什么呢？顾名思义，工厂——生产制造东西的地方。那么应用在程序当中该如何使用、并且又起到什么效果呢？以至于为什么用工厂模式呢？ 之前我们说的OCP原则（开放封闭原则），对扩展开放，对修改封闭这一原则。在工厂模式中有极好的体现，对对象及类进行极好的封装。使其减少代码之间的耦合性。更具有扩展性。 工厂模式介绍一、来由 在我们编程过程当中，总会面临一些类的创建以及对象的创建，但是由于需求而不断变动（增加或者修改），导致对象的变化。这时怎么处理这个问题呢？ 工厂模式提供的一种封装机制，隔离出了那些易变动的对象。这个时候需求的变动不再影响之前的对象的变动了。 二、意图 定义一个用于创建对象的接口，让子类决定实例化哪一个类。FactoryMethod使一个类的实例化延迟到其子类。 三、案例图 工厂模式中由以下部分组成： （1）、抽象工厂（Creator）: 复制定义工厂所需的基本规则，其他任何具体工厂都得继承此抽象工厂 （2）、具体工厂（Concrete _ Creator）： 继承抽象工厂，实现其定义的方法，以此来创建具体的产品 （3）、抽象产品（Product）： 复制定义产品的基本方法及规则，所有具体产品都得基础此抽象产品类 （4）、具体产品（Concrete_Product）： 继承抽象产品，实现其定义抽象方法，由具体工厂创建，两者是一一对应的关系。 四、工厂模式代码实现这里我们通过一个事例来介绍工厂模式的规则及用法。在工厂模式中，定义抽象工厂，然后其具体工厂继承实现其抽象方法调用继承了抽象产品类的具体产品来创建产品。 下面我们就手机产品的制造来看看下面的事例吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990namespace ConsoleApp4&#123; public class Factory_Method_Pattern &#123; &#125; #region 产品 ========================= /// &lt;summary&gt; /// 抽象手机产品类 /// &lt;/summary&gt; public abstract class Phone &#123; public abstract string Create(); &#125; /// &lt;summary&gt; /// 具体华为手机产品类 /// &lt;/summary&gt; public class Huawei : Phone &#123; /// &lt;summary&gt; /// 实现抽象方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override string Create() &#123; return "华为一号现世"; &#125; &#125; /// &lt;summary&gt; /// 具体小米手机产品类 /// &lt;/summary&gt; public class Xiaomi : Phone &#123; /// &lt;summary&gt; /// 实现抽象方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override string Create() &#123; return "小米一号现世"; &#125; &#125; #endregion #region 工厂========================= /// &lt;summary&gt; /// 抽象工厂类 /// &lt;/summary&gt; public abstract class Factory &#123; /// &lt;summary&gt; /// 抽象工厂类的方法，创建调用产品 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public abstract Phone CreatePhone(); &#125; /// &lt;summary&gt; /// 具体华为工厂类，继承抽象工厂类 /// &lt;/summary&gt; public class HuaweiFactory : Factory &#123; /// &lt;summary&gt; /// 实现继承方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override Phone CreatePhone() &#123; return new Huawei(); &#125; &#125; /// &lt;summary&gt; /// 具体小米工厂类，继承抽象工厂类 /// &lt;/summary&gt; public class XiaomiFactory : Factory &#123; /// &lt;summary&gt; /// 实现继承方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override Phone CreatePhone() &#123; return new Xiaomi(); &#125; &#125; #endregion &#125; 123456789101112131415161718192021class Program &#123; static void Main(string[] args) &#123; //初始化工厂 Factory huaweiFactory = new HuaweiFactory(); //生产具体的华为手机 var result=huaweiFactory.CreatePhone(); //华为手机现世 var answer = result.Create(); Console.WriteLine(answer); Factory xiaomiFactory = new XiaomiFactory(); result = xiaomiFactory.CreatePhone(); answer = result.Create(); Console.WriteLine(answer); Console.ReadLine(); &#125; &#125; 在上述事例中，同样是先把手机抽象出一个抽象类，手机当然也不是凭空出现的。所以需要再抽象一个工厂类。工厂类派生子类不同的手机厂商类。同样手机也派生了不一样的品牌。手机厂商类再对应手机品牌去生产相应的手机。这时我们需要增加一个手机手机品牌，我们不需要去修改工厂类及产品类。我们另外新增即可。完全不影响其原来的运行。比如我们需要新增魅族手机。 1234567891011121314151617181920212223#region 新增魅族手机 ================/// &lt;summary&gt;/// 新增魅族工厂类/// &lt;/summary&gt;public class MeizuFactory : Factory&#123; public override Phone CreatePhone() &#123; return new Meizu(); &#125;&#125;/// &lt;summary&gt;/// 新增具体魅族手机产品类/// &lt;/summary&gt;public class Meizu : Phone&#123; public override string Create() &#123; return "魅族一号现世"; &#125;&#125;#endregion 在客户端调用时增加以下调用就可以了 1234Factory meizuFactory = new MeizuFactory();result = meizuFactory.CreatePhone();answer = result.Create();Console.WriteLine(answer); 使用场景及优缺点在此模式中，将所有要创建的具体对象的工作都延迟放在了子类中去实现，实现了一种扩展的策略。与OCP原则相对应。 工厂模式主要针对解决的是”单个对象”的问题。隔离类的对象的使用者与具体类型之间的耦合关系。去实现了一定程度的解耦。 （一）使用场景1、当用户不需要知道产品的类名的时候或者不关心如何创建的时候。我们只需要知道创建它的具体工厂的时候。 2、将创建对象的任务委托给多个工厂中的一个，客户端使用的时候无需关心是哪一个创建产品。当需要动态指定。 （二）优点1、在编程方法中，客户端调用不需要知道产品的具体工厂，也不需要关心如何创建的。 2、在增加需求的时候，增加产品的时候仅需要新增一个工厂类及产品类即可，不需要对原来的代码进行修改。可轻易的扩展。 （三）缺点在增加产品的时候，额外的增加了工厂类及产品类。增加一个产品增加两个类。在一定程度上增加了系统的复杂度。同时也增强了类之间的依赖性。这也就是其中不好的问题 总结 每一个设计模式都有对应的使用场合，切勿滥用。在我们学习设计模式的同时，我们也需要以其原主要则作为基准学习。万万不能违背原则。在设计模式——工厂模式中，将创建对象的任务委托给其工厂子类、延迟执行。解决了系统难于扩展的问题，同时也减少了具体类与对象之间的耦合性。也实现了开放扩展封闭修改的原则。 ** 这个社会是存在不公平的，不要抱怨，因为没有用！人总是在反省中进步的！**]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——抽象工厂模式]]></title>
    <url>%2F2019%2F08%2F18%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 前面介绍了单例模式及工厂模式相关知识及示例，今天主要介绍的是抽象工厂模式，上一篇我们讲了工厂模式。将创建对象的任务委托给子类，延迟创建。解决工厂中责任的划分。实现具体工厂与产品之间的一一对应。解决的是”单个对象”的问题。 华为工厂除了生产华为手机之外。肯定也会有原件配套的充电线和耳机。这时工厂对应的是一套产品该如何解决了呢？显然不再适合使用工厂模式了。今天将的抽象工厂模式将会比较好的解决此问题。抽象工厂模式解决的是”一系列对象”的问题、解决多套变化的问题。 抽象工厂模式介绍一、来由 在我们编程的过程中难免会出现”一系列相互依赖对象”的创建问题，往往会有由于需要的改变增加或减少对象的创建。为了面对解决这种”一系列的相互依赖的对象”的创建工作的紧密耦合性，出现了其解决方案——抽象工厂模式。 二、意图** 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。** 三、案例图 四、与工厂模式区别工厂模式： 1、解决”单个对象”的问题 2、工厂类与产品类一一对应关系 抽象工厂模式： 1、解决”一系列对象”的问题 2、工厂类与产品类是一对多的关系（一对应一系列想依赖的产品） 工厂模式讲的是一个华为手机工厂生产一个华为手机，要生产其他的产品需另加工厂。抽象工厂模式讲的是一个华为手机工厂可以生产一系列的华为手机产品（手机、耳机、充电器）。 五、抽象工厂模式代码示例 根据上一篇文章的事例我们进行扩展，进一步讲述抽象工厂模式的使用。抽象工厂模式我们工厂类对应的多个产品的生产。华为手机工厂生产华为手机、华为耳机、华为充电器等。下面我们看看抽象工厂模式的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128namespace Abstract_Factory&#123; #region 抽象产品类 =============== /// &lt;summary&gt; /// 手机抽象类 /// &lt;/summary&gt; public abstract class Phone &#123; public abstract string CreatePhone(); &#125; /// &lt;summary&gt; /// 耳机抽象类 /// &lt;/summary&gt; public abstract class Headset &#123; public abstract string CreateHeadset(); &#125; /// &lt;summary&gt; /// 充电器抽象类 /// &lt;/summary&gt; public abstract class Charger &#123; public abstract string CreateCharger(); &#125; #endregion #region 华为具体产品类 =========== public class HuaweiPhone : Phone &#123; public override string CreatePhone() &#123; return "华为手机一号现世"; &#125; &#125; public class HuaweiHeadset : Headset &#123; public override string CreateHeadset() &#123; return "华为手机一号原配耳机"; &#125; &#125; public class HuaweiCharger : Charger &#123; public override string CreateCharger() &#123; return "华为手机一号原配充电器"; &#125; &#125; #endregion #region 小米具体产品类 =========== public class XiaomiPhone : Phone &#123; public override string CreatePhone() &#123; return "小米手机一号现世"; &#125; &#125; public class XiaomiHeadset : Headset &#123; public override string CreateHeadset() &#123; return "小米手机一号原配耳机"; &#125; &#125; public class XiaomiCharger : Charger &#123; public override string CreateCharger() &#123; return "小米手机一号原配充电器"; &#125; &#125; #endregion #region 抽象工厂类 =============== /// &lt;summary&gt; /// 抽象工厂类 /// &lt;/summary&gt; public abstract class AbstractFactory &#123; public abstract Phone GetPhone(); public abstract Headset GetHeadset(); public abstract Charger GetCharger(); &#125; #endregion #region 华为具体工厂=============== public class HuaweiFactory : AbstractFactory &#123; public override Phone GetPhone() &#123; return new HuaweiPhone(); &#125; public override Headset GetHeadset() &#123; return new HuaweiHeadset(); &#125; public override Charger GetCharger() &#123; return new HuaweiCharger(); &#125; &#125; #endregion #region 小米具体工厂=============== public class XiaomiFactory : AbstractFactory &#123; public override Phone GetPhone() &#123; return new XiaomiPhone(); &#125; public override Headset GetHeadset() &#123; return new XiaomiHeadset(); &#125; public override Charger GetCharger() &#123; return new XiaomiCharger(); &#125; &#125; #endregion &#125; 1234567891011121314151617181920212223class Program&#123; static void Main(string[] args) &#123; ///华为工厂生产华为产品 HuaweiFactory huaweiFactory = new HuaweiFactory(); var phone = huaweiFactory.GetPhone().CreatePhone(); var headset = huaweiFactory.GetHeadset().CreateHeadset(); var charger = huaweiFactory.GetCharger().CreateCharger(); Console.WriteLine("华为产品生产：" + phone + "——" + headset + "——" + charger); ///小米工厂生产小米产品 XiaomiFactory xiaomiFactory = new XiaomiFactory(); phone = xiaomiFactory.GetPhone().CreatePhone(); headset = xiaomiFactory.GetHeadset().CreateHeadset(); charger = xiaomiFactory.GetCharger().CreateCharger(); Console.WriteLine("小米产品生产：" + phone + "——" + headset + "——" + charger); Console.ReadLine(); &#125;&#125; 这是系列产品新增了一个魅族手机，我们看看如何修改增加魅族手机的生产： 123456789101112131415161718192021222324252627282930313233343536373839#region 新增魅族手机需求===========public class MeizuPhone : Phone&#123; public override string CreatePhone() &#123; return "魅族手机一号现世"; &#125;&#125;public class MeizuHeadset : Headset&#123; public override string CreateHeadset() &#123; return "魅族手机一号原配耳机"; &#125;&#125;public class MeizuCharger : Charger&#123; public override string CreateCharger() &#123; return "魅族手机一号原配充电器"; &#125;&#125;public class MeizuFactory : AbstractFactory&#123; public override Phone GetPhone() &#123; return new MeizuPhone(); &#125; public override Headset GetHeadset() &#123; return new MeizuHeadset(); &#125; public override Charger GetCharger() &#123; return new MeizuCharger(); &#125;&#125;#endregion 123456///魅族工厂生产小米产品MeizuFactory meizuFactory = new MeizuFactory();phone = meizuFactory.GetPhone().CreatePhone();headset = meizuFactory.GetHeadset().CreateHeadset();charger = meizuFactory.GetCharger().CreateCharger();Console.WriteLine("魅族产品生产：" + phone + "——" + headset + "——" + charger); 这里我们可以发现新增系列产品（魅族系列）比较方便，而且吻合”开放扩展——封闭修改”的原则。扩展起来还是比较方便的，但是也是存在着一定的问题的。当我们新增新的产品的时候，这个时候就需要去系列产品生产抽象工厂去增加产品的生产方法。同时也需要在各个子类中增加其方法。这也就违背了开闭原则。这也就是抽象方法的一个缺点所在。 使用场景及优缺点一、使用场景1、在系统中如果存在一系列相互依赖的产品。这系列变化比较多。且存在着多套系列的产品的时候。我们就可以考虑使用抽象工厂模式了。 2、强调一系列相关的产品对象设计的时候。 3、一个系统由多个相互依赖项进行配置且需要多个系统时。 二、优点1、当一个产品系列，对个对象使用时，保证使用的是同系列中的对象 2、降低了具体产品和具体类及客户端之间的耦合性。通过使用抽象类相关联而不是具体类。 3、对系列产品的修改增加极其方便 三、缺点1、在系列产品中新增产品困难并且违反了开闭原则 总结 到这里抽象工厂模式我们就暂时的介绍完了。今天呢又介绍了创建型中的一种设计模式，设计模式的学习之路还很漫长。一切都才刚刚开始。学习更重要的是灵活运用，举一反三。选择适当的场景去使用适当的模式。多思考其优点缺点和使用场景。抽象工厂在针对于系列产品的修改增加时符合开闭原则。但是在系列产品中的产品修改增加的时候又违反了开闭原则。我们在使用每一种设计模式时都得慎重选择。 只要认为是对的就去做，坚持去做，不要在乎别人的看法，哪怕是错，至少你有去做过证明曾经你努力过。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂设计模式解析——单例模式]]></title>
    <url>%2F2019%2F08%2F17%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、前言 在上一节中我们对设计模式进行了一定的介绍及分类。设计模式分为创建型、结构型、行为型。创建型模式——主要负责对象的创建。结构型职责——主要负责处理类与对象的组合。行为型模式——主要负责类与对象交互中的职责的分配问题。今天我们也是讲述介绍创建型模式中的第一个模式——单例模式。 二、单例模式介绍 （一）来由 单例模式（Singleton Pattern）是最简单的一个设计模式 ，这种设计模式属于创建型模式。在程序中总会有一些特殊的类。它们必须保证在系统中只存在一个实例，这个单一的类自己创建自己的对象，同时确保只有单个对象被创建，并且提供唯一的访问形式。可以直接进行访问，不用再新建实例。 那么如何避开常规的设计，来实现一个类一个实例、并且保证唯一调用呢？这时候就是单例模式施展身手的时候了。 （二）意图 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 （三）单例模式实现方法 单例模式到底又是如何实现的呢？既然是单一实例，那么队友多线程又该如何处理呢？下面我们一一来看看单例模式的实现。单例模式我们又涉及到其实现的多种形式——非线程安全、线程安全、双重验证线程安全、不用锁线程安全、完全延迟加载、使用.NET4的Lazy类型。 1. 非线程安全1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// 非线程安全/// &lt;/summary&gt;public sealed class Singleton1&#123; /// &lt;summary&gt; /// 定义静态变量保存实例 /// &lt;/summary&gt; public static Singleton1 Instance = null; /// &lt;summary&gt; /// 定义私有构造函数保护，使其他地方不得实例 /// &lt;/summary&gt; private Singleton1() &#123; &#125; public string GetString() &#123; return "非线程安全的单例模式"; &#125; /// &lt;summary&gt; /// 定义公共方法，实现全局访问 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Singleton1 GetInstance() &#123; //判断实例状态 if (Instance==null) &#123; Instance = new Singleton1(); &#125; return Instance; &#125;&#125; 在上述事例中完美的实现了单线程的单例模式的情况。这里我们也需要注意一些的情况： ① 单例类包含一个 private 的私有构造函数 ② 类申明 sealed 密封不可继承（不强制） ③ 类中有一个静态变量保存实例 ④ 类中提供有一个静态方法或者属性实现实例的创建引用全局调用访问 ⑤ 在多线程中单例模式需要另行处理，不然有可能得到类的多个实例 2. 线程安全123456789101112131415161718192021222324252627282930313233343536373839/// &lt;summary&gt;/// 线程安全单例模式/// &lt;/summary&gt;public sealed class Singleton2&#123; /// &lt;summary&gt; /// 定义静态变量保存实例 /// &lt;/summary&gt; public static Singleton2 Instance = null; private static readonly object locks=new object(); /// &lt;summary&gt; /// 定义私有构造函数保护，使其他地方不得实例 /// &lt;/summary&gt; private Singleton2() &#123; &#125; public string GetString() &#123; return "线程安全的单例模式"; &#125; /// &lt;summary&gt; /// 定义公共方法，实现全局访问 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Singleton2 GetInstance() &#123; //对线程进行加锁限制，挂起后来的线程。保证实例安全 lock (locks) &#123; if (Instance == null) &#123; Instance = new Singleton2(); &#125; &#125; return Instance; &#125;&#125; 3. 不用锁线程安全12345678910111213141516171819202122232425262728293031/// &lt;summary&gt; /// 不用锁线程安全单例模式 /// &lt;/summary&gt; public sealed class Singleton3 &#123; /// &lt;summary&gt; /// 定义静态变量保存实例 /// &lt;/summary&gt; private static readonly Singleton3 Instance = new Singleton3 (); static Singleton3() &#123; &#125; /// &lt;summary&gt; /// 定义私有构造函数保护，使其他地方不得实例 /// &lt;/summary&gt; private Singleton3() &#123; &#125; public string GetString() &#123; return "不用锁线程安全单例模式"; &#125; /// &lt;summary&gt; /// 定义公共方法，实现全局访问 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Singleton3 GetInstance() &#123; return Instance; &#125; &#125; 这个实现方法没有使用到锁，但是也实现了线程安全。在第一次调用的时候会创建一个instance。这个实现也有一定的安全隐患。 1. instance被创建的时机不明，任何对Singleton的调用都会提前创建instance 2. static构造函数的循环调用。如有A，B两个类，A的静态构造函数中调用了B，而B的静态构造函数中又调用了A，这两个就会形成一个循环调用，严重的会导致程序崩溃。 3. 我们需要手动添加Singleton的静态构造函数来确保Singleton类型不会被自动加上beforefieldinit这个Attribute，以此来确保instance会在第一次调用Singleton时才被创建。 4. readonly的属性无法在运行时改变，如果我们需要在程序运行时dispose这个instance再重新创建一个新的instance，这种实现方法就无法满足。 4. 完全延迟加载1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// 实现完全延迟加载单例模式/// &lt;/summary&gt;public sealed class Singleton4&#123; /// &lt;summary&gt; /// 定义私有构造函数保护，使其他地方不得实例 /// &lt;/summary&gt; private Singleton4() &#123; &#125; /// &lt;summary&gt; /// 提供访问位置 /// &lt;/summary&gt; public static Singleton4 Instance &#123; get &#123; return GetInstance.instance; &#125; &#125; /// &lt;summary&gt; /// 定义私有类确保第一次加载是初始化及调用 /// &lt;/summary&gt; private class GetInstance &#123; static GetInstance()&#123;&#125; internal static readonly Singleton4 instance = new Singleton4(); &#125; public string GetString() &#123; return "实现完全延迟加载单例模式"; &#125; &#125; 它确保了instance只会在Instance的get方法里面调用，且只会在第一次调用前初始化。是上一个版本的延迟加载的版本 5. 使用.NET4的Lazy类型12345678910111213141516171819202122232425262728293031/// &lt;summary&gt;/// 使用Lazy&lt;T&gt;实现完全延迟加载单例模式/// &lt;/summary&gt;public sealed class Singleton5&#123; /// &lt;summary&gt; /// 延迟加载初始化 /// &lt;/summary&gt; private static readonly Lazy&lt;Singleton5&gt; lazy=new Lazy&lt;Singleton5&gt;(()=&gt;new Singleton5()); /// &lt;summary&gt; /// 定义私有构造函数保护，使其他地方不得实例 /// &lt;/summary&gt; private Singleton5() &#123; &#125; /// &lt;summary&gt; /// 提供全局访问点 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Singleton5 Instance() &#123; return lazy.Value; &#125; public string GetString() &#123; return "实现完全延迟加载单例模式"; &#125;&#125; 在.NET4.0中，可以使用Lazy 来实现对象的延迟初始化，从而优化系统的性能。延迟初始化就是将对象的初始化延迟到第一次使用该对象时。延迟初始化是我们在写程序时经常会遇到的情形，例如创建某一对象时需要花费很大的开销，而这一对象在系统的运行过程中不一定会用到，这时就可以使用延迟初始化，在第一次使用该对象时再对其进行初始化，如果没有用到则不需要进行初始化,这样的话，使用延迟初始化就提高程序的效率，从而使程序占用更少的内存。 三、使用场合及优缺点 一、使用场合1、当类只需要且只能有一个实例并且需要全局访问的时候。 2、当类是使用子类化扩展，并且无需更改代码就可以使用扩展实例的情况下。 二、优点1、控制实例数量：保证实例数量的唯一且是全局访问。 2、灵活性：类控制了实例化的全过程，这样可以更加灵活的修改实例化过程 3、资源节省：避免对资源的多重占用 三、缺点1、没有接口、也不能继承。这个与单一责任原则相冲突，一个类只应该负责其逻辑，而不应该去负责如何实例。 四、总结 在设计模式的学习过程中，单例模式较为简单，实现操作并不是特别难，但是在我们实例运用中也当注意下，比较如果使用出现问题。找到问题还是稍微困难的。这篇文章也介绍了几种单例模式的使用方法，在我们使用时择优选取最佳方案。下一节我们将为全面讲述二级野怪、并学习攻克它。 ** 生命不息、战斗不止!**]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>.Net设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NET之反射_元数据详解]]></title>
    <url>%2F2019%2F08%2F16%2FNET%E4%B9%8B%E5%8F%8D%E5%B0%84_%E5%85%83%E6%95%B0%E6%8D%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言 在本节中主要讲述自定义特性、反射。自定义特性允许把自定义元数据与程序元素关联起来。这些元数据是在编译过程中创建的，并嵌入程序集中。反射是一个普通的术语，它描述了在运行过程中检查和处理程序元素的功能。例如，反射运行完成以下任务： 枚举类型的成员 实例化新对象 执行对象的成员 查找类型的信息 查找程序集的信息 检查应用于某个类型的自定义特性 创建和编译新程序集 这个列表列出了许多功能，本章中主要介绍部分常用的功能。 自定义特性一、编写自定义特性 1. 理解自定义特性12[LastModified("Test","Test")] public class TestNumber &#123; &#125; 这个例子首先会发现LastModified这个特性，首先把字符串Attribute追加到这个名称后面，形成一个组合LastModifiedAttribute，然后在其搜多路径的所有名称空间去搜索这个名称的类。注意如果本来就以Attribute结尾了，那么也就不会组合在一起了。编译器会找到含有改名称的类，且这个类直接或间接派生自System.Attribute。编译器很认为这个类包含控制特性用法的信息。特别是属性类需要指定： 特性可以应用到那些类型的程序元素上（类、结构、属性和方法等） 是否可以多次应用到同一个应用程序元素上 在应用到类和接口上时，是否由派生类和接口继承 这个特性有那些必选和可选参数 如果哦编译器找不到对应的特性类，或者找到了但是使用方式或者信息不对，编译器就会产生一个编译错误。 下面我们看看自定义特性其中的各个元素如何定义吧 2. 指定AttributeUsage特性 第一个要注意的就是AttributeUsage特性，它是特性类的标记。AttributeUsage主要用于标识自定义特性可以应用到那些类型的程序元素上。 这些信息都是由第一个参数提供的，该参数输入必选参数，其类型是枚举类型AttributeTargets。其成员如下： 在上面列表中，有两个值不对应于任何程序元素：Assembly和Module。特性可以应用到整个程序集或模块中，而不是应用到代码中的一个元素上，在这种情况下，这个特性可以放在源代码的任何地方，但需要关键字Assembly和Module作为前缀 12[assembly:SupportsWhatsNew] [module: SupportsWhatsNew] 下面我们再介绍几个参数AllowMultiple表示一个特性是否可以多次应用到同一项，Inherited表示应用到类或接口上的特性是否可以自动应用到所以的派生的类或接口上。如果特性应用到方法或者属性上，就表示是否可以自动应用到该方法或属性等的重新版本上。 二、自定义特性示例 经过上面的介绍，下面我们开始定义自定义特性示例。这里我们将创建两个类库，第一个WhatsNewAttributes库程序集，其中定义了两个特性，LastModifiedAttribute和SupportsWhatsNewAttribute。 LastModifiedAttribute特性可以用于标记最后一次修改数据项的时间，它有两个必选参数：修改的日期和包含描述修改的信息。还有一个可选参数issues，它可以用来描述该数据项的任何重要问题。 SupportsWhatsNewAttribute是一个较小的类，不带有任何参数的特性。这个特性是一个程序集的特性，用于把程序集标记为通过**SupportsWhatsNewAttribute**维护的文档。 12345678910111213141516171819202122232425262728 /// &lt;summary&gt; /// 用于标记最后一次修改数据项的时间和信息。 /// &lt;/summary&gt; [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Constructor, AllowMultiple = true, Inherited = false)] public class LastModifiedAttribute : Attribute &#123; private readonly DateTime _dateModified; private readonly string _changes; public LastModifiedAttribute(string dateModified, string changes) &#123; _dateModified = DateTime.Parse(dateModified); _changes = changes; &#125; public DateTime DateModified =&gt; _dateModified; public string Changes =&gt; _changes; public string Issues &#123; get; set; &#125;&#125; /// &lt;summary&gt; /// 用于把程序集标记为通过LastModifiedAttribute维护的文档 /// &lt;/summary&gt; [AttributeUsage(AttributeTargets.Assembly)] public class SupportsWhatsNewAttribute : Attribute &#123; &#125; 接下来我们介绍第二个库VectorClass。VectorClass库引用了WhatsNewAttributes库，添加声明后我们使用全局程序集特性标记程序集。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980[assembly:SupportsWhatsNew]namespace VectorClass&#123; [LastModified("2017-7-19", "更新C#7，.NET Core 2")] [LastModified("2015-6-6", "更新C#6,.NET Core")] [LastModified("2010-2-14", "修改第一步")] public class Vector : IFormattable, IEnumerable&lt;double&gt; &#123; public Vector(double x, double y, double z) &#123; X = x; Y = y; Z = z; &#125; public Vector(Vector vector) : this(vector.X, vector.Y, vector.Z) &#123; &#125; public double X &#123; get; &#125; public double Y &#123; get; &#125; public double Z &#123; get; &#125; public IEnumerator&lt;double&gt; GetEnumerator() &#123; throw new NotImplementedException(); &#125; [LastModified("2017-7-19", "将ijk格式从StringBuilder更改为格式字符串")] public string ToString(string format, IFormatProvider formatProvider) &#123; if (format == null) &#123; return ToString(); &#125; switch (format.ToUpper()) &#123; case "N": return "|| " + Norm().ToString() + " ||"; case "VE": return $"( &#123;X:E&#125;, &#123;Y:E&#125;, &#123;Z:E&#125; )"; case "IJK": return $"&#123;X&#125; i + &#123;Y&#125; j + &#123;Z&#125; k"; default: return ToString(); &#125; &#125; public double Norm() =&gt; X * X + Y * Y + Z * Z; IEnumerator IEnumerable.GetEnumerator() &#123; throw new NotImplementedException(); &#125; [LastModified("2015-6-6", "修改")] [LastModified("2010-2-14", " 类创建")] public class VectorEnumerator : IEnumerator&lt;double&gt; &#123; public double Current =&gt; throw new NotImplementedException(); object IEnumerator.Current =&gt; throw new NotImplementedException(); public void Dispose() &#123; throw new NotImplementedException(); &#125; public bool MoveNext() &#123; throw new NotImplementedException(); &#125; public void Reset() &#123; throw new NotImplementedException(); &#125; &#125; &#125;&#125; 这里我们还需要设置下csproj项目文件添加 1&lt;version&gt;2.1.0&lt;/version&gt; 到这里我们介绍了自定义特性相关。接下来我们介绍反射，然后根据反射示例加上自定义特性示例去完成一个小的demo。 反射 反射是.NET中的重要机制，通过反射，可以在运行时获得程序或程序集中每一个类型（包括类、结构、委托、接口和枚举等）的成员和成员的信息。有了反射，即可对每一个类型了如指掌。另外我还可以直接创建对象，即使这个对象的类型在编译时还不知道。 一、System.Type类1Type t=typeof(double); 这里使用Type类只为了存储类型的引用，以前把Type看做一个类，实际上时一个抽象的基类。实例化一个Type对象，实际上就实例化了Type的一个派生类。尽管一般情况下派生类只提供各种Type方法和属性的不同重载，但是这些方法和属性返回对应数据类型的正确数据。通常，获取指定任何给定类型的Type引用有3中常用的方式： 使用typeof运算符，就想上面的例子一样 使用GetType()方法，所有的类都会从System.Object继承这个方法。 123double d = 10;Type t = d.GetType(); 调用Type类的静态方法GetType() 1Type t = Type.GetType("System.Double"); Type是实现许多反射功能的入口，它实现了许多方法和属性，这里我们将介绍如何使用这个类。 其中还有许多布尔属性表示这种类型是否是一个类。还是一个枚举等等。这些特性包括IsAbstract、IsArray、IsClass、IsEnum、IsInterface、IsPointer、IsPrimitive（一种预定义的基元数据类型）、IsPublic、IsSealed以及IsValueType。例如判断类型是否是数组： 1234 Type t = typeof(double); if (t.IsArray)//返回布尔值&#123; &#125; 二、方法 System.Type的大多数方法都用于获取对应数据类型的成员信息:构造函数、属性、方法和事件等。下面我们看看Type的成员方法，这里遵循一个模式。注意名称为复数形式的方法返回一个数组。 GetMember()和GetMembers()方法返回的数据类型的任何成员或所有成员的详细信息，不管这些成员是构造函数、属性、方法等 三、Assembly类 Assembly类在System.Reflection名称空间定义，它允许访问给定程序集的元数据，它也可以包含可以加载和执行程序集的方法。 我们可以先看第一个方法Assembly.Load()或者Assembly.LoadFrom()。这两个方法的区别在于Load方法的参数时程序集的名称，运行库会在各个位置搜索该程序集，试图找到该程序集，这些位置包括本地目录和群居程序集缓存。 1、获取在程序集好难过定义的类型的详细信息 这里我跟根据Assembly类的一个功能来获取程序集中定义的所有类型的详细信息，只要调用Assembly.GetTypes()方法，他就可以返回一个包含所有类型的详细信息的System.Type引用数组。 123Assembly theAssembly = Assembly.Load(new AssemblyName("VectorClass")); Type[] types = theAssembly.GetTypes(); 2、获取自定义特性的详细信息 用于查找在程序集或类型中定义了什么自定义特性的方法取决于与该特性相关的对象类型。如果要确定程序集从整体上关联了什么自定义特性，就需要调用Assembly类的一个静态方法 1Attribute[] attributes = Attribute.GetCustomAttributes(theAssembly); 完成示例 到这里我们就简单的介绍了自定义特性以及反射，我们就接着完成我们的示例，刚刚以及定义了两个程序集以及自定义特性。现在我们要做的就是配合反射来获取相关程序集的信息。主要实现效果是：说明公司如何定期升级软件，自动记录升级的信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class Program &#123; /// &lt;summary&gt; /// 输出的消息 /// &lt;/summary&gt; private static readonly StringBuilder outputText = new StringBuilder(1000); /// &lt;summary&gt; /// 存储的时间 /// &lt;/summary&gt; private static DateTime backDateTo = new DateTime(2017,2,1); static void Main(string[] args) &#123; //获取访问的程序集 Assembly theAssembly = Assembly.Load(new AssemblyName("VectorClass")); //获取自定义特性的详细信息 Attribute supportsAttribute = theAssembly.GetCustomAttribute(typeof(SupportsWhatsNewAttribute)); AddToOutput($"assembly:&#123;theAssembly.FullName&#125;"); if (supportsAttribute==null) &#123; AddToOutput("这个程序集不支持"); return; &#125; else &#123; AddToOutput("定义的类型是："); &#125; //获取程序集中定义的公共类型集合 IEnumerable&lt;Type&gt; types = theAssembly.ExportedTypes; foreach ( Type definedType in types) &#123; DisplayTypeInfo(definedType); &#125; Console.WriteLine(backDateTo); Console.WriteLine(outputText.ToString()); Console.ReadLine(); &#125; public static void DisplayTypeInfo(Type type) &#123; if (!type.GetTypeInfo().IsClass) &#123; return; &#125; AddToOutput($"&#123;Environment.NewLine&#125;类 &#123;type.Name&#125;"); //获取类型的详细信息然后获取其自定义详细信息选择自定义特性再筛选时间 IEnumerable&lt;LastModifiedAttribute&gt; lastModifiedAttributes = type.GetTypeInfo().GetCustomAttributes() .OfType&lt;LastModifiedAttribute&gt;().Where(a =&gt; a.DateModified &gt;= backDateTo).ToArray(); if (lastModifiedAttributes.Count()==0) &#123; AddToOutput($"\t这个&#123;type.Name&#125;没有改变&#123;Environment.NewLine&#125;"); &#125; else &#123; foreach (LastModifiedAttribute item in lastModifiedAttributes) &#123; WriteAttributeInfo(item); &#125; AddToOutput("这些类的修改方法："); //获取类的信息中的方法 foreach (MethodInfo methond in type.GetTypeInfo().DeclaredMembers.OfType&lt;MethodInfo&gt;()) &#123; //获取这些方法的自定义特性信息筛选时间 IEnumerable&lt;LastModifiedAttribute&gt; attributesToMethods = methond.GetCustomAttributes().OfType&lt;LastModifiedAttribute&gt;() .Where(a =&gt; a.DateModified &gt;= backDateTo).ToArray(); if (attributesToMethods.Count()&gt;0) &#123; AddToOutput($"&#123;methond.ReturnType&#125;&#123;methond.Name&#125;()"); foreach (Attribute attribute in attributesToMethods) &#123; WriteAttributeInfo(attribute); &#125; &#125; &#125; &#125; &#125; static void AddToOutput(string Text) =&gt; outputText.Append("\n" + Text); private static void WriteAttributeInfo(Attribute attribute) &#123; if (attribute is LastModifiedAttribute lastModifiedAttribute) &#123; AddToOutput($"\tmodified:&#123;lastModifiedAttribute.DateModified:D&#125;:&#123;lastModifiedAttribute.Changes&#125;"); if (lastModifiedAttribute.Issues!=null) &#123; AddToOutput($"\tOutstanding issues:&#123;lastModifiedAttribute.Issues&#125;"); &#125; &#125; &#125; &#125; 上面都打上了详细备注，完整的项目示例已存放在Github上。有兴趣的可以Download下来看看。 总结 本篇文章主要介绍了Type和Assembly类，它们是访问反射所提供的扩展功能的主要入口点。反射是.NET中的重要机制，通过反射，可以在运行时获得程序或程序集中每一个类型（包括类、结构、委托、接口和枚举等）的成员和成员的信息。 不是井里没有水，而是你挖的不够深。不是成功来得慢，而是你努力的不够多。]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue创建项目配置]]></title>
    <url>%2F2019%2F08%2F15%2FVue%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言 安装VS Code，开始vue的学习及编程，但是总是遇到各种各样的错误，控制台语法错误，格式错误。一股脑的袭来，感觉创建个项目怎么这个麻烦。这里就讲一下vue的安装及创建。 安装环境 当然第一步还是先下载VS Code咯。然后傻瓜式的安装一步接一步的进行下去就完事。然后打开进入VS Code，这里会提醒你，有些配置可能需要重启之后才会生效，这个看你个人的安排。也可以最后进行重启。 一、中文语言环境安装 1、使用快捷键组合【Ctrl+Shift+p】，在搜索框中输入“configure display language”，点击确定后选择zh-cn. 2、如果没有zh-cn选项，我们就【Ctrl+Shift+X】打开扩展窗口搜索Chinese进行安装。 3、在返回搜索框去设置，然后重启VS Code 二、vetur插件的安装 这个插件是vue文件基本语法高亮显示的插件。点击【Ctrl+Shift+X】打开插件扩展窗口搜索vetur进行安装。安装完成之后需要在配置文件中进行配置。 文件=&gt;首选项=&gt;设置=&gt;常用设置=&gt;settings.json中添加一下配置。 1234"emmet.syntaxProfiles": &#123;"vue-html": "html","vue": "html"&#125;, 三、eslint插件的安装 Eslint **是一个智能错误检测的插件，这个插件在实际开发中可能会发挥极其很重要的作用。能够帮我们及时的发现错误。按照上面哪一步去插件扩展窗口搜索eslint**进行安装，然后在相同的位置进行配置。 12345678910111213141516171819"eslint.validate": ["javascript","javascriptreact","html","vue"], "eslint.options": &#123;"plugins": ["html"]&#125; 最终两个插件安装完成之后配置如下。 开始创建项目 想要学好vue，那么npm命令是必不可少的。 一、安装node.js Vue,npm都是基于node.js的，所以这里我们先安装node.js 进入node.js官网，点击下载windows版本的。 然后根据步骤一步步安装就行了。然后打开CMD命令窗口进行检查。 123Node -vNpm -v 分别检查node的版本及npm的版本 二、安装Vue.js 安装vue这里我们使用NPM方法进行安装，打开命令行窗口。 安装最新稳定版本vue 1 npm install vue 全局安装 vue-cli 1npm install --global vue-cli 到这里我们基本环节配置差不多就ok了。 接下来呢我们就可以开始创建项目了。 三、创建项目1、首先我们创建一个文件夹(VueWeb)用来专门存放我们的vue项目。 2、打开命令行窗口或者VS Code的终端，然后定位到刚创建的文件夹下。 3、然后使用vue init webpack myweb命令开始创建项目。 ? Project name (**myweb) vue ———————项目名称，这里注意是不允许出现大写字母的。** ? Project description (A Vue.js project) myweb ———————项目描述 ? Author super ——————— 项目创建者 ? Vue build (Use arrow keys) 直接回车 出现 ? Vue build standalone ? Install vue-router? (Y/n) Yes ——————— 是否安装Vue路由，通过路由控制页面跳转 ? Use ESLint to lint your code? (Y/n) No ———————是否启用eslint检测规则**，这里我建议选择No，不然后面会出现各种语法不同的问题，让我有点不适应。** ? Setup unit tests? (Y/n) Yes ———————是否安装程序的单元测试 ? Pick a test runner? 回车默认 ———————选择一个测试工具 ? Setup e2e tests with Nightwatch? (Y/n) Yes———— 是否使用npm进行安装刚刚的配置 然后等待完毕，我们就可以打开VS Code然后打开刚刚我们创建的Vue项目。 四、运行项目 打开刚刚创建的Vue项目终端后，我们就可以进行运行项目前的最后几步了。 1、运行npm install命令进行相关依赖的安装。 2、然后使用 npm run dev运行项目，接下来就出现了一个网址，我们点击访问就是我们刚刚创建的项目了。 3、现在我们继续对项目进行修改，创建一个Login登录页面。 4、在src目录下新建Login文件夹及Login.vue文件并添加代码（这里注意主体代码和style和script中间是需要空一行的） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div&gt; &lt;div class="login-wrap" v-show="showLogin"&gt; &lt;h3&gt;登录&lt;/h3&gt; &lt;p v-show="showTishi"&gt;&#123;&#123;tishi&#125;&#125;&lt;/p&gt; &lt;input type="text" placeholder="请输入用户名" v-model="username"&gt; &lt;input type="password" placeholder="请输入密码" v-model="password"&gt; &lt;button v-on:click="login"&gt;登录&lt;/button&gt; &lt;span v-on:click="ToRegister"&gt;没有账号？马上注册&lt;/span&gt; &lt;/div&gt; &lt;div class="register-wrap" v-show="showRegister"&gt; &lt;h3&gt;注册&lt;/h3&gt; &lt;p v-show="showTishi"&gt;&#123;&#123;tishi&#125;&#125;&lt;/p&gt; &lt;input type="text" placeholder="请输入用户名" v-model="newUsername"&gt; &lt;input type="password" placeholder="请输入密码" v-model="newPassword"&gt; &lt;button v-on:click="register"&gt;注册&lt;/button&gt; &lt;span v-on:click="ToLogin"&gt;已有账号？马上登录&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .login-wrap&#123;text-align:center;&#125; input&#123;display:block; width:250px; height:40px; line-height:40px; margin:0 auto; margin-bottom: 10px; outline:none; border:1px solid #888; padding:10px; box-sizing:border-box;&#125; p&#123;color:red;&#125; button&#123;display:block; width:250px; height:40px; line-height: 40px; margin:0 auto; border:none; background-color:#41b883; color:#fff; font-size:16px; margin-bottom:5px;&#125; span&#123;cursor:pointer;&#125; span:hover&#123;color:#41b883;&#125;&lt;/style&gt;&lt;script&gt; export default&#123; data () &#123; return &#123; showLogin: true, showRegister: false, showTishi: false, tishi: '', username: '', password: '', newUsername: '', newPassword: '' &#125; &#125; &#125;&lt;/script&gt; 5、然后修改router路由文件下的index.js 新增 1import Login from '@/Login/Login' 修改routes： 123456789101112routes: [ &#123; path: '/', name: 'Login', component: Login &#125;, &#123; path: '/HelloWorld', name: 'HelloWorld', component: HelloWorld &#125; ] 6、运行项目 npm run dev 总结 本篇文章主要讲述VS Code 安装及环境的搭建，还有vue及node.js的环境搭建。最后达到可以创建项目运行项目的目的。然后可以通过修改路由来显示登录页面。这一篇算是比较完善完整的基础入门篇了。 永远都不要停止微笑，即使是在你难过的时候，说不定哪一天有人会因为你的笑容面爱上你。]]></content>
      <categories>
        <category>Vue系列</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Net异步编程详解入门]]></title>
    <url>%2F2019%2F08%2F14%2FNet%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言 今天周五，早上起床晚了。赶着挤公交上班。但是目前眼前有这么几件事情。刷牙洗脸、泡牛奶、煎蛋。在同步编程眼中。先刷牙洗脸，然后烧水泡牛奶。再煎蛋，最后喝牛奶吃蛋。毫无疑问，在时间紧促的当下。它完了，稳的迟到、半天工资没了。那么异步编程眼中，或许还有一丝解救的希望。先烧水，同时刷牙洗脸。然后泡牛奶，等牛奶不那么烫的时候煎个蛋。最后喝牛奶吃蛋。也许还能不迟到。在本篇文章中将围绕这个事例讲解异步编程。 异步编程不同模式 在看异步模式之前我们先看一个同步调用的事例： 123456789101112131415161718192021class Program &#123; private const string url = "http://www.cninnovation.com/"; static void Main(string[] args) &#123; AsyncTest(); &#125; public static void AsyncTest() &#123; Console.WriteLine(nameof(AsyncTest)); using (var client=new WebClient()) &#123; string content = client.DownloadString(url); Console.WriteLine(content.Substring(0,100)); &#125; Console.WriteLine(); &#125; &#125; 在这个事例中，DownloadString方法将请求的地址下载为string资源，但是在我们实际运行当中，因为DownloadString方法阻塞调用线程，直到返回结果。整个程序就一直卡在了DownloadString方法这里。这样的体验是非常的不愉快的。有了问题，自然也就有了对应的解决方法，下面我们就一起来看看对应的解决方法的进步史吧。 一、异步模式 异步模式是处理异步特性的第一种方式，它不仅可以使用几个API，还可以使用基本功能（如委托类型）。不过这里需要注意的是在使用.NET Core调用委托的这些方法时，会抛出一个异常，其中包含平台不支持的信息。 异步模式定义了BeginXXX方法和EndXXX方法。例如上面同步方法是DownloadString，那么异步就是BeginDownloadString和EndDownloadString方法。BeginXXX方法接收其同步方法的所有输入的参数，EndXXX方法使用同步方法所有的输出参数，并按照同步方法的返回类型来返回结果。BeginXXX定义了一个AsyncCallback参数，用于接受在异步方法执行完成后调用的委托。BeginXXX方法返回IAsyncResult，用于验证调用是否已经完成，并且一直等到方法执行结束。 我们看下异步模式的事例，因为上面事例中的WebClient没有异步模式的实现，这里我们使用WebRequest来代替： 1234567891011121314151617181920212223242526class Program &#123; private const string url = "http://www.cninnovation.com/"; static void Main(string[] args) &#123; AsyncTest(); &#125; public static void AsyncTest() &#123; Console.WriteLine(nameof(AsyncTest)); WebRequest request = WebRequest.Create(url); IAsyncResult result = request.BeginGetResponse(ReadResponse, null); Console.ReadLine(); void ReadResponse(IAsyncResult ar) &#123; using (WebResponse response = request.EndGetResponse(ar)) &#123; Stream stream = response.GetResponseStream(); var reader = new StreamReader(stream); string content = reader.ReadToEnd(); Console.WriteLine(content.Substring(0, 100)); Console.WriteLine(); &#125; &#125; &#125; &#125; 上面事例中展现了异步调用的一种方式—使用异步模式。先使用WebRequest类的Create方法创建WebRequest，然后使用BeginGetResponse方法异步将请求发送到服务器。调用线程没有被阻塞。第一个参数上面有讲，完成后回调的委托。一旦网络请求完成，就会调用该方法。 在UI应用程序中使用异步模式有一个问题：回调的委托方法没有在UI线程中允许，因此如果不切换到UI，就不能访问UI元素的成员，而是抛出一个异常。调用线程不能访问这个对象，因为另一个线程拥有它。为了简化这个过程在.NET Framework 2.0 中引入了基于时间的异步模式，这样更好的解决了此问题，下面就介绍基于事件的异步模式。 二、基于事件的异步模式 基于事件的异步模式定义了一个带有”Async”后缀的方法。下面看下如何使用这个基于事件的异步模式，还是使用的第一个事例进行修改。 12345678910111213141516171819202122class Program &#123; private const string url = "http://www.cninnovation.com/"; static void Main(string[] args) &#123; AsyncTest(); &#125; public static void AsyncTest() &#123; Console.WriteLine(nameof(AsyncTest)); using (var client =new WebClient()) &#123; client.DownloadStringCompleted += (sender, e) =&gt; &#123; Console.WriteLine(e.Result.Substring(0,100)); &#125;; client.DownloadStringAsync(new Uri(url)); Console.ReadLine(); &#125; &#125; &#125; 在上述事例中，对于同步方法DownloadString，提供了一个异步变体方法DownloadStringAsync。当请求完成时会触发DownloadStringCompleted 事件，关于事件使用及描述前面文章已有详细介绍了。这个事件类型一共带有两个参数一个是object类型，一个是DownloadStringCompletedEventArgs类型。后面个这个类型通过Result属性返回结果字符串。 这里使用的DownloadStringCompleted 事件，事件处理成将通过保存同步上下文的线程来调用，在应用程序中这就是UI线程，因此可以直接访问UI元素。这里就是与上面那个异步模式相比更优之处。下面我们看看基于事件的异步模式进一步的改进将是什么样的————基于任务的异步模式。 三、基于任务的异步模式 在.NET Framework 4.5中更新了WebClient类，也新增提供了基于任务的异步模式，该模式也定义了一个”Async”后缀的方法，返回一个Task类型，但是由于基于事件的异步模式已经采用了，所以更改为——DownloadStringTaskAsync。 DownloadStringTaskAsync方法声明返回为Task,但是不需要一个Task类型的变量接收返回结果，只需要声明一个string类型的变量。并且使用await关键字。此关键字会解除线程的阻塞，去完成其他的任务。我们看下面这个事例 123456789101112131415161718192021222324class Program &#123; private const string url = "http://www.cninnovation.com/"; static async Task Main(string[] args) &#123; await AsyncTestTask(); &#125; public static async Task AsyncTestTask() &#123; Console.WriteLine("当前任务Id是："+Thread.CurrentThread.ManagedThreadId); Console.WriteLine(nameof(AsyncTestTask)); using (var client = new WebClient()) &#123; string content = await client.DownloadStringTaskAsync(url); Console.WriteLine("当前任务Id是："+Thread.CurrentThread.ManagedThreadId); Console.WriteLine(content.Substring(0,100)); Console.ReadLine(); &#125; &#125; &#125; 上面代码相对于之前的就较为简单多了，并且也没有阻塞，不用切换回UI线程。调用顺序也和同步方法一样。 这里我单独的放出了允许结果，新增了当前任务显示，在刚进入方法时任务为1，但是执行完成DownloadStringTaskAsync方法后，任务id变成了8，上面其他的事例允许此代码也都是返回任务id为1，这也就是基于任务的异步模式的不同点。 异步编程的基础 async和await关键字编译器功能，编译器会用Task类创建代码。如果不使用这两个关键字，也是可以用c#4.0Task类的方法来实现同样的功能，虽然会麻烦点。下面我们看下async和await这两个关键字能做什么，如何采用简单的方式创建异步方法，如何并行调用多个异步方法等等。 这里我们首先创建一个观察线程和任务的方法，来更好的观察理解发送的变化。 1234567public static void SeeThreadAndTask(string info) &#123; string taskinfo = Task.CurrentId == null ? "没任务" : "任务id是：" + Task.CurrentId; Console.WriteLine($"&#123;info&#125; 在线程&#123;Thread.CurrentThread.ManagedThreadId&#125;和&#123;taskinfo&#125;中执行"); &#125; 同时准备了一个同步方法，该方法使用Delay方法等待一段时间后返回一个字符串。 1234567891011static void Main(string[] args) &#123; var name= GetString("张三"); Console.WriteLine(name); &#125; static string GetString(string name) &#123; SeeThreadAndTask($"运行&#123;nameof(GetString)&#125;"); Task.Delay(3000).Wait(); return $"你好，&#123;name&#125;"; &#125; 一、创建任务 上面我们也说了不使用哪两个关键字也可以使用Task类实现同样的功能，这里我们采用一个简单的做大，使用Task.Run方法返回一个任务。 123456789101112131415161718192021222324252627static void Main(string[] args) &#123; SeeThreadAndTask($"运行&#123;nameof(Main)&#125;"); var name= GetStringAsync("张三"); Console.WriteLine(name.Result); Console.ReadLine(); &#125; static Task&lt;string&gt; GetStringAsync(string name) =&gt; Task.Run&lt;string&gt;(() =&gt; &#123; SeeThreadAndTask($"运行&#123;nameof(GetStringAsync)&#125;"); return GetString(name); &#125;); 二、调用异步方法 我们继续来看await和async关键字，使用await关键字调用返回任务的异步方法，但是也需要使用async修饰符。 1234567891011121314151617181920static void Main(string[] args) &#123; SeeThreadAndTask($"运行&#123;nameof(Main)&#125;"); GetSelfAsync("张三"); Console.ReadLine(); &#125; private static async void GetSelfAsync(string name) &#123; SeeThreadAndTask($"开始运行&#123;nameof(GetSelfAsync)&#125;"); string result =await GetStringAsync(name); Console.WriteLine(result); SeeThreadAndTask($"结束运行&#123;nameof(GetSelfAsync)&#125;"); &#125; 在异步方法完成前，该方法内的其他代码不会执行。但是，启动GetSelfAsync方法的线程可以被重用。该线程没有被阻塞。 这里刚开始时候中是没有任务执行的，GetStringAsync方法开始在一个任务中执行，这里所在的线程也是不同的。其中GetString和GetStringAsync方法都执行完毕，等待之后返回现在GetStringAsync开始转变为线程3，同时也没有任务。await确保任务完成后继续执行，但是现在使用的是另一个线程。这一个行为在我们使用控制台应用程序和具有同步上下文的应用程序之间是不同的。 三、使用Awaiter 可以对任何提供GetAwaiter方法并对awaiter的对象async关键字。其中awaiter用OnCompleted方法实现INotifyCompletion接口，完成任务时调用，下面事例中没有使用await关键字，而是使用GetAwaiter方法，返回一个TaskAwaiter，并且使用OnCompleted方法，分配一个在任务完成时调用的本地函数。 1234567891011121314151617181920212223242526272829static void Main(string[] args) &#123; SeeThreadAndTask($"运行&#123;nameof(Main)&#125;"); GetSelfAwaiter("张三"); Console.ReadLine(); &#125; private static void GetSelfAwaiter(string name) &#123; SeeThreadAndTask($"运行&#123;nameof(GetSelfAwaiter)&#125;"); TaskAwaiter&lt;string&gt; awaiter = GetStringAsync(name).GetAwaiter(); awaiter.OnCompleted(OnCompletedAwauter); void OnCompletedAwauter() &#123; Console.WriteLine(awaiter.GetResult()); SeeThreadAndTask($"运行&#123;nameof(GetSelfAwaiter)&#125;"); &#125; &#125; 我们看这个运行结果，再与上面调用异步方法的运行结果进行对比，好像类似于使用await关键字的情形。相当于编译器把await关键字后面的所有的代码放进OnCompleted方法的代码块中完成。当然也可另外方法使用GetAwaiter方法。 12345678910111213141516171819202122static void Main(string[] args) &#123; SeeThreadAndTask($"运行&#123;nameof(Main)&#125;"); GetSelfAwaiter("张三"); Console.ReadLine(); &#125; private static void GetSelfAwaiter(string name) &#123; SeeThreadAndTask($"运行&#123;nameof(GetSelfAwaiter)&#125;"); string awaiter = GetStringAsync(name).GetAwaiter().GetResult(); Console.WriteLine(awaiter); SeeThreadAndTask($"运行&#123;nameof(GetSelfAwaiter)&#125;"); &#125; 四、延续任务 这里我们介绍使用Task对象的特性来处理任务的延续。GetStringAsync方法返回一个Task对象包含了任务创建的一些信息，并一直保存到任务完成。Task类的ContinueWith定义了完成任务之后就调用的代码。这里指派给ContinueWith方法的委托接收将已完成的任务作为参数传入，可以使用Result属性访问任务的返回结果。 123456789101112131415161718192021222324252627static void Main(string[] args) &#123; SeeThreadAndTask($"运行&#123;nameof(Main)&#125;"); GetStringContinueAsync("张三"); Console.ReadLine(); &#125; /// &lt;summary&gt; /// 使用ContinueWith延续任务 /// &lt;/summary&gt; /// &lt;param name="name"&gt;&lt;/param&gt; private static void GetStringContinueAsync(string name) &#123; SeeThreadAndTask($"开始 运行&#123;nameof(GetStringContinueAsync)&#125;"); var result = GetStringAsync(name); result.ContinueWith(t=&gt; &#123; string answr = t.Result; Console.WriteLine(answr); SeeThreadAndTask($"结束 运行&#123;nameof(GetStringContinueAsync)&#125;"); &#125;); &#125; 这里我们观察运行结果可以发现在执行完成任务后继续执行ContinueWith方法。其中这个方法在线程4和任务2中完成。这里相当于又开始了一个新的任务，也就是使用ContinueWith方法对任务进行一定的延续。 五、多个异步方法的使用 在每个异步方法中可以调用一个或多个异步方法。那么如何进行编码呢？这就看这些异步方法之间是否存在相互依赖了。 正常来说按照顺序调用： 123456789101112131415161718static void Main(string[] args) &#123; SeeThreadAndTask($"运行&#123;nameof(Main)&#125;"); ManyAsyncFun(); Console.ReadLine(); &#125; private static async void ManyAsyncFun() &#123; var result1 = await GetStringAsync("张三"); var result2 = await GetStringAsync("李四"); Console.WriteLine($"第一个人是&#123;result1&#125;,第二个人是&#123;result2&#125;"); &#125; 使用await关键字调用每个异步方法。如果一个异步方法依赖另一个异步方法的话，那么这个await关键字就比较有效，但是如果第二个异步方法独立于第一个异步方法，这样可以不使用await关键字，这样的话整个ManyAsyncFun方法将会更快的返回结果。 还一种情况，异步方法不依赖于其他异步方法，而且不使用await，而是把每个异步方法的返回结果赋值给Task比变量，这样会运行的更快。组合器可以帮助实现这一点，一个组合器可以接受多个同一类型的参数，并返回同一类型的值。如果任务返回相同的类型，那么该类型的数组也可用于接收await返回的结果。当只有等待所有任务都完成时才能继续完成其他的任务时，WhenAll方法就有实际用途，当调用的任务在等待完成时任何任务都能继续完成任务的时候就可以采用WhenAny方法，它可以使用任务的结果继续。 12345678910111213141516171819static void Main(string[] args) &#123; SeeThreadAndTask($"运行&#123;nameof(Main)&#125;"); ManyAsyncFunWithWhenAll(); Console.ReadLine(); &#125; private static async void ManyAsyncFunWithWhenAll() &#123; Task&lt;string&gt; result1 = GetStringAsync("张三"); Task&lt;string&gt; result2 = GetStringAsync("李四"); await Task.WhenAll(result1, result2); Console.WriteLine($"第一个人是&#123;result1.Result&#125;,第二个人是&#123;result2.Result&#125;"); &#125; 在使用await依次调用两个异步方法时，诊断会话6.646秒，采用**WhenAll**时，诊断会话话费3.912秒，可以看出速度明显提高了。 六、使用ValueTasks C#带有更灵活的await关键字：它现在可以等待任何提供GetAwaiter方法的对象。下面我们讲一个可用于等待的新类型—–ValueTask，与Task相反，ValueTask是一个结构。这具有性能优势，因ValueTask在堆上没有对象。 123456789101112131415161718192021222324252627282930313233static async Task Main(string[] args) &#123; SeeThreadAndTask($"运行&#123;nameof(Main)&#125;"); for (int i = 0; i &lt; 10000; i++) &#123; string result2 = await GetStringDicAsync("张三"); &#125; Console.WriteLine("结束"); Console.ReadLine(); &#125; private readonly static Dictionary&lt;string, string&gt; names = new Dictionary&lt;string, string&gt;(); private static async ValueTask&lt;string&gt; GetStringDicAsync(string name) &#123; if (names.TryGetValue(name,out string result)) &#123; return result; &#125; else &#123; result = await GetStringAsync(name); names.Add(name,result); return result; &#125; &#125; 上面事例中我们使用ValueTask替代了Task，因为我们前面讲，每次使用Task都会对内存进行分配空间，在我们反复时会造成一定的性能上的损耗，但是使用ValueTask只会存放在Stack中，存放实际值而不是记忆地址。 七、转换异步模式 并非所有的.NET Framework的所有的类都引用了新的异步方法，在使用框架中不同的类的时候会发现，还有许多类只提供了BeginXXX方法和EndXXX方法的异步模式，没有提供基于任务的异步模式，但是我们可以把异步模式更改为基于任务的异步模式。 提供的Task.Factory.FromAsync&lt;&gt;泛型方法，将异步模式转换为基于任务的异步模式。 1234567891011121314151617181920212223242526static void Main(string[] args) &#123; ConvertingAsync(); Console.ReadLine(); &#125; private static async void ConvertingAsync() &#123; HttpWebRequest request = WebRequest.Create("http://www.cninnovation.com/") as HttpWebRequest; using (WebResponse response = await Task.Factory.FromAsync&lt;WebResponse&gt;(request.BeginGetResponse(null,null),request.EndGetResponse)) &#123; Stream stream = response.GetResponseStream(); using (var reader=new StreamReader(stream)) &#123; string content = reader.ReadToEnd(); Console.WriteLine(content.Substring(0,100)); &#125; &#125; &#125; 异步编程的错误处理 上一节我们讲了错误和异常处理，但是我们在使用异步方法时，应该知道一些特殊的处理方式，我们先看一个简单的事例 1234567891011121314151617181920212223242526static void Main(string[] args) &#123; Dont(); Console.WriteLine("结束"); Console.ReadLine(); &#125; static async Task ThrowAfterAsync(int ms, string msg) &#123; await Task.Delay(ms); throw new Exception(msg); &#125; private static void Dont() &#123; try &#123; ThrowAfterAsync(200,"第一个错误"); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; &#125; 在这个事例中，调用了异步方法，但是并没有等待，try/catch就捕获不到异常，这是因为Dont方法在抛出异常前就运行结束了。 一、异步方法的异步处理 那么异步方法的异常怎么处理呢，有一个较好的方法就是使用await关键字。将其放在try/catch中，异步方法调用完后，Dont方法就会释放线程，但它会在任务完成时保持任务的引用。 123456789101112private static async void Dont() &#123; try &#123; await ThrowAfterAsync(200,"第一个错误"); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; &#125; 二、多个异步方法的异步处理 那么多个异步方法调用，每个都抛出异常怎么处理呢？我们看下面事例中 1234567891011121314private static async void Dont() &#123; try &#123; await ThrowAfterAsync(200,"第一个错误"); await ThrowAfterAsync(100, "第二个错误"); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; &#125; 调用两个异步方法，但是都抛出异常，因为捕获了一个异常之后，try块代码就没有继续调用第二方法，也就只抛出了第一个异常 12345678910111213private static async void Dont() &#123; try &#123; Task t1 = ThrowAfterAsync(200, "第一个错误"); Task t2 = ThrowAfterAsync(100, "第二个错误"); await Task.WhenAll(t1,t2); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; &#125; 对上述事例修改，采用并行调用两个方法，在2s秒后第一个抛出异常，1s秒后第二个异常也抛出了，使用Task.WhenAll,不管是否抛出异常，都会等两个任务完成。因此就算捕获了第一个异常也会执行第二个方法。但是我们只能看见抛出的第一个异常，没有显示第二个异常，但是它存在在列表中。 三、使用AggregateException这里为了得到所有失败任务的异常信息，看将Task.WhenAll返回的结果写到一个Task变量中。这个任务会一个等到所有任务结束。 1234567891011121314151617181920212223private static async void Dont() &#123; Task taskResult = null; try &#123; Task t1 = ThrowAfterAsync(200, "第一个错误"); Task t2 = ThrowAfterAsync(100, "第二个错误"); await (taskResult=Task.WhenAll(t1,t2)); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); foreach (var item in taskResult.Exception.InnerExceptions) &#123; Console.WriteLine(item.Message); &#125; &#125; &#125; 这里可以访问外部任务的Exception属性了。Exception属性是AggregateException类型的。这里使用Task.Exception.InnerExceptions属性，它包含了等待中所有的异常列表。这样就可以轻松的变量所有的异常了。 总结 本篇文章介绍了三种不同的异步模式，同时也介绍 了相关的异步编程基础。如何对应的去使用异步方法大有学问，用的好的异步编程减少性能消耗，提高运行效率。但是使用不好的异步编程提高性能消耗，降低运行效率也不是不可能的。这里也只是简单的介绍了异步编程的相关基础知识以及错误处理。更深更完美的编程模式还得实践中去探索。异步编程使用async和await关键字等待这些方法。而不会阻塞线程。异步编程的介绍到这里就暂时结束，下一篇文章我们将详细介绍反射、元数据。 不是井里没有水，而是你挖的不够深。不是成功来得慢，而是你努力的不够多。]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NET----错误和异常处理机制]]></title>
    <url>%2F2019%2F08%2F13%2FNET----%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 错误的出现并不总是编写程序的人的原因，有时应用程序会因为应用程序的最终用户引发的动作或运行代码的环境发生错误。无论如何，我们都应预测应用程序中出现的错误，并相应的进行编码。 .Net改进了处理错误的方式。C#处理错误的机制可以为每种错误提供自定义处理方式，并把识别错误的代码与处理错误的代码分别开来。 异常类 在C#中当出现某个特殊的异常错误条件时，就会创建抛出一个异常对象，这个对象包含有助于跟踪问题的信息。.Net提供了许多预定义的异常类，我们下面看看一些常见特别的异常类吧（异常类太多了，这里就介绍几个常见的）。 对于.Net类，一般的异常类System.Exception派生自System.Object,通常不在代码中抛出System.Exception泛型对象，因为他们无法确定错误情况的本质。 在该层次中有两个重要的类，他们派生自System.Exception类： SystemException——该类用于通常由.NET允许库抛出的异常，或者由几乎所有的应用程序抛出的异常。例如，如果.NET运行库检测到栈已满，他就会抛出StackOverflowException异常。另一方面，如果检测到调用方法时参数不对，就可以在自己的代码中选择抛出ArgumentException异常或其子类。SystemException异常的子类包括表示致命错误和非致命错误的异常。 ApplicationException—-在.NET Framework最初的设计中，是打算把这个类作为自定义应用程序异常类的基类的。不过，CLR抛出的一些异常类也派生自这个类。应用程序抛出的异常则派生自SystemException。因此从ApplicationException派生自自定义异常类型没有任何好处，取而代之的是，可以直接从Exception基类派生自定义异常类。 其他可能会用到的异常类包括： StackOverflowException——-如果分配给栈的内存区域已满，就会抛出这个异常。如果一个方法连续地递归调用自己，就可能发生栈溢出。这一般是一个致命错误，因为它禁止应用程序执行除了中断以外的其他任务。在这种情况下，甚至也不可能执行到finally块。通常用户自己不能处理像这样的错误，而应退出应用程序。 EndOfStreamException——-这个异常通常是因为读到文件末尾而抛出的，流表示数据源之间的数据流。 OverflowException—–如果要在checked上下文中把包含-40的int类型数据强制转换为uint数据，就会抛出这个异常 MemberAccessException———-该类用于处理访问类的成员失败时所引发的异常。失败的原因可能的原因是没有足够的访问权限，也可能是要访问的成员根本不存在（类与类之间调用时常用） IndexOutOfException——-该类用于处理下标超出了数组长度所引发的异常 使用try…catch…finally捕获异常 try 块包含的代码组成了程序的正常操作部分，但这部分程序可能会遇到某些严重的错误。 catch块包含的代码处理各种错误，这些错误是执行try块中的代码时遇到的问题。这个快可以用来记录错误。 finally快包含的代码清理资源或执行通常要在try块或者catch块末尾执行的其他操作。无论是否抛出异常，都会执行finally块。finally块中防止return语句，编译器会标记一个错误。另外此块可以如果没有需要关闭或者处理的其他操作可以省略此块。 异常处理具有性能含义，在常见的情况下，不应该使用异常处理错误。应尽量编写好避免错误出现的代码。 在异常捕获中，我们可以实现多个catch块来针对不同的错误做出对应的错误处理。下面我们看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Program &#123; static void Main(string[] args) &#123; while (true) &#123; try &#123; string userInput; Console.WriteLine("请输入0-5之间任意一个数字："); userInput = Console.ReadLine(); if (string.IsNullOrWhiteSpace(userInput)) &#123; break; &#125; if (int.TryParse(userInput, out int index)) &#123; if (index &lt; 0 || index &gt; 5) &#123; throw new IndexOutOfRangeException($"你输入的数字是&#123;index&#125;"); &#125; Console.WriteLine($"你输入的数字是&#123;index&#125;"); &#125; else &#123; throw new Exception("请输入数字"); &#125; &#125; catch (IndexOutOfRangeException ex) &#123; Console.WriteLine($"你输入的数字不在此范围内.&#123;ex.Message&#125;"); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; finally &#123; Console.WriteLine("谢谢合作"); &#125; &#125; &#125; &#125; 在此事例中，定义了两个catch块。如果输入的超过规定返回的数字，则会抛出超出范围的错误也就进入对应的catch块。而输入的非数字也就进入了另外一个catch块进行处理。 下面我们看一看关于System.Exception属性。熟悉了解其中熟悉能更好的去观察理解抛出的异常错误。 过滤异常、创建用户定义的异常 自从C#6开始就支持异常过滤器。Catch块仅在过滤器但会true时执行。捕获不同的异常类型时，可以有行为不同的代码块。在某些情况下，catch块基于异常的内容执行不同的操作。下面我们看下如何来使用异常过滤器吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyIndexOutOfException :SystemException &#123; public MyIndexOutOfException(string message) : base(message) &#123; &#125; public int ErrorCode &#123; get; set; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; try &#123; int steInput = 12; if (steInput &gt; 10) &#123; throw new MyIndexOutOfException("数据超出了范围") &#123; ErrorCode = 1 &#125;; &#125; &#125; catch (MyIndexOutOfException ex) when (ex.ErrorCode!=1) &#123; Console.WriteLine("出现了自定义错误"); &#125; catch (MyIndexOutOfException ex) when (ex.ErrorCode == 1) &#123; Console.WriteLine(ex.Message); &#125; catch (Exception ex) &#123; throw; &#125; &#125; &#125; 上面例子中，自定义了一个异常处理，同时增加ErrorCode，以此来作为过滤条件，利用关键字When+条件来进行过滤。 总结 本篇文章介绍了异常处理错误的情况及机制，我们不仅可以输出代码好难过的一般错误代码，也可以输出我们自己定义的特殊错误情况。无论编程技术有多好，程序都必须能处理可能出现的任何错误。对不同的错误采取相应的应对措施，才是正确编码的其中一步。 不是井里没有水，而是你挖的不够深。不是成功来得慢，而是你努力的不够多。]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 安装部署Sql Server]]></title>
    <url>%2F2019%2F08%2F12%2FDocker%20%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Sql%20Server%2F</url>
    <content type="text"><![CDATA[前言 在如今，容器化概念越来越盛行，.Net Core项目也可以跨平台部署了，那么思考下Sql Server能不能呢？当然是可以的啦。本文今天就是介绍Docker部署配置和连接Sql Server。本文基于Centos7。 配置Docker链接Sql Server 前提条件（至少2 GB的磁盘空间。至少2 GB的RAM）。我们现在开始配置安装： 查询并找到Docker Hub 上Microsoft SQL Server的介绍。 然后根据这个上docker拉取镜像 1docker pull mcr.microsoft.com/mssql/server:2017-latest 查看镜像并允许此镜像 12docker imagessudo docker run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=MyPassWord123" -p 1433:1433 --name sql1 -d mcr.microsoft.com/mssql/server:2017-latest 然后查看是否允许成功 1Docker ps -a 出现下图这样既允许成功，显示UP(如果失败的话通过docker logs 容器名进行查看错误日志) 然后这里我们就配置了SQL Server，接下来我们实际进入容器内操作。 123sudo docker exec -it sql1 "bash"/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P "MyPassWord123" 然后现在就可以进行日常的数据库操作了，输入命令后执行Go结束 创建库 1CREATE DATABASE TestDB 使用库、创建表 123USE TestDBCREATE TABLE Inventory (id INT, LastName NVARCHAR(50), FirstName NVARCHAR(50)) 查询表 1Select * from Inventory 查询用户创建的表 1select name from sysobjects where type = 'U' 系统表sysobjects保存的都是数据库对象,其中type表示各种对象的类型，具体包括: U = 用户表 S = 系统表 C = CHECK 约束 D = 默认值或 DEFAULT 约束 F = FOREIGN KEY 约束 L = 日志 FN = 标量函数 IF = 内嵌表函数 P = 存储过程 PK = PRIMARY KEY 约束（类型是 K） RF = 复制筛选存储过程 TF = 表函数 TR = 触发器 UQ = UNIQUE 约束（类型是 K） V = 视图 X = 扩展存储过程及相关的对象信息。 其他配置 一、更改sa的登录密码 1sudo docker exec -it sql1 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P "MyPassWord123" -Q 'ALTER LOGIN SA WITH PASSWORD="MyPassWord456"' 二、保留数据 将主机目录装载为数据卷 1docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=MyPassWord456' -p 1433:1433 -v /var/opt/mssql -d mcr.microsoft.com/mssql/server:2017-latest 使用数据卷容器 1docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=MyPassWord456' -p 1433:1433 -v sqlvolume:/var/opt/mssql -d mcr.microsoft.com/mssql/server:2017-latest 三、删除或退出容器 删除容器：docker rm 容器名 删除镜像：docker rmi 镜像名 退出容器;Ctrl+D 夫志当存高远，慕先贤，绝情欲，弃疑滞，使庶几之志，揭然有所存，恻然有所感；忍屈伸，去细碎，广咨问，除嫌吝，虽有淹留，何损于美趣，何患于不济。 若志不强毅，意不慷慨，徒碌碌滞于俗，默默束于情，永窜伏于平庸，不免于下流矣。]]></content>
      <categories>
        <category>Docker知识分享</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正向代理与反向代理]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 使用Nginx做反向代理，部署负载均衡。为啥用Nginx做反向代理？反向代理是什么意思？那么又什么是正向代理呢？一连串的问题把我给整懵了。不该如何回答。现在有时间，就慢慢的解决一下这些问题吧。 正向代理及反向代理 正向代理 我们还是先搞清楚啥是正向代理。我们先说个简单而熟悉的事情吧，大家肯定都知道代购。代购是一个什么角色呢？处于消费者和生产者之间。更像一个纽带，一个中间商。在这里他叫”代购”，程序中可以叫他”代理”。每一个代购只针对某部分特殊的产品。然而通过代购去购买的人有是各式各样不同的人。其中原理就是我要买某某国外的化妆品，买不到，找到对应的代购，他去买了然后再给我。我们可以理解这在程序中是正向代理。 在程序当中，当我们需要访问某些网站但无法访问的时候，就比如访问国外的一些论坛，无法访问。这是我们可以再香港或者没过搭建一个服务器，然后通过搭建的服务器再去访问想要访问的网站，这就是所谓的正向代理了。（客户端-正向代理服务器-原始服务器。配合代购的例子，还是比较好理解的了。买不到某物，访问不到某网站，通过中间的代购或者服务器来达到我买到某物或者客户端访问某网站的目的，就可以说是代理了。） 比如我现在目前使用的Shadowsocks软件，就是通过配置美国那边的服务器配置来达到访问Google资源的目的，它这个工具就充当了一个正向代理的作用。 反向代理 说完正向代理再看反向代理，反向代理恰好和正向代理有点相反了。通过正向代理访问某些网站时，那些网站是不知道实际访问的客户端的，这里隐藏了真实的客户端。而反向代理，却是隐藏了真实的服务器，客户端通过反向代理去访问，并不知道访问的是哪一个服务器。 这里当客户端访问服务器的时候先经过反向代理服务器，然后反向代理服务器转发请求给服务器，至于是服务器一还是服务器二还是服务器三的话，这个客户端就不知道了。客户端只要请求过来得到需要的东西就ok。这一过程也就是反向代理了。 使用场景 上面我们详细介绍了反向代理及正向代理。那到底有什么用呢？有些地方为什么用反向代理呢？ 首先我们看正向代理，具体可以干啥： 访问原来无法访问的资源，通过Shadowsocks访问google资源 使用使用缓冲特性，可以做缓存，加速访问资源 对客户端访问授权，上网进行认证 那么反向代理呢？ 保护内网的安全，隐藏内网服务器地址，防止Web的攻击 部署负载均衡，通过反向代理部署负载均衡优化网站 Nginx反向代理 这里我们提一下Nginx，比较常见的就是使用Nginx做反向代理或者部署负载均衡。其中Nginx仅仅只是实现反向代理的工具而已，具体Nginx的安装及使用在之前的文章（Nginx安装与代理）有提过。Nginx (engine x) 是一个高性能的HTTP和反向代理服务器，Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件代理服务器。其特点是占有内存少，并发能力强。 总结 不过说实话反向代理正向代理都是其名词概念，实际上需要知道的是其内容，以及到底怎么用用来干啥的。不要每天喊着使用Nginx进行反向代理部署网站，到最后不知道啥是反向代理，啥是正向代理。这就有点小尴尬了。只有了解的更多一点才会用的更灵活一点。 振作低沉的士气，鼓舞消沉的信心，迸发澎湃的激情，舞动勤奋的双手，用努力去创造奇迹，用行动去开拓未来，精彩就一定会呈现！]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组（ArrayPool数组池、Span结构）]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%95%B0%E7%BB%84%EF%BC%88ArrayPool%E6%95%B0%E7%BB%84%E6%B1%A0_SpanT%E7%BB%93%E6%9E%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 如果需要使用相同的类型的多个对象，就可以使用集合和数组，这一节主要讲解数组，其中会重点涉及到Span结构和ArrayPool数组池。我们也会先涉及到简单的数组、多维数组、锯齿数组、Array类。 简单的数组、多维数组、锯齿数组 简单的数组介绍 数组的声明： 1Int [] myArray; 初始化： 1myArray=new int[4]; 还可以： 1Int [] myArray=new int []&#123;1,2,3,4&#125;; 访问数组： 1myArray[0]; 多维数组介绍 一般的数组（也称一维数组）是用一个数字来索引，多维数组用两个或两个以上的数字进行索引。 声明多维数组时中间以，隔开，我们下面声明一个二维数组。 12345int [,] twodim=new int [3,3] int[,] twodim = &#123; &#123; 1,2,3&#125;, &#123; 4,5,6&#125;, &#123; 7,8,9&#125; &#125;; 一个三维数组。 123456int[,,] threedim = &#123; &#123; &#123; 1,2&#125;,&#123; 3,4&#125; &#125;, &#123;&#123; 5,6&#125;,&#123; 7,8&#125; &#125;, &#123; &#123; 9,10&#125;,&#123; 11,12&#125; &#125; &#125;; Console.WriteLine(threedim[0,1,1]); 锯齿数组 二维数组图形： 锯齿数组 在声明锯齿数组的时候要依次放置左右括号。在初始化锯齿数组时，只对第一对方括号中设置该数组包含的行数，定义各行中元素个数的第二个方括号设为空，因为这类数组的每一行包含不同的元素个数。 int[][] jagged = new int[3][]; jagged[0] = new int[2] { 1, 2 }; jagged[1] = new int[4] { 3, 4, 5, 6 }; jagged[2] = new int[3] { 7, 8, 9 }; Array类 创建数组： 12345Array intArray1 = Array.CreateInstance(typeof(int), 5); for (int i = 0; i &lt; intArray1.Length; i++) &#123; intArray1.SetValue(33, i); &#125; 上面这段代码，描述了Array数组的创建以及设置值。CreateInstance**()方法第一个参数为元素的类型，第二个参数为定义数组的大小。SetValue**()方法设置值第一个参数为设置IDE值，第二个参数为设置的索引。 复制数组： 12int[] intArray1 = &#123; 1,2&#125;; int[] intArray2 = (int[])intArray1.Clone(); 因为数组是引用类型的，所以将一个数组的变量赋予另一个数组变量，就会得到两个引用同一个数组的变量，这是使用的是Clone()方法创建数组的浅表副本。使用Copy()方法也可以创建浅表副本，Clone()方法会创建一个数组，而Copy()方法必须传递阶数相同且有足够元素的已有数组。 排序： 1234567891011121314151617181920212223242526272829303132333435class Program &#123; static void Main(string[] args) &#123; int[] list = &#123; 34, 72, 13, 44, 25, 30, 10 &#125;; Console.Write("原始数组： "); foreach (int i in list) &#123; Console.Write(i + " "); &#125; Console.WriteLine(); // 逆转数组 Array.Reverse(list); Console.Write("逆转数组： "); foreach (int i in list) &#123; Console.Write(i + " "); &#125; Console.WriteLine(); // 排序数组 Array.Sort(list); Console.Write("排序数组： "); foreach (int i in list) &#123; Console.Write(i + " "); &#125; Console.WriteLine(); &#125; &#125; 输出： 1234原始数组： 34 72 13 44 25 30 10 逆转数组： 10 30 25 44 13 72 34 排序数组： 10 13 25 30 34 44 72` 在上述方法中Array.Sort()方法实现了数组的排序，而Array.Reverse()实现了数组的逆转 。 ArrayPool数组池 接下来重点来了，本文的重点一，ArrayPool数组池。如果一个应用需要创建和销毁许多的数组，垃圾收集器就要花费很多的功夫来做这些工作，为了较少垃圾收集器的工作，这里我们可以使用ArrayPool类来使用数组池。ArrayPool管理一个数组池，数组可以再这里租借内存，并且返回到这里。需要引用usingSystem.Buffers; 创建数组池： 1ArrayPool&lt;int&gt; arrayPool = ArrayPool&lt;int&gt;.Create(maxArrayLength:40000, maxArraysPerBucket: 10); maxArrayLength的默认值是1024X10224字节（数组的长度），maxArraysPerBucket默认值是50（数组的数量）。 这里还可以使用以下方法来使用预定义的共享池。 1ArrayPool&lt;int&gt; sharePool = ArrayPool&lt;int&gt;.Shared; 下面我们就一起看看如何去使用这个数组池吧： 123456789101112131415161718192021222324252627282930313233343536373839class Program &#123; static void Main(string[] args) &#123; //定义数组池 ArrayPool&lt;int&gt; arrayPool = ArrayPool&lt;int&gt;.Create(maxArrayLength: 10000, maxArraysPerBucket: 10); //定义使用数组的长度 int arrayLenght = 5; int[] array = arrayPool.Rent(arrayLenght); //输出数组的长度 Console.WriteLine($"定义数组长度：&#123;arrayLenght&#125;，实际数组长度：&#123;array.Length&#125;"); //对数组进行赋值 array[0] = 0; array[1] = 1; array[2] = 2; array[3] = 3; array[4] = 4; //输出数组的值 foreach (var item in array) &#123; Console.WriteLine(item); &#125; //将内存返回给数组池，clearArray设置True清除数组，下次调用时为空，设置False，保留数组，下次调用还是现在的值 arrayPool.Return(array, clearArray: true); foreach (var item in array) &#123; Console.WriteLine(item); &#125; &#125; &#125; 在上面事例中，我们使用Rent()方法请求池中的内存，Rent方法返回一个数组，其中至少包含所请求的元素个数。返回的数组可能会用到更多的内存，池中最少的请求为16个元素，紧接着是32,64,128以此类推。所以在上述例子中我们请求的长度为5，但是实际使用的元素个数为16个，多余的将根据类型对其赋值0或者null。 我们使用Return()方法将数组返回到池中，这里使用了一个可选参数clearArray，指定是否清除该数组，不清除的话下一个从池中租用这个数组的人可以读取到其中的数据。清除数据可以避免这种情况，但是会消耗更多的CPU时间。 Span Span介绍 为了快速访问托管或非托管的连续内存，可以使用Spam结构。一个可以使用Span结构的例子就是数组，Span结构在后台保存在连续的内存中，另一个例子就是长字符串。 使用Span结构，可以直接访问数组元素。数组的元素没有复制，但是它们可以直接调用，并且比复制还快。 12345678910class Program &#123; static void Main(string[] args) &#123; int[] arr1 = &#123; 3, 5, 7, 9, 11, 13, 15, 18, 19 &#125;; var span1 = new Span&lt;int&gt;(arr1); span1[1] = 11; Console.WriteLine(arr1[1]); &#125; &#125; 输出： 这里将创建的arr1数组传递给Span,同时Span类型提供了一个索引器，这里直接修改span1的第二个值，然后再输出arr1数组中的第二个值，也是被其修改过得值。 Span切片 Span它一个强大的特性是，可以使用它访问数组的部分或者切片，使用切片的时候不会复制数组元素，他们是从Span中直接访问的。下面代码介绍了创建切片的两种方法： 12345678910111213141516171819202122232425262728293031class Program &#123; static void Main(string[] args) &#123; //定义简单的数组 int[] arr2 = &#123; 3, 5, 7, 9, 11, 13, 15, 18, 19, 20, 30, 40, 50, 60 &#125;; //Span&lt;T&gt;对数组进行切片，访问arr2数组，从第三个开始，取长度6个的一个数组。 var span3 = new Span&lt;int&gt;(arr2, start: 3, length: 6); //输出切片中的值 foreach (var item in span3) &#123; Console.WriteLine(item); &#125; Console.WriteLine(""); Console.WriteLine(""); Console.WriteLine(""); //对span3进行切片处理，从第二个开始，去长度4个的一个数组 var span4 = span3.Slice(start: 2, length: 4); foreach (var item in span4) &#123; Console.WriteLine(item); &#125; &#125; &#125; ** 输出：** 使用Span改变值 前面介绍了如何使用Span的索引器，更改数组的元素，下面介绍的将会有更多的选项，关于修改元素的值及复制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Program &#123; static void Main(string[] args) &#123; //定义简单的数组 int[] arr = &#123; 3, 5, 7, 9, 11, 13, 15, 18, 19, 20, 30, 40, 50, 60 &#125;; //将数组传递给span var span = new Span&lt;int&gt;(arr); var span2 = new Span&lt;int&gt;(arr); //对span进行切片处理，从第四个开始 var span3 = span.Slice(start: 4 ); //调用clear方法，用0填充span3 span3.Clear(); foreach (var item in span3) &#123; Console.WriteLine("span3的值："+item); &#125; Console.WriteLine("span3的长度："+span3.Length); //创建新的切片span4，从span2开始，长度3 Span&lt;int&gt; span4 = span2.Slice(start: 3, length: 3); //调用Fill方法，用传入的值填充span4 span4.Fill(42); foreach (var item in span4) &#123; Console.WriteLine("span4的值"+item); &#125; Console.WriteLine("span4的长度"+span4.Length); //将span4复制给span，复制失败 span4.CopyTo(span); //将span复制给span3 复制失败 if (!span.TryCopyTo(span3)) &#123; Console.WriteLine("复制不了"); &#125; &#125; &#125; 输出： 上面事例中，显示调用clear()方法，该方法用0填充Span，然后调用了Fill()方法，该方法用传递给Fill方法的值来填充Span，同时也可以将一个Span复制给另一个Span,这里先是采用的CopyTo,在这个方法中，如果另一个目标span不够大，就会复制失败，这里可以使用TryCopyTo来优化此功能，如果目标不够大，将会返回false。以此来判断是否复制成功。上面例子中span4长度为3，而span长度为14，这里是复制成功了，然后其下面的操作，因为span3的长度是10，span复制给span3失败了。因为span3不够大。 上面事例中提供了改变值的一些方法，当我们不需要对值进行改变，只需要对数组进行读访问的时候，我们可以使用ReadOnlySpan。这里定义了只读的Span 1ReadOnlySpan&lt;int&gt; readonlySpan = new ReadOnlySpan&lt;int&gt;(arr); 总结 在本篇文章中，重点介绍了ArrayPool数组池和Span结构，通过使用数组池，来降低数组创建和销毁时消耗的性能，减少垃圾回收器的工作，使用Span可以快速的访问托管及非托管代码，创建切片来对数组和长字符串进行一定的操作。更加高效的操作数组。 青少年是一个美好而又是一去不可再得的时期，是将来一切光明和幸福的开端。——加里宁]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型协变与抗变（二）]]></title>
    <url>%2F2019%2F08%2F07%2F%E6%B3%9B%E5%9E%8B%E5%8D%8F%E5%8F%98%E4%B8%8E%E6%8A%97%E5%8F%98%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 在.NET 4之前，泛型接口是不变的。.NET 4通过协变和抗变为泛型接口和泛型委托添加了一个重要的扩展。协变和抗变指对参数和返回值的类型进行转换。 我们来看下到底什么是协变什么是抗变： 如果某个返回的类型可以由其基类替换，那么这个类型就是支持协变的 如果某个参数类型可以由其派生类替换，那么这个类型就是支持逆变（抗变）的。 函数的类型转换 在理解协变与抗变之前，我们看下面这个例子： 1234567891011121314class Program &#123; public static string Tmain(object o) &#123; return "aaa"; &#125; static void Main(string[] args) &#123; string a = "aaa"; object b = Tmain(a); &#125; &#125; 我们仔细看下这个传值和返回。注意其中发现了两次隐式转换。 1、向函数传值的时候 参数a从string类型转换成object类型 2、最后接收返回值的时候b由string类型转换成object类型 我们在返回函数来看。 1、 String Tmain(object o) 可以转换成string Tmain(string o) 2、 String Tmain(string o) 可以转换成 object Tmain(string o) 在这里，也就是说函数输入的时候输入类型可以从object转换成string。基类-派生类 在函数输出时，函数的输出类型（返回类型）从string转换成object。派生类-基类。 这里就比较接近泛型接口的协变和抗变的概念了。我们再看我们开头的概念 如果某个返回的类型可以由其基类替换，那么这个类型就是支持协变的 如果某个参数类型可以由其派生类替换，那么这个类型就是支持逆变（抗变）的。 理解泛型接口的协变和抗变（in、out） 我们下面来看看泛型接口的协变及抗变的例子： 首先我们看下协变，在C#高级编程（第十一版）中指出，如果泛型类型用out关键字标注，泛型接口就是协变的。这也就意味着返回类型只能是T。 1234567891011121314151617 /// &lt;summary&gt; /// 标识out，意味着返回类型只能是T /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; interface Itest&lt;out T&gt; &#123; T Tmain(object value); &#125; public class Test : Itest&lt;string&gt; &#123; public string Tmain(object value) &#123; return value.ToString(); &#125;&#125; 我们调用时： 12345static void Main(string[] args) &#123; Itest&lt;string&gt; itest = new Test(); Itest&lt;object&gt; itestObj = itest; &#125; 在这里，我们最后接收其返回值的时候，理应由string类型进行接收的，但是这里我们可以修改，由其基类object类型进行替换。也就是在某个返回类型可以由其基类替换的时候，也就是支持协变了。注意其关键点。返回类型、由基类替换派生类。 然后我们再看看那抗变也可称为逆变。在C#高级编程中指出的概念：如果泛型类型用in关键字标注，泛型接口就是抗变的。这样，接口只能把泛型类型T用作其方法的输入。 123456789101112131415161718192021222324252627 /// &lt;summary&gt; /// 标识in，意味着输入类型只能是T /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; interface Itest&lt;in T&gt; &#123; string Tmain(T value); &#125; public class Test : Itest&lt;object&gt; &#123; public string Tmain(object value) &#123; return value.ToString(); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Itest&lt;object&gt; itest = new Test(); Itest&lt;string&gt; itestStr= itest; &#125;&#125; 这里我们看上面这个例子，其中返回类型已经是固定的string类型了。而泛型接口中的泛型类型用来作为参数传递了。我们再看调用时，正常传入object类型的参数，，但是我们修改传入参数类型为string类型也是可以的。也就是我们在参入参数时，参数可以由其派生类替换的话，那么这个类也就是支持抗变（逆变）的。注意其中关键点。传入参数，派生类替换基类。 总结 其实在上述例子及其概念中，我们可以发现，泛型接口的协变及抗变，也就是将类型参数返回或者传入的情况，在这情况下进行其类型的隐式转换所遵循的规律。 协变：（使用关键字out）返回类型可以由其基类所替代的时候，就是支持协变的。 抗变（逆变）：（使用关键字in）传入参数类型可以由其派生类所代替的时候，就是支持抗变（逆变）的。 夫学须静也，才须学也，非学无以广才，非志无以成学——-诸葛亮]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型程序设计详解（一）]]></title>
    <url>%2F2019%2F08%2F07%2F%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 泛型是C#和.Net的一个重要概念，泛型不仅是C#编程语言中的一部分，而且与程序集中的IL(Intermediate Language)代码紧密的集成。 在平时编程过程中，常常会出现编写一些差不多的代码块，不同的仅是处理不同的数据类型。比如一个处理int数据的方法，现在新加了string类型的数据。是不是把之前的方法复制一遍，然后修改类型int为string。当然这样的方法是没有错的，那么后面又新增了其他的许多类型怎么办？还是复制修改吗？这样代码看上去很冗余，很复杂。这时候泛型就出现了。下面我们看下为何使用泛型吧。 优点 下面介绍下泛型的优点，尤其是下面几个： l 性能 l 类型安全 l 二进制代码重用 一、性能 ** 泛型的一个主要优点就是性能，在泛型集合类和非泛型集合类中，对值类型使用非泛型集合类，在把值类型转换为引用类型和把引用类型转换为值类型的时候，需要进行装箱和拆箱的操作（前面的文章中讲到了拆箱和装箱会造成一定的性能损失），当集合数据量大的时候造成的性能损失也就随之的增大了。** 使用非泛型集合时： 1234567var list = new ArrayList();list.Add(100);//装箱 int-objectint i = (int)list[0];//拆箱 object-intforeach (int item in list)&#123; Console.WriteLine(item);//遍历拆箱输出&#125; 使用泛型集合类时： 1234567var list = new List&lt;int&gt;();list.Add(100);//无装箱操作 int i = list[0];//无拆箱拆箱 foreach (int item in list)&#123; Console.WriteLine(item);//无拆箱操作&#125; 减少装箱拆箱操作，节省了性能消耗。这也就是泛型的主要优点了。 二、类型安全 泛型另一个优点就是类型安全，这里我们还是使用非泛型集合类ArrayList()和泛型集合类List来做案例。 非泛型集合类ArrayList(): 1234567891011 var list = new ArrayList(); list.Add(100);// 添加一个int类型 list.Add("string");//添加一个string类型 foreach (int item in list) &#123; Console.WriteLine(item);//遍历循环输出 &#125;这里允许输出和抛出异常：System.InvalidCastException:“Unable to cast object of type 'System.String' to type 'System.Int32'.” 无法强制把”string”转换成int类型。 我们再看泛型集合类： 1234567 var list = new List&lt;int&gt;();list.Add(100);// 添加一个int类型list.Add("string");//添加一个string类型,编译器报错，无法从string转换到intforeach (int item in list)&#123; Console.WriteLine(item);//遍历循环输出&#125; 在添加”string”类型的时候编译器报错，无法添加。这里也就杜绝了后续的错误。这也就是保证了类型的安全。 三、二进制代码重用 泛型允许更好的重用二进制代码，泛型类型可以定义一次，并且可以再许多不同的类型实例化，相比C++来说，不用每次访问源代码。 例如上面使用的泛型集合类，using System.Collections.Generic; 中的List类，可以用int，string，自定义类去实例化。 泛型类型还可以在一种语言定义，然后再其他任何.Net语言中使用。 泛型类的功能 这里我们可以来了解下创建泛型类了之后，泛型类有哪些功能呢？ l 默认值 l 约束 l 继承 l 静态成员 一、默认值 在我们定义了泛型类型之后如何赋值呢？ 123456public class Tclass&lt;T&gt; &#123; public static T Get() &#123; T a = default; return a; &#125; &#125; 因为在泛型中初始给值不好给，你说给null吧，null是给引用类型的，你是给0吧，这又是给值类型的，这时候出现了default，当时引用类型调用时就给null，当时值类型时就0。 二、约束 说到泛型类型的约束时，不得不提关键字where，where是用来限制参数的范围的，如果不符合where条件指定的参数范围，编译是不允许通过的。 这里泛型类型的约束主要可以分为以下6中 l Where T: class（类型参数必须是引用类型） l Where T:struct（类型参数必须是值类型） 1234public class Tclass&lt;T,U&gt; where T:class //类型参数为引用类型 where U:struct //类型参数为值类型 &#123;&#125; l Where T：&lt;接口名称&gt;（类型参数必须是指定的接口或者实现指定的接口） 12345678910111213141516171819 /// &lt;summary&gt;/// 接口/// &lt;/summary&gt;interface Itest&#123;&#125;/// &lt;summary&gt;/// 定义一个字典类型/// &lt;/summary&gt;/// &lt;typeparam name="TK"&gt;&lt;/typeparam&gt;/// &lt;typeparam name="TV"&gt;&lt;/typeparam&gt;class Dictionary&lt;TK, TV&gt; where TK : IComparable, IEnumerable where TV : Itest&#123; public void Add(TK key, TV val) &#123; &#125;&#125; l Where T:&lt;基类名&gt;（参数必须是指定的基类或者是派生自指定的基类） 1234class Ttest &#123; &#125; class Tclass&lt;T&gt; where T:Ttest &#123; &#125; l Where T:new ()（这是一个构造函数的约束，指定参数类型必须有一个默认构造函数，当与其他约束一起使用时必须放在其最后） 123 class EmployeeList&lt;T&gt; where T : Employee, IEmployee, System.IComparable&lt;T&gt;, new() &#123; // ... &#125; l Where T1:T2（这个约束指定类型T1派生自泛型类型T2，也就是说T1的参数类型要和T2一样） public class Tclass where T:IComparable { } 三、继承 泛型类型的继承与普通类的继承相似但不同。 123456789101112131415161718 /// &lt;summary&gt; /// 抽象基类，泛型类型 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; public abstract class Ttest&lt;T&gt; &#123; public abstract T Add(T x, T y); &#125;/// &lt;summary&gt;/// 继承抽象基类，实现int类型/// &lt;/summary&gt;/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; class Tclass&lt;T&gt; : Ttest&lt;int&gt; &#123; public override int Add(int x, int y) =&gt; x + y; &#125; 四、静态成员 泛型类型的静态成员需要特殊的关注，泛型类的静态成员只能在类的一个实例中共享。 123456789101112131415161718/// &lt;summary&gt;/// 泛型类型，静态字段x/// &lt;/summary&gt;/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;public class Ttest&lt;T&gt;&#123; public static int x;&#125;class Program&#123; static void Main(string[] args) &#123; Ttest&lt;string&gt;.x = 111; Ttest&lt;int&gt;.x = 222; Console.WriteLine(Ttest&lt;string&gt;.x); &#125;&#125; 上面事例中最后输出的为111， 总结 这里我们主要是介绍了泛型的优点及泛型类型的功能。在我们日常的编程中会发现很多地方可以使用泛型。提高代码的扩展性及重用性。同时也可以减少对object类型的使用，采用泛型类型的使用来替代。较少对性能的消耗。我们下一节主要是对泛型类型的协变及抗变进行一定的理解。 只要认为是对的就去做，坚持去做，不要在乎别人的看法，哪怕是错，至少你有去做过证明曾经你努力过。]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象三大特效————封装、继承、多态]]></title>
    <url>%2F2019%2F08%2F07%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7-----%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[前言 前面有文章写到了面向对象编程和面向对象设计的头五大原则(SOLID五大原则)。今天我们再来谈谈面向对象的三大特性–封装、继承、多态 封装 被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中”。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。**封装只公开某些对外接口，隐藏具体实现细节。增加了一定的安全性，防止信息的泄露以及破坏。** 讲到封装，我们又得提下访问修饰符了。 public：所有对象都可以访问； private：对象本身在对象内部可以访问； protected：只有该类对象及其子类对象可以访问 internal：同一个程序集的对象可以访问； protected internal：访问限于当前程序集或派生自包含类的类型。 继承** 继承是软件复用的一种形式。使用继承可以复用现有类的数据和行为，为其赋予新功能而创建出新类。** ** 在现有类（基类、父类）上建立新类（派生类、子类）的处理过程称为继承。派生类能自动获得基类的除了构造函数和析构函数以外的所有成员，可以在派生类中添加新的属性和方法扩展其功能。** ** 这里继承又可分为以下系列：** 单重继承：表示一个类可以派生自一个基类，C#采用此继承 多重继承：多重继承允许一个类派生自多个类，C#不支持多重继承，但允许接口的多重继承 多层继承：多层继承允许有更大的层此结构，类B派生自类A，类C派生自类B，其中，类B也称为中间基类，C#支持它，也很常用。 接口继承：允许接口多重继承 多态** 多态指在程序设计中存在同名不同方法的存在，主要通过子类对父类的覆盖来实现多态，设计原则之一就是要依赖于抽象，而不依赖于具体，增加灵活性。多态就是为了体现这一原则。** 实例讲解 这里我们假设一个场景，对图形的面积进行计算。在这里我们就抽象一个基类，形状。然后其他的设计都来继承它。 ** 类设计** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/// &lt;summary&gt;/// 抽象类/// &lt;/summary&gt;public abstract class Shape&#123; private string ShapeName &#123; get; set; &#125; public Shape(string shapeName) &#123; this.ShapeName = shapeName; &#125; /// &lt;summary&gt; /// 计算面积 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public abstract double CalculateArea();&#125; /// &lt;summary&gt;/// 长方形/// &lt;/summary&gt;public class Rectangle:Shape&#123; /// &lt;summary&gt; /// 长 /// &lt;/summary&gt; public double Longm &#123; get; set; &#125; /// &lt;summary&gt; /// 宽 /// &lt;/summary&gt; public double Widem &#123; get; set; &#125; public Rectangle():base("Rectangle") &#123; Longm = 0; Widem=0; &#125; public override double CalculateArea() &#123; return Longm * Widem; &#125;&#125;/// &lt;summary&gt;/// 圆形/// &lt;/summary&gt;public class Circle: Shape&#123; /// &lt;summary&gt; /// 半径 /// &lt;/summary&gt; public double R &#123; get; set; &#125; public Circle(): base("Circle ") &#123; R = 0; &#125; public override double CalculateArea() &#123; return Math.PI*R*R; &#125;&#125; 调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("请选择计算面积的图形：长方形（A）/圆形（B）"); string answer = Console.ReadLine(); if (answer=="A") &#123; double longm=0; double widem = 0; try &#123; Console.WriteLine("请输入长："); longm = double.Parse(Console.ReadLine()); Console.WriteLine("请输入宽："); widem = double.Parse(Console.ReadLine()); &#125; catch (Exception) &#123; Console.WriteLine("请输入数字!"); &#125; Rectangle rectangle = new Rectangle(); rectangle.Longm = longm; rectangle.Widem = widem; Console.WriteLine($"此长方形的面积是&#123;rectangle.CalculateArea()&#125;"); &#125; else &#123; double r=0; try &#123; Console.WriteLine("请输入半径："); r = int.Parse(Console.ReadLine()); &#125; catch (Exception) &#123; Console.WriteLine("请输入数字!"); &#125; Circle circle = new Circle(); circle.R = r; Console.WriteLine($"此圆形的面积是&#123;circle.CalculateArea()&#125;"); &#125; &#125; &#125; 总结 本个案例实际作用不是很大，主要是方便讲解理解封装继承多态，在实例中，对图形的名称封装，抽象一个抽象类图形基类，圆形和长方形继承此基类。override 重写实现面积计算的多态。更多的还是需要在实际项目中实际运用的。 ** 再长的路，一步步也能走完，再短的路，不迈开双脚也无法到达。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托与事件-委托详解（三）]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6-%E5%A7%94%E6%89%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 这两天一直在想如何结合实际案例来结束委托与事件的讲解，下面讲解两个事例，用来加深对委托及事件的理解。 事例一（分页功能） 本场景是用来讲解使用的，具体内容功能需自行填补实现。用委托加事件来实现分页功能的通用。按上一节讲解中的逻辑处理，分为订阅者和发布者，一样的可以先定义订阅者感兴趣的对象，然后发布者，订阅者。再就是主程序调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 /// &lt;summary&gt;/// 首先定义订阅者感兴趣的对象，本例感兴趣的是上一页下一页等方法。这里使用Action抽象/// &lt;/summary&gt;public class PageChangeEventArgs : EventArgs&#123; public string Action &#123; get; set; &#125; public int PageIndex &#123; get; set; &#125; public PageChangeEventArgs() &#123; &#125; public PageChangeEventArgs(string action, int pageIndex) &#123; this.Action = action; this.PageIndex = pageIndex; &#125;&#125;/// &lt;summary&gt;/// 定义发布者/// &lt;/summary&gt;public class PageActionPubliser&#123; //定义委托 public delegate void PageActionEventHandler(object sender, PageChangeEventArgs e); //定义委托类型的事件 public event PageActionEventHandler PageAction; //定义保护方法判断委托事件是否为空,传入参数e类型为EventArgs protected void OnPageAction(PageChangeEventArgs e) &#123; if (PageAction != null) &#123; PageAction(this, e); &#125; //PageAction?.Invoke(this, e);也可这样写 &#125; //编写触发事件、上一页 public void PreviousClick( PageChangeEventArgs e) &#123; OnPageAction(new PageChangeEventArgs("Previous",e.PageIndex)); &#125; //下一页 public void NextClick( PageChangeEventArgs e) &#123; OnPageAction(new PageChangeEventArgs("Next",e.PageIndex)); &#125; &#125; /// &lt;summary&gt;/// 定义订阅者/// &lt;/summary&gt;public class Recevice&#123; /// &lt;summary&gt; /// 具体分页内容的实现，订阅者 /// &lt;/summary&gt; public static void BindPage(object sender, PageChangeEventArgs e) &#123; //假设最大页数为10 int MaxIndex = 10; if (e.PageIndex == 0 &amp;&amp; e.Action == "Previous") &#123; //当前0页，不能上一页 &#125; if (e.PageIndex == MaxIndex - 1 &amp;&amp; e.Action == "Next") &#123; //已是最后一页，不能下一页 &#125; switch (e.Action) &#123; case "Previous": e.PageIndex--; break; default: e.PageIndex++; break; &#125; Console.WriteLine($"已跳转到第&#123;e.PageIndex&#125;页"); &#125; &#125; /// &lt;summary&gt; /// 这里使用的是控制台应用程序进行模拟 /// &lt;/summary&gt; /// &lt;param name="args"&gt;&lt;/param&gt;class Program&#123; static void Main(string[] args) &#123; //绑定注册事件 PageActionPubliser pageActionPubliser = new PageActionPubliser(); pageActionPubliser.PageAction += Recevice.BindPage; Console.WriteLine("请选择上一页或者下一页：上一页(A)/下一页（B）"); string answer=Console.ReadLine(); PageChangeEventArgs pageChangeEventArgs = new PageChangeEventArgs(); //假设当前页为5 pageChangeEventArgs.PageIndex = 5; if (answer=="A") &#123; pageActionPubliser.PreviousClick(pageChangeEventArgs); &#125; else &#123; pageActionPubliser.NextClick(pageChangeEventArgs); &#125; &#125;&#125; 在这里委托加事件的分页功能实现完成了。其实原理很简单的，当点击上一页或者下一页的时候，这时候因为因为已经绑定注册了这个事件。 它就会具体执行其中的操作。还是要具体去实践编写操作调试一下，就很快知道它的执行顺序、也能很快的掌握的。 事例二（新车到达提醒） 这个案例，简要的表述就是在车库中新到达了车辆时会对管理者发送通知。首先我们也先分析下。订阅者是管理者。订阅者感兴趣的对象是啥呢？感兴趣的对象是有没有新车达到。 然后，我们开始这个的一个设计。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 /// &lt;summary&gt; /// 定义订阅者感兴趣的对象 /// &lt;/summary&gt; public class NewCarsEventArgs : EventArgs &#123; public string NewCardName &#123; get; set; &#125; public NewCarsEventArgs() &#123; &#125; public NewCarsEventArgs(string newCardName) &#123; this.NewCardName = newCardName; &#125; &#125; /// &lt;summary&gt; /// 定义发布者 /// &lt;/summary&gt; public class NewCarsPublisher &#123; public delegate void CarsEventHandler(object sender ,NewCarsEventArgs e); public event CarsEventHandler Cars; private void OnCars(NewCarsEventArgs e) &#123; if (Cars!=null) &#123; Cars(this,e); &#125; &#125; public void NewCarsArrivals(NewCarsEventArgs e) &#123; OnCars(e); &#125; &#125; public class NewCarsRecevie &#123; public static void Manager(object sender,NewCarsEventArgs e) &#123; Console.WriteLine($"通知：新车&#123;e.NewCardName&#125;到了!"); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; NewCarsPublisher newCarsPublisher = new NewCarsPublisher(); newCarsPublisher.Cars += NewCarsRecevie.Manager; Console.WriteLine("请输入到达车辆的名称："); string name=Console.ReadLine(); Console.WriteLine("到达车辆是否是新车（Y/N）："); string answer = Console.ReadLine(); if (answer=="Y") &#123; NewCarsEventArgs newCarsEventArgs = new NewCarsEventArgs() &#123; NewCardName=name&#125;; newCarsPublisher.NewCarsArrivals(newCarsEventArgs); &#125; else &#123; Console.WriteLine("不是新车不对订阅者发送通知!"); &#125; &#125;&#125; 谨记，事件基于委托，为委托提供了一种发布/订阅机制。理解发布订阅机制就会容易多了。一旦理清楚，发现好像也并不是很难的。多多消化一下，自己动手去想一下实例。去写一下。很快能掌握的。 总结 委托与事件到这里就大结局了。一些列的问题也解决了。心中的疑惑也揭开了。下面我们就接着基础系列写其他的了。 ** 再长的路，一步步也能走完，再短的路，不迈开双脚也无法到达。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托与事件-委托详解（二）]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6-%E5%A7%94%E6%89%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 上一节我们了解学习了委托，委托是类型安全的类，它定义了返回类型和参数的类型。委托类不仅包含对方法的引用，也可以包含对多个方法的引用。 理解委托的一种好的方式是把委托视为是给方法的签名和返回类型指定名称。 今天我们继续来了解委托和事件，现在我们来了解学习一下事件详解。 事件 事件基于委托，为委托提供了一种发布/订阅机制，在.Net中随处可见到这种事件，例如在应用程序中，Button类提供了Click事件，这类事件就是委托。 既然事件是为委托提供了发布/订阅机制，那么肯定设计到两个角色，发布者以及订阅者。 ** 事件发布者（Publisher）–事件的发布者就是一个对象，这个对象维护自身的状态信息，一旦自身的状态信息发生了改变，那么便触发一个事件** ** 事件订阅者（Subscriber）–对事件感兴趣的对象，也可以叫做Receiver，可以注册感兴趣的事件，在触发一个事件后自动执行这段代码。** ** 到底事件的一个怎么运行过程呢？在介绍此过程中我们先看下委托与事件的微软编码规范吧。** 一、上一节讲了委托的命名需以EventHandler结束 ** 二、委托原型的定义是一个void返回值而且有两个参数，一个object类型，一个EventArgs类型（或者继承此类型的）** ** 三、事件的命令是委托去掉后缀EventHandler** ** 四、继承了EventArgs需以EventArgs结尾** ** 下面我们一起来看一个简单的委托与事件案例** 委托与事件简单实例讲解 假设现在电信公司提供一个话费流量查询的功能，但是其中小明仅关心流量，小红仅关心话费，小李关心话费和流量。现在设计一段他们查询流量和话费的功能。 分析下，他们关心感兴趣的是流量多少，话费多少。–订阅者 输入查询触发事件，反馈流量多少，话费多少。–发布者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/// &lt;summary&gt;/// 所有订阅者（Subscriber）感兴趣的对象，本列中订阅者感兴趣的对象是流量话费及多少/// &lt;/summary&gt;public class PubEventArgs : EventArgs&#123; /// &lt;summary&gt; /// 话费或者流量具体值 /// &lt;/summary&gt; public readonly string mobleType; public PubEventArgs() &#123; &#125; public PubEventArgs(string mobleType) &#123; this.mobleType = mobleType; &#125;&#125; /// &lt;summary&gt;/// 发布者（publiser）/// &lt;/summary&gt;public class Publiser&#123; //先定义委托 public delegate void PublishEventHandler(object sender,PubEventArgs e); /// &lt;summary&gt; /// 定义事件，命名为委托去除EventHandler /// &lt;/summary&gt; public event PublishEventHandler Publish; /// &lt;summary&gt; /// 执行函数 /// &lt;/summary&gt; /// &lt;param name="e"&gt;&lt;/param&gt; public void OnPublish(PubEventArgs e) &#123; if (Publish!=null) &#123; this.Publish(this,e); &#125; &#125; /// &lt;summary&gt; /// 事件的触发 /// &lt;/summary&gt; /// &lt;param name="mobleType"&gt;&lt;/param&gt; public void Use( string mobleType) &#123; OnPublish(new PubEventArgs(mobleType)); &#125;&#125; /// &lt;summary&gt;/// 订阅者（Subscriber）小明/// &lt;/summary&gt;public class XiaoMing&#123; public static void Receive(object sender, PubEventArgs e) &#123; Console.WriteLine($"您的&#123;e.mobleType&#125;剩余100G"); &#125;&#125;public class XiaoHong&#123; public static void Receive(object sender,PubEventArgs e) &#123; Console.WriteLine($"您的&#123;e.mobleType&#125;余额为100元"); &#125;&#125;public class XiaoLi&#123; public static void Receive(object sender, PubEventArgs e) &#123; Console.WriteLine($"您的流量剩余100G,您的话费余额为100元"); &#125;&#125; /// &lt;summary&gt;/// 小明订阅了流量 小红订阅了话费 小李订阅了话费流量。分别查询自己所订阅的,主流程编写/// &lt;/summary&gt;class Program&#123; static void Main(string[] args) &#123; //实例化一个发布者 Publiser publiser = new Publiser(); Console.WriteLine("请输入您需要查询的业务："); string mobleType=Console.ReadLine(); if (mobleType=="流量") &#123; //事件注册 publiser.Publish += XiaoMing.Receive; &#125; else if (mobleType=="话费") &#123; publiser.Publish += XiaoHong.Receive; &#125; else &#123; publiser.Publish += XiaoLi.Receive; &#125; //调用触发事件 publiser.Use(mobleType); &#125;&#125; 在Main函数中，进行一个事件的注册，例如小明，进来Main函数，实例化一个发布者，在发布者中绑定了小明的订阅事件，然后调用发布者触发事件的方法。 发布者： 一、声明一个委托 二、基于委托声明一个事件 三、一个判断事件是否为空，然后开始执行处理事件 四、一个调用用来触发事件的方法 12345678910//先定义委托public delegate void PublishEventHandler(object sender,PubEventArgs e);/// &lt;summary&gt;/// 定义事件，命名为委托去除EventHandler/// &lt;/summary&gt;public event PublishEventHandler Publish; //事件注册 publiser.Publish += XiaoMing.Receive; 订阅者： 感兴趣的事件，最后的输出。 订阅者感兴趣的对象： 用来保存处理订阅者感兴趣的对象。 总结 我们仔细考虑下这整个委托与事件，事件的本质也就是对委托的一种使用。看我们事件注册绑定和多播委托的用法是一样的，事件的声明也是使用的委托类。 大家好好想想其中的奥妙，然后理解消化下。其实它们也没有那么难的。 下一节我们对委托和事件进行深入解析外加实际案例。 ** 再长的路，一步步也能走完，再短的路，不迈开双脚也无法到达。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托与事件-委托详解（一）]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6-%E5%A7%94%E6%89%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 说起委托和事件，我就想起了再学校的时候，当时死记硬背去记什么是委托什么是事件。记得当时蝼某人问我，委托是什么？但是只知道一点点，就跟他说:打个比方，我要喝水，但是我不去买，我委托你去帮我买水。这就是委托，够直白简单了吧。 委托语法使用** 语法： public delegate void BuyWater EventHandler();** ** 其中 delegate 是关键字，声明委托的时候命名时后缀加入 EventHandle** 这就是一个简单的委托，就是这么简单。我们相对于平时使用的方法有什么区别吧 ** 方法：** 1234public static string BuyWaterSlef()&#123; return "自己去买水";&#125; 我们看方法，是实现买水这个功能的，而委托是委托你去帮我买水的。方法是具体做事实现功能，委托只是命令而已。 我们具体使用委托来实现刚刚那个委托蝼某人去买水的程序设计。 1234567891011121314151617181920212223242526272829303132333435363738394041/// &lt;summary&gt;/// 蝼某人去买水的类/// &lt;/summary&gt;public class LouBuy&#123; /// &lt;summary&gt; /// 蝼某人买水的方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string LouBuyWater() &#123; return "蝼某人去买水"; &#125;&#125;/// &lt;summary&gt;/// 定义买水的委托/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public delegate string BuyWater(); /// &lt;summary&gt;/// 买水委托实现的类/// &lt;/summary&gt;public class MainBuy&#123; /// &lt;summary&gt; /// 实现委托 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string BuyFun() &#123; /// 委托中加入蝼某人的方法 BuyWater buyWater = new BuyWater(LouBuy.LouBuyWater); ///返回结果 return buyWater(); &#125; &#125; 最后这里输出的是”蝼某人去买水” ** BuyWater buyWater = new BuyWater(LouBuy.LouBuyWater);** ** 这里声明委托方法， BuyWater 委托中加入 LouBuy.LouBuyWater 买水的方法，**这个方法参数必须加入，因为委托的构造函数参数不为空。同时需要注意委托参数的返回类型都是要和具体委托方法一样的。 ** 在这个例子中都是返回的string，都是无参数的** 委托链（多播委托） 上面我们简单的介绍了下委托及其用法，这里我们可以了解一下委托链，顾名思义，委托链也就是委托连续，啥意思呢？继续上面的例子，我委托蝼某人去买水，然后顺带买包辣条。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// &lt;summary&gt;/// 蝼某人去买水的类/// &lt;/summary&gt;public class LouBuy&#123; /// &lt;summary&gt; /// 蝼某人买水的方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static void LouBuyWater() &#123; Console.WriteLine ("蝼某人去买水";) &#125; /// &lt;summary&gt; /// 楼某人买辣条方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static void LouBuyLT() &#123; Console.WriteLine ("楼某人又买了辣条";) &#125;&#125; /// &lt;summary&gt;/// 定义买水的委托/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public delegate void BuyWater(); /// &lt;summary&gt;/// 买水委托实现的类/// &lt;/summary&gt;public class MainBuy&#123; /// &lt;summary&gt; /// 实现委托 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static void BuyFun() &#123; /// 委托中加入蝼某人的方法 BuyWater buyWater = new BuyWater(LouBuy.LouBuyWater); buyWater += LouBuy.LouBuyLT; ///返回结果 Console.WriteLine (buyWater();) &#125; &#125; 这里就相当于我委托蝼某人做了两件事情，先去买水然后顺带买了辣条，委托链（多播委托）可以使用+=来增加委托中调用的方法，同理也可使用-=来删除委托中调用的方法. ** 注意，委托链（多播委托）–委托的签名必须返回void，否则就只能得到委托调用的最后一个方法的结果。同时委托链（多播委托）中注意不要调用一些必须有特定顺序的方法，因为委托中调用其方法链的顺序并未正式定义。** ** 委托链（多播委托）还可能出现一个非常严重的问题，也就是在委托中多个方法调用时，一旦出现了异常报错，则整个迭代都会停止。** 123456789101112131415161718192021222324252627282930313233class Pragram&#123; static void One() &#123; Console.WriteLine("one"); throw new Exception("抛出异常报错"); &#125; static void Two() &#123; Console.WriteLine("two"); &#125; public delegate void ActionMain(); static void Main() &#123; ActionMain actionMain = One; actionMain += Two; try &#123; actionMain(); &#125; catch (Exception) &#123; Console.WriteLine("异常报错"); &#125; &#125; &#125; 在这个委托调用中，遇到抛出异常错误时就会停止迭代。最终返回结果为 123one抛出异常报错 扩展延伸一、解决多播委托问题 上面讲到多播委托中一个调用抛出异常，整个迭代都会停止。下面讲解一个解决此问题的方法。在Delegate类中定义了GetInvocationList()方法，它返回的是Delegate对象数组，现在可以使用这个委托调用与委托直接相关的方法，捕获异常，并继续下一次迭代。 123456789101112131415161718192021222324252627282930313233class Pragram&#123; static void One() &#123; Console.WriteLine("one"); throw new Exception("抛出异常报错"); &#125; static void Two() &#123; Console.WriteLine("two"); &#125; public delegate void ActionMain(); static void Main() &#123; ActionMain actionMain = One; actionMain += Two; Delegate[] delegates = actionMain.GetInvocationList(); foreach (ActionMain item in delegates) &#123; try &#123; item(); &#125; catch (Exception) &#123; Console.WriteLine("抛出异常"); &#125; &#125; &#125;&#125; 再看我们对出现问题的代码进行修改，这里抛出异常之后会继续迭代，并不会停止，返回的结果是 12345one抛出异常错误Two 二、委托其他写法（Action委托和Fun委托） 我们上面介绍到委托 123public delegate void BuyWater(string a);BuyWater buyWater = new BuyWater(LouBuy.LouBuyWater); 下面我们介绍另外两种委托形式，Action委托和Fun委托 ** Action委托表示引用一个void返回类型的方法，可以没有参数，也可以有很多参数,一个参数Action,l两个参数Action&lt;in T1,in T2&gt;** 1Action&lt;string&gt; action=LouBuy.LouBuyWater; ** Fun委托表示可以调用允许带返回类型的参数，Fun表示委托类型可以调用带返回类型且无参数的方法，Fun&lt;in T,out TResult&gt;调用带返回类型带参数的方法** 1Func&lt;string, string&gt; buyWater = LouBuy.LouBuyWater;//表示返回string类型，参数也是string类型的一个方法 总结 以前总在说委托与事件，都没有一次去了解熟悉它，现在得好好巩固一下了。到这里就介绍完了委托，看上去也挺简单的。我们下一节继续看Event事件。然后结合委托一起看看委托加事件如何运用的。 ** 再长的路，一步步也能走完，再短的路，不迈开双脚也无法到达。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Net集合详解]]></title>
    <url>%2F2019%2F08%2F02%2FNet%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言 前面几篇文章讲了泛型、讲了数组，都有提到集合，这一节重点对集合进行详细解说。本文主要使用各种集合类型。以至于评估其性能，针对不同的场景选择不同的集合使用。 集合分类详解一、列表** 列表的创建** 1var intList=new List&lt;int&gt;(); ** 创建一个容量为10 的集合** 1List&lt;int&gt; intList=new List&lt;int&gt;(10); ** 列表初始值设定项** 1var intList = new List&lt;int&gt;() &#123; 1,2&#125;; ** 添加元素(通过使用Add方法进行元素添加)** 12345var intList=new List&lt;int&gt;();inList.Add(1); var intList = new List&lt;int&gt;();intList.AddRange(new List&lt;int&gt;()&#123; 1,2,3&#125;); ** 插入元素(使用insert方法插入元素)** 12345var intList = new List&lt;int&gt;();intList.Insert(3, 3); var intList = new List&lt;int&gt;();intList.InsertRange(3, new List&lt;int&gt;() &#123; 1,2,3&#125;); ** 访问元素(通过下表去实现访问或者循环遍历)** 123456789var intList = new List&lt;int&gt;(); intList.AddRange( new List&lt;int&gt;() &#123; 1,2,3&#125;); var answer = intList[2]; foreach (var item in intList) &#123; Console.WriteLine(item); &#125; ** 删除元素(通过RemoveAt指定删除某一位置的值)** 12345var intList = new List&lt;int&gt;();intList.AddRange( new List&lt;int&gt;() &#123; 1,2,3,4&#125;);intList.RemoveAt(3); ** 搜索(通过IndexOf访问指定位置的值，可以使用的方法IndexOf()、LastIndexOf()、FindLastIndex()、Find()、FindLast())** 123var intList = new List&lt;int&gt;();intList.AddRange( new List&lt;int&gt;() &#123; 1,2,3,4&#125;); int indenx = intList.IndexOf(3); 二、队列 队列是其元素以先进先出（FirstIn，FirstOut，FIFO）的方式来处理的集合，先放入队列中的元素会先读取。队列的例子比比皆是。排队买票，食堂排队打饭，先到先买，先到先打饭。 队列使用System.Collections.Generic命名空间中的泛型类Queue来实现的。这个类型类似于List。队列类使用Enqueue()方法在队列的一段插入元素，使用Dequeue()方法在另一端读取元素并删除。 12345Queue&lt;string&gt; qa = new Queue&lt;string&gt;(); qa.Enqueue("第一个进");qa.Dequeue(); 其中使用Count()返回队列中的元素总数，使用Peek()方法从队列头部读取一个元素，但不删除它。使用TrimExcess()方法重新设置队列的容量，Dequeue()虽然删除了元素，但不会重新设置容量。要从队列头部去除空元素，应使用TrimExcess()方法 三、栈 栈是与队列非常相似的另一个容器，知识使用不同的方法访问栈，而且栈的元素属于最后添加的元素最先读取也就是后进先出（LastIn,FirstOut,LIFO）。 与Queue类似，栈使用Stack来实现，其中Push()在栈中添加元素，用Pop()方法获取最近添加的元素。 12345Stack&lt;string&gt; qa = new Stack&lt;string&gt;();qa.Push("第一个进");qa.Pop(); 其中其他方法与Queue类似，使用Count()返回队列中的元素总数，使用Peek()方法从队列头部读取一个元素，但不删除它。使用Contains()确定某个元素是否存在于栈中，存在则返回True 四、有序列表 如果需要基于键对所需的集合进行排序，就可以使用SortedList&lt;TKey,TValue&gt;类。这个类按照键给的元素排序，这个集合中的值和键都可以使用任意类型。 下面先创建一个空列表，然后通过Add()方法进行添加元素。然后输出结果。我们看下图可以发现自动帮我们已经排序好了然后输出的。 123456789101112131415161718192021static void Main(string[] args) &#123; var test = new SortedList&lt;string, string&gt;(); test.Add("First","Code1"); test.Add("Two", "Code2"); test.Add("A", "Code3"); foreach (var item in test) &#123; Console.WriteLine(item.Key+":"+ item.Value); &#125; &#125; 五、字典 字典表示一种复杂的数据结构，这种数据结构允许按照某个键来访问元素。字典也称为映射或散列表。字典的主要特性是能根据键快速查找值。也可以自由添加和删除元素，这有点像List，但没有在内存中移动后续元素的性能开销。 字典的初始化： 1var dict = new Dictionary&lt;int, string&gt;() &#123; &#123;1,"第一个" &#125;,&#123;2,"第二" &#125; &#125;; 添加和输出访问 1234567 dict.Add( 3,"第一个" ); foreach (var item in dict) &#123; Console.WriteLine("Key:"+item.Key+" Value:"+ item.Value);&#125; 有序字典SortedDictionary&lt;TKey,TValue&gt;是一个二叉搜索树，其中的元素根据建排序。和前面讲的SortedList&lt;TKey,TValue&gt;的功能类似。但是SortedList&lt;TKey,TValue&gt;是基于数组的列表，而有序字典类为一个字典。多以它们也有不同之处： SortedList&lt;TKey,TValue&gt;使用的内存比SortedDictionary&lt;TKey,TValue&gt;少 SortedDictionary&lt;TKey,TValue&gt;的元素插入和删除比较快 在用已排好序的数据填充集合时，若不需要修改容量，SortedList&lt;TKey,TValue&gt;就比较快 六、集 包含不重复元素的的集合称为”集(set)”，.Net Core 包含两个集(HashSet**和SortedSet)**，它们都实现ISet接口，HashSet集包含不重复元素的无序列表，SortedSet集包含不重复元素的有序列表。 ISet接口提供的方法可以创建合集、交集，或者给出一个集是另一个集的超集或子集的信息。 1234567891011121314151617181920212223242526272829303132static void Main(string[] args) &#123; var teams = new HashSet&lt;string&gt;() &#123; "one","two","three"&#125;; var teams1= new HashSet&lt;string&gt;() &#123; "开始","one", "two", "three" &#125;; //Add方法如果集中存在该元素则不添加，返回bool值 if (!teams.Add("one")) &#123; Console.WriteLine("one 已经存在集中"); &#125; //IsSubsetOf方法判断teams集合中的元素是否都包含在teams1中，返回bool值 if (teams.IsSubsetOf(teams1)) &#123; Console.WriteLine("teams中的值都包含在teams1中"); &#125; //IsSupersetOf方法判断teams1集合是否是teams集合超集，返回bool值 if (teams1.IsSupersetOf(teams)) &#123; Console.WriteLine("teams1是teams的超集"); &#125; //Overlaps方法判断teams集合与teams是否存在重叠的元素，返回bool值 if (teams.Overlaps(teams1)) &#123; Console.WriteLine("teams与teams1有重叠元素"); &#125; &#125; 总结 许多的集合都提供了相同的功能，例如SortedList类与SortedDictionary类的功能几乎完全相同。但是其性能常常差别非常巨大，一个集合使用的内存少，另一个元素检索起来速度快，在MSDN文档中，集合的方法常常有性能的提示，给出以O记号表示的操作时间： * ** O(1)** * ** O(log n)** * ** O(n)** O(1)表示无论集合中有多少数据项，这个操作需要的时间都不变，例如，ArrayList类的Add()方法就具有这个行为，无论列表有多少个集合，在列表末尾添加一个新元素的时间都相同。 O(n)表示对于集合执行一个操作需要的时间最坏的情况是N，如果需要重新给集合分配内存，ArrayList类的Add()方法就是一个O(n)操作。改变容量，需要复制列表，复制的时间随元素的增加而线性的增加。 O(log n)表示操作需要的时间随集合中元素的增加而增加，但每个元素要增加的时间不是线性的，而是呈对数曲线。在集合中执行插入操作时，SortedDictionary&lt;TKey,TValue&gt;集合类具有O(log n)行为，而SortedList&lt;TKey,TValue&gt;集合具有O(n)行为，这里SortedDictionary&lt;TKey,TValue&gt;集合类就要快的多，因为树形结构中插入元素的效率比列表高的多。 下面表格中则列出了集合类及其执行不同操作的性能。可以使用这个表选择性能最佳的集合类进行使用。 最糟糕的是人们在生活中经常受到错误志向的阻碍而不自知，真到摆脱了那些阻碍时才能明白过来。——歌德]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类及接口详解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%8A%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、前言 在上一节中我们讲到抽象类和接口之间的异同，我们一起回顾下其异同。 ** 同：** 1、都不可以被实例化 2、都含有声明但未实现的方法 3、都可以被继承 4、其子类必须实现其声明未实现的方法 ** 异：** 1、接口是多继承，抽象类是单继承（一个类仅能继承一个抽象类，但可以继承多个接口） 2、抽象类可以包含实现的方法，接口不能包含实现的方法 3、接口支持回调，抽象类不支持 4、抽象类更多的定义在一些类关系紧密的类间，接口则定义在实现其某一种功能之间 抽象类和接口的异同我们再次熟悉了一遍，今天我们主要讲的是抽象类和接口使用场景及详讲抽象类的使用方法及接口的使用方法 二、使用场景 抽象类、普通类、接口。我们到底什么时候使用哪一个呢？这就很头痛了，不是一直使用一个就是好的。每一个都有每一个的使用场景。下面我们看看到底啥事时候用啥东西吧。 我们现在假设一个场景，现在需要设计一个程序，用来描述各个动物的一些生活习性，这里我们就有猪、猫、狗。 不使用抽象类也不使用接口。我们设计他们三个的各个习性，就是猪的类里面就包含自己的习性，猫类里面包含自己的习性，狗类里面包含自己的习性。如果各个习性较多但也有相同的。这样的类看起来非常的冗余。 我们加入抽象类（设计实现大的功能单元），定义一个抽象类-哺乳动物类，其中定义了共同的习性，走路的方法，呼吸的方法，繁衍下一代的方法。但是叫声不一样。我们又声明一个叫声的方法不实现（抽象方法）。这样再我们去定义猪类或者狗类的时候只需要写出不一样的地方即可。这样看起来代码也简洁，清楚 我们现在改用接口（设计实现小而简练的功能），我们把这些动物可以做什么列出来，然后统一使用接口去定义公共的。比如叫声，行走。这些功能，我们就可以使用接口来定义声明。然后继承再去实现。 到了这里，我们总结下到底我们编写程序为什么需要使用抽象类呢？为什么需要使用接口呢？单一用一个普通的类不好吗？简单又容易。其实不然。存在即合理。我们一起看看到底为什么要使用吧 ** 为什么使用抽象类？** ** 抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象`。这样来说如果一个类设计就是为了给其他类继承的，它代表一类对象所具有的公共属性或方法，我们就使用抽象类。就像上门的这个例子，把一些动物共同的属性或者方法提取出来，定义一个抽象类。代码变的易懂，代码冗余减少，变得简洁明了。实现了代码复用性。** ** 那么为什么使用接口呢？** ** 通俗点讲就是为了降低代码的耦合度。接口的意义在于抽象，不拘细节，从而使同类事物在在同一高度具有通用性及可替代性。上面的例子来讲，规定好了这个叫声这个方法，那么继承的就去实现这个叫声方法就好了。如果某天加入了一个新的动物，这样我们也不需要修改其他的任何方面，仅继承一下接口修改本身即可，不需要修改或改变其他的类或者接口。系统的灵活性增加了。** ** 这里可能会有个问题了。既然有了抽象类为什么还要用接口呢？这会不会有点多余？** ** 答案肯定是不会的。那么有了抽象类为什么还要使用接口呢？我们看看抽象类和接口的异同就很快能明白了。** 1、接口提供的事统一的行为规范，供其他调用，而抽象类具有接口的特性同时还可以有自己的具体实现 2、抽象类只能有一个父类，可以实现多个接口 ** 那么我们如何使用抽象类和接口呢？** 三、抽象类及接口使用 就拿我们上面举的那个例子来编写一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 /// &lt;summary&gt;/// 叫声的接口定义/// &lt;/summary&gt;public interface ICry&#123; string Cry();&#125;/// &lt;summary&gt;/// 说话的接口定义/// &lt;/summary&gt;public interface ISay&#123; string Say();&#125; /// &lt;summary&gt;/// 动物抽象的抽象类/// &lt;/summary&gt;public abstract class Animale&#123; /// &lt;summary&gt; /// 包含的实现了的方法、呼吸、走路 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Breathe() &#123; return "呼吸一样"; &#125; public static string Run() &#123; return "走路一样"; &#125; /// &lt;summary&gt; /// 未实现的抽象方法睡觉方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public abstract string Sleep();&#125;/// &lt;summary&gt;/// 普通的类 继承了抽象类及两个接口/// &lt;/summary&gt;public class Dog: Animale,ICry, ISay&#123; /// &lt;summary&gt; /// 实现重写抽象方法睡觉 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override string Sleep() &#123; return "睡觉"; &#125; /// &lt;summary&gt; /// 实现叫声接口方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string Cry() &#123; return "旺旺"; &#125; /// &lt;summary&gt; /// 实现说话接口方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string Say() &#123; return "说话"; &#125;&#125; 在上面的代码中，我们列举出了接口的定义及抽象类、抽象方法的定义及使用。在最下面一个普通类中，我们继承了一个抽象类及两个接口，可以实现多个接口但是只能有一个抽象父类。如果继承两个抽象类的话会报错的。 ** 抽象类关键字**–abstract ** 接口关键字–interface** 四、扩展延伸（密封类） 讲到抽象类，我们也可以一起看看密封类，密封类不能作为基类，禁止派生。如果重写了某些功能会导致编译错误或者为了防止第三方进行扩展重写，这个时候我们就可以使用到密封类。 ** 重点注意**： ** 1、密封类中不能包含虚方法（Virtual）和抽象方法（abstract）。因为密封类是不能被继承的也就没有派生类，就不具备实现抽象方法和虚方法的机会。** ** 2、在使用密封类（sealed）的时候，密封类将限制它的使用，现在及未来都将受到影响** ** 3、如果实例方法包含了sealed修饰符，那么它也必须包含override修饰符，其父类方法必须包含virtual修饰符** 12345678910111213141516171819202122232425262728 /// &lt;summary&gt;/// 普通动物类/// &lt;/summary&gt;public class Animals&#123; /// &lt;summary&gt; /// 动物的叫声方法，因为其派生类重写了次方法，所以必须使用virtual修饰符 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public virtual string Cry() &#123; return "叫声"; &#125;&#125;/// &lt;summary&gt;/// 动物狗类密封类，无法产生派生类，不能作为基类，继承了动物类/// &lt;/summary&gt;public sealed class Dog : Animals&#123; /// &lt;summary&gt; /// 重写了动物叫的方法，同时标记为了密封方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override sealed string Cry() &#123; return "旺旺"; &#125;&#125; ** 在使用密封类的时候我们需要考虑的因素需要更加的全面，更加的谨慎，以防后面重新推翻重写。每个东西都没有绝对的好，只有你用的恰到好处。多思考多选择才是智者。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ的介绍及使用进阶（Docker+.Net Core）]]></title>
    <url>%2F2019%2F08%2F02%2FRabbitMQ%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%EF%BC%88Docker%2B.Net%20Core%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： ** 一、什么是RabbitMQ** ** 二、RabbitMQ运用场景** ** 三、RabbitMQ优势及特点** ** 四、Centos7中Docker安装RabbitMQ** ** 五、.Net Core 中使用RabbitMQ** 一、什么是RabbitMQ RabbitMQ是什么? –”RabbitMQ是基于AMQP协议的队列服务“,. 什么是AMQP?– Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。 可以理解RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（也可以叫面向消息的中间件） 二、RabbitMQ运用场景 消息通讯—因为其本身就是基于AMQP协议的队列服务，也就可以用于单纯的消息通讯，实现点对点的消息通讯或者聊天。 提速提性能—异步处理，不需要及时同步处理并且比较耗时，减少请求响应时间 流量削峰—流量过大，应用容易挂掉，可使用队列来处理。 三、RabbitMQ优势及特点 可靠—RabbitMQ具有持久化，传输确认，发布确认等机制。保证了消息的安全性，一旦发送了消息，就算接收者接收不到，它也会保存信息，一直到接收者接收消息为止 复用性—RabbitMQ可以发送多种类型消息 异步处理（提速）—把消息传给中间件，中间件后续慢慢处理，同时也可达到削峰的效果 解耦–防止引入过多的API给系统的稳定性带来风险；调用方使用不当会给被调用方系统造成压力，被调用方处理不当会降低调用方系统的响应能力。 四、Centos7中Docker安装RabbitMQ ** 如何在Linux中安装可以看前段时间的一篇文章–https://www.cnblogs.com/hulizhong/p/10702367.html** 先拉取镜像（选择带有mangement的版本） 1docker pull rabbitmq:management 然后查看镜像拉取情况 1docker images 启动容器同时设置账号密码 1docker run --name=rabbit -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -d rabbitmq:management 查看容器运行情况 1docker ps 运行成功，然后我们就去浏览器看看能否访问ip:15672 然后输入刚刚输入的账号密码登入进去就可以查看消息队列的整体情况，到这里RabbitMQ已经安装好了，接下来我们看看如何在.Net Core中使用RabbitMQ. 五、.Net Core 中使用RabbitMQ RabbitMQ使用的话可以分为三个步骤 1、 创建RabbitMQ的连接 1234567891011121314151617181920public class ConnectionMQ &#123; /// &lt;summary&gt; /// 创建MQ连接 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IConnection Connection() &#123; //创建连接工厂 ConnectionFactory factory = new ConnectionFactory &#123; UserName = “admin”,//用户名 Password =” admin”,//密码 HostName = “127.0.0.1”//rabbitmq ip &#125;; //创建连接 var connection = factory.CreateConnection(); return connection; &#125; &#125; 2、 RabbitMQ发送消息 12345678910111213141516171819202122232425262728293031323334 public class PushMQ &#123; /// &lt;summary&gt; /// 发送MQ消息 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; /// &lt;param name="item"&gt;&lt;/param&gt; /// &lt;param name="queueName"&gt;&lt;/param&gt; public static void SendMQ&lt;T&gt;(T item,string queueName) &#123; string input = Newtonsoft.Json.JsonConvert.SerializeObject(item); using (var channel = ConnectionMQ.Connection().CreateModel()) &#123; //声明一个队列 channel.QueueDeclare( queue: queueName,//队列名称 durable: true,//队列是否持久化 exclusive: false,//是否排外的 autoDelete: false,//是否自动删除 arguments: null//消息什么时候自动 ); var sendBytes=Encoding.UTF8.GetBytes(input); var properties = new BasicProperties(); properties.DeliveryMode = 2;// 设置消息是否持久化，1： 非持久化 2：持久化 //发布消息 channel.BasicPublish( exchange: "", routingKey: queueName, mandatory: true, basicProperties: properties, body: sendBytes); &#125; &#125;&#125; 在这里连接的ConnectionMQ.Connection().CreateModel()是可以进行重写的，自己定义如何去连接 3、 RabbitMQ接收消息 123456789101112131415161718192021222324252627282930313233343536 public class ReceiveMQ &#123; /// &lt;summary&gt; /// 接收MQ消息 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; /// &lt;param name="func"&gt;&lt;/param&gt; /// &lt;param name="queueName"&gt;&lt;/param&gt; public static void GetMQ&lt;T&gt;(Func&lt;T,bool&gt; func,string queueName) &#123; //创建连接 var connection = ConnectionMQ.Connection(); //创建通道 var channel = connection.CreateModel(); //事件基本消费者 EventingBasicConsumer consumer = new EventingBasicConsumer(channel); //接收到消息事件 consumer.Received += (ch, ea) =&gt; &#123; var message = Encoding.UTF8.GetString(ea.Body); try &#123; var item = JsonConvert.DeserializeObject&lt;T&gt;(message); func(item); &#125; catch (Exception ex) &#123; LogHelp.Error(ex); &#125; //确认该消息已被消费 channel.BasicAck(ea.DeliveryTag, false); &#125;; //启动消费者 设置为手动应答消息 channel.BasicConsum、e(queueName, false, consumer); &#125;&#125; 4、查看消息 在这里我们发送消息，然后我们去ip+15672看看是否有未消费的消息。 发现有一条未消费的信息，队列名称是Test，正好是我们刚刚发送的消息。 然后我们去消费这一条信息，再次进入ip+15672看看 刚刚的一条消息的确被消费掉了。其中GetInfo方法可以穿插自己的很多的业务逻辑的处理。到这里也就简单的介绍了下如何在.Net Core中使用RabbitMQ,还有一些其他的属性必要之时都可以加入进来的。可以高度扩展的。`]]></content>
      <categories>
        <category>Docker知识分享</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows+docker 运行.NetCore]]></title>
    <url>%2F2019%2F08%2F02%2FWindows%2Bdocker%20%E8%BF%90%E8%A1%8C.NetCore%2F</url>
    <content type="text"><![CDATA[今天我们来说下如何在windows下使用docker运行.net core，既然是docker，那么我们首先得在windows上安装docker。 在Windows安装 docker 有两种选择： 1、docker for windows 2、docker toolbox 区别： docker for windows-64位Windows 10、必须开启 Hyper-V docker toolbox -有virtualbox即可 今天只给大家介绍 docker for windows安装 地址：https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe 我们下载按照步骤一步步安装就ok了，安装之后打开可能会出现一个错误，如果没有出现那肯定万事大吉咯！ Hyper-V 没开不能启动： 以管理员身份打开 PowerShell 控制台。 运行以下命令： 1Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All 现在我们再来启动即可，在右下角也会有一个图标，悬浮上去显示 docker desk is running，表示已经安装成功（这个会提示我们登录，不过登录不登录问题都不是太大，登录之后可以连接到(Docker Hub） 接下来正式进入我们今天的主题，如何而使用 docker for windows 来运行 .netcore（Start） 首先我们创建一个.net core web项目 然后我们去项目根目录去看，会发现有一个Dockerfile的文件，同样我们需要在项目当中修改Dockerfile文件的属性，修改为较新则复制。 我们可以运行一下.net core看一下出来的页面效果，到现在我们需要的.net core的事例已经准备好了，我们现在开始在docker 中部署了。 我们打开PowerShell ，输入 docker info 出现下面的界面的样子证明docker 一切正常。 我们进入到我们刚刚创建的.net core 项目的根目录，然后开始构建docker镜像，要注意命令后面的那个 . ，意思是当前目录 1docker build -t demotest . 然后我们发现在执行到第六步的时候报错了，说什么在该路径找不到该文件 我也卡在这里卡了很久，最后发现路径拼接起来不对。我们仔细检查下Dockerfile文件的第六步发现文件路径是dockertest/dockertest.csproj，再结合我们当前路径是E:\Docker\dockertest \dockertest，组合一来看，多了一个dockertest，然后我们修改Dockerfile文件中的路径去掉这个多的dockertest/ 然后我们再来执行docker build -t demotest .然后发现我们在第10步的时候又出错了，说这个程序不包含适合入口点的静态’Main’方法，我们继续检查下Dockerfile文件，发现第9步那个工作路径 是/src/dockertest，我们拼接一下发现，又多了一个/dockertest，我们接着继续去掉这个，然后继续运行docker build -t demotest . 这一次终于不负众望。它完整的运行完成了所有的步骤并且提示了 123Successfully built eaa8cea8fcf4Successfully tagged demotest:latest 我们来看看构建镜像是否真的成功了吧 1docker images 我们发现了这一个，是我们刚刚创建的demotest,既然镜像我们已经创建成功了，那我们正式运行起来看看是否可用。 1docekr run --name=demotest -p7778:80-d demotest--name：指定容器名称-p：指定容器端口-d：指定容器 后台运行 然后出现了一串字符串，说明我们启动成功了，然后我们查看一下我们正在运行的容器 1docker ps 然后我们去浏览器输入ip+7778，看到如下页面证明这次docker for windows +.net core 成功运行了。 那么到这里我们的第一的windows+docker运行.netcore算是正式完工了，然后在给大家介绍一些较为常用的docker命令（命令） 123456789101112131415161718192021docker build -t demotest . 构建 demotest镜像docker images 查看当前所有的镜像docker inspect demotest 查看 运行容器的详情docker ps 查看当前运行的容器docker ps -a 查看当前所有的容器docker stop demotest 停止运行demotest容器docker start demotest 开启运行demotest容器docker rm demotest 删除demotest容器docker rmi demotest 删除demotest镜像docker rm $(docker ps -aq) 删除所有容器docker rmi $(docker images -q) 删除所有镜像]]></content>
      <categories>
        <category>Docker知识分享</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识详解系列目录]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[摘要：这个系列是本人在学习与复习当中所遇到或尚且未知的一些知识点，目前逐步学习并详细解读。 目录索引：一、c#类型详解上 二、基础类型详解下 三、抽象类与接口 四、委托与事件-委托详解（一） 五、委托与事件-事件详解（二） 六、委托与事件-委托事件案例（三） 七、面向对象三大特性—–封装、继承、多态 八、泛型程序设计详解（一） 九、泛型协变与抗变（二） 十、数组（ArrayPool数组池、Span结构） 十一、集合（正在编写中） 十二、LINQ（正在编写中） 十三、错误异常处理（正在编写中） 十四、异步编程（正在编写中） 十五、反射、元数据和动态编程（正在编写中） 十六、托管和非托管内存（正在编写中） 总结：** 本人知识尚且有限，一旦出现误解或者少解还请各位慷慨解囊。** ** 清风飒爽柳姿还在，一片轻云漫飞天。涟漪泛湖荷叶拂舟，一曲和音绕指柔。对镜描妆素面朝天，一记浅笑去无痕。凭栏怅望凝眸思量，一片清秋气自爽。和音题文，一把辛酸暂埋藏，寻音倚歌，一帘惆怅浅卷起。但凭楼兰，倾泻柔情，不慢不躁，雅致清秋，莫使伤愁锁清秋。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NET类型详解]]></title>
    <url>%2F2019%2F07%2F31%2FNET%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、类型成员类成员定义有（public、private、internal、protected）。 Public–对任何类和成员都是公开的，无限制 Private–是私有的，仅能由类内部代码访问，如果没有声明，默认使用此关键字 Internal–仅能在所属命名空间内部访问 Protected–可以由类或者其派生类中的代码访问 类成员–字段、方法、属性 12345678910 public class MyClass &#123; public int MyInt = 2019;//字段 public static string MyMain() &#123; return "这是方法"; &#125; public int MyProperty &#123; get; set; &#125;//属性 &#125; 字段–一个只读、可读/写的数据值 方法–对类型或对象状态数据操作的一个过程实现 属性–它可以像方法一样操作类或对象的状态数据，但看上去却像字段一样的书写方式 二、类型操作（隐式转换、显示转换、装箱、拆箱）隐式转换–对于内置数值类型，如果要存储的值无需截断或四舍五入即可适应变量，则可以进行隐式转换、小精度数据转大精度也可进行隐式转换 123Int Num=100;Long Bignum= Num;&lt;/pre&gt; 显示转换–显示转换也称为强制转换，强制转换是显式告知编译器你打算进行转换且你知道可能会发生数据丢失的一种方式。 12345Double Num=100.1;Int a;a=int.Parse(Num);&lt;/pre&gt; 显示转换存在一定的风险性，如若出现失误可能会抛出异常或者影响整个结果的精确性。假如在不知a的类型的情况下进行显示转换，但是转换失败则会引起程序抛出异常。 1var a = "yi"; int b = int.Parse(a);&lt;/pre&gt; 这是可以尝试使用TryParse，这里返回的是一个bool，转换成功则True 1var a = "yi"; int b; int.TryParse(a, out b);&lt;/pre&gt; 类型操作转换–装箱、拆箱 12345678public void Test() &#123; //装箱 int a = 1; object obj = a; //拆箱 object obj2 = 2; int b = (int)obj2; &#125; 首先我们得了解，值类型是分配在线程栈中的，不受垃圾回收机制管理。而引用类型分配在托管堆中的。 装箱–简单来说值类型转换引用类型是装箱，详细来说是。先在托管内存中分配内存，然后将值类型的值复制到内存堆中，然后返回新对象的地址，这一过程为装箱。 拆箱–拆箱并不是装箱的逆过程，简单说也是引用类型转换为值类型为拆箱，详细来说拆箱是获取为装箱部分的指针，然后将未装箱部分的值复制到堆栈中。 三、类型转换(Is,As)类型转换操作符–is、as as–是将一个对象从一种类型转换为另一种类型，如果转换成功则返回该类型，否则返回null 123A a=new A();B b= A as B;//转换正常则返回B类型，转换失败则返回null&lt;/pre&gt; is–是判断一种类型转换为另一种类型，如果转换成功则返回True，否则返回False。 123456A a=new A();If(B is A)//返回True False &#123;&#125; 保险起见可以先用is对类型转换进行判断然后再使用as进行类型转换。当然这样的话可能会造成更新的性能消耗。 更简单的一次验证并安全的操作： 123A a=new A();B b= A as B; if(B!=null)&#123;&#125; else&#123;&#125; 四、类型分类一切皆对象，每一个对象都对应一个类，所有的类都有一个基类–Object-System.Object 然后其下又可分为值类型(基本数据类型)、引用类型。 值类型：整型、浮点型、字符型、布尔型、结构体、枚举 引用类型：数组、字符串、类、接口、委托 关于类型的详解将在下一节中详细讲出。 五、扩展延伸（抽象类、类）在这里我们详细讲解下类以及抽象类。同时与接口直接的区别和相同。 类-抽象类： 1、都可被继承 2、抽象类不能被实例化，只是用来继承的，普通类可以实例化 3、抽象类只含有方法声明，没有方法体。并且只能存在于抽象类中 4、继承抽象类的子类必须实现抽象方法，除非子类也是抽象类 5、抽象类中可以包含抽象方法和实例方法 接口-抽象类： 相同 1、都可被继承 2、都可以有声明不实现的方法 3、都不可被实例化 4、子类必须实现其声明的方法 不同： 1、一个类可以继承多个接口，但是仅能继承一个抽象类 2、抽象类可包含实例方法，接口不可包含 3、接口支持回调，抽象类不支持 既然有类、抽象类、接口，那么他们分别在什么时候使用呢？ 类不用说了吧，普通情况下使用即可。 抽象类–如果需要设计大的功能单元，则使用抽象类。抽象类主要用于关系密切的对象。 接口–如果设计小而简练的功能块的话可以使用接口，接口适合为不想关的类提供通用功能 举个例子：一个围栏之间有很多的小动物，猪、狗、鸡、猫。针对这个我们设计一段程序，猪、狗、鸡、猫其都是动物，根据抽象类-设计大的功能单元。我们可以设计一个动物类的抽象类。然后在各自继承下去写自己的具体类（猪类、狗类、鸡类、猫类）。那么我们要研究他们的叫声，这里设计小的功能模块。我们就可以使用接口来设计一个叫声。然后每个每个东西去实现不同的叫声（猪叫、狗叫、鸡叫、猫叫）。设计实现大的功能单元我们选择抽象类，设计实现小而简练的功能块我们选择使用接口。 总结:c#基础知识详解系列]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础类型详解下]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[前言在上一节中，我们讲到在c#中所有的类都继承一个基类–System.Object。然后其下又分为俩大类–值类型及引用类型。这一节我们详细讲解值类型和引用类型包含了那些东西及内存的分配 堆和栈在我们讲解类型前，我们得先去了解堆和栈是什么，及其区别。我们可以先知道值类型和引用类型的引用都是分配在栈中的，而引用类型的对象分配在堆中的。我们详细看看堆和栈有啥区别及其原理吧 堆（heap）–堆的分配空间是自下到上的，已占用的空间在自由空间下面，C#中引用类型的对象及分配在堆中的，内存的分配是连续的。内存对象释放是受垃圾回收机制管理的，所有在引用对象释放时会消耗更多的性能。效率相对于栈来说是较低的。 栈（stack）–栈的分配空间是自上到下的，遵循先进先出的原则，依次释放分配的内存空间。分配的内存空间是连续的，C#中的值类型及引用类型的引用都是存放在栈中的。 当一个类的实例创建对象的的时候，这个对象的不同的成员将被分配到不用的内存空间，值类型及引用类型的引用分配到栈中，引用类型对象分配到堆中，静态成员被分配到全局数据区。这个时候栈上的指针会指向堆中实际的对象，在对象使用完成后，指针和对象会切开联系，从而使对象进入冬眠期，因为栈具有自我维护性，内存管理通过操作系统完成，而堆中的冬眠对象将有垃圾回收机制进行回收，释放对象所占的内存。 值类型及引用类型值类型： 结构体：struct（直接派生于System.ValueType） 数值类型：整型、浮点型、decimal型、bool型 枚举：enum（派生于System.Enum） 引用类型： 数组：Array（派生于System.Array） 类：class（派生于System.Object） 接口：interface 委托：delegate（派生于System.Delegate） 字符串：string(System.String) 在此特别强调：.Net中所有的元素在使用前都必须初始化，在调用new创建实例的时候，编译器会隐式的调用无参构造函数进行初始化。所有的值类型的值都为0（char为’0’），所有引用类型为null。 在此可调用IsValueType来判断类型是否为值类型 1234567StringBuilder strSql = new StringBuilder(); if (strSql.GetType().IsValueType) &#123;&#125; 引用类型中尤为注意的事string类型，它具有一特效–恒定不变性，什么意思呢？也就是说string类型一旦赋值，一旦在Heap堆中分配了内存存储对象，则再也无法改变其对象的内容。我们看下面这个例子 123String a=”aaa”;a=”bbb”; 在这个例子中先是对象a创建在堆中分配内存存储’aaa’，然后又给a对象重新赋值’bbb’,其中并不是修改堆内存中对象aaa为bbb，实则是重新创建了一个堆内存对象存储’bbb’，然后把它的引用地址指向a，原来的堆内存对象’aaa’还继续保存在堆内存中，不曾修改。只有当GC垃圾回收机制处理回收，才会消失。]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
</search>
