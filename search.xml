<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NET----错误和异常处理机制]]></title>
    <url>%2F2019%2F08%2F13%2FNET----%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 错误的出现并不总是编写程序的人的原因，有时应用程序会因为应用程序的最终用户引发的动作或运行代码的环境发生错误。无论如何，我们都应预测应用程序中出现的错误，并相应的进行编码。 .Net改进了处理错误的方式。C#处理错误的机制可以为每种错误提供自定义处理方式，并把识别错误的代码与处理错误的代码分别开来。 异常类 在C#中当出现某个特殊的异常错误条件时，就会创建抛出一个异常对象，这个对象包含有助于跟踪问题的信息。.Net提供了许多预定义的异常类，我们下面看看一些常见特别的异常类吧（异常类太多了，这里就介绍几个常见的）。 对于.Net类，一般的异常类System.Exception派生自System.Object,通常不在代码中抛出System.Exception泛型对象，因为他们无法确定错误情况的本质。 ** 在该层次中有两个重要的类，他们派生自System.Exception类：** SystemException——该类用于通常由.NET允许库抛出的异常，或者由几乎所有的应用程序抛出的异常。例如，如果.NET运行库检测到栈已满，他就会抛出StackOverflowException异常。另一方面，如果检测到调用方法时参数不对，就可以在自己的代码中选择抛出ArgumentException异常或其子类。SystemException异常的子类包括表示致命错误和非致命错误的异常。 ApplicationException—-在.NET Framework最初的设计中，是打算把这个类作为自定义应用程序异常类的基类的。不过，CLR抛出的一些异常类也派生自这个类。应用程序抛出的异常则派生自SystemException。因此从ApplicationException派生自自定义异常类型没有任何好处，取而代之的是，可以直接从Exception基类派生自定义异常类。 ** 其他可能会用到的异常类包括：** StackOverflowException——-如果分配给栈的内存区域已满，就会抛出这个异常。如果一个方法连续地递归调用自己，就可能发生栈溢出。这一般是一个致命错误，因为它禁止应用程序执行除了中断以外的其他任务。在这种情况下，甚至也不可能执行到finally块。通常用户自己不能处理像这样的错误，而应退出应用程序。 EndOfStreamException——-这个异常通常是因为读到文件末尾而抛出的，流表示数据源之间的数据流。 OverflowException—–如果要在checked上下文中把包含-40的int类型数据强制转换为uint数据，就会抛出这个异常 MemberAccessException———-该类用于处理访问类的成员失败时所引发的异常。失败的原因可能的原因是没有足够的访问权限，也可能是要访问的成员根本不存在（类与类之间调用时常用） IndexOutOfException——-该类用于处理下标超出了数组长度所引发的异常 使用try…catch…finally捕获异常 try 块包含的代码组成了程序的正常操作部分，但这部分程序可能会遇到某些严重的错误。 catch块包含的代码处理各种错误，这些错误是执行try块中的代码时遇到的问题。这个快可以用来记录错误。 finally快包含的代码清理资源或执行通常要在try块或者catch块末尾执行的其他操作。无论是否抛出异常，都会执行finally块。finally块中防止return语句，编译器会标记一个错误。另外此块可以如果没有需要关闭或者处理的其他操作可以省略此块。 ** 异常处理具有性能含义，在常见的情况下，不应该使用异常处理错误。应尽量编写好避免错误出现的代码。** ** 在异常捕获中，我们可以实现多个catch块来针对不同的错误做出对应的错误处理。下面我们看一个例子：** 1234567891011121314151617181920212223242526272829class Program &#123; static void Main(string[] args) &#123; while (true) &#123; try &#123; string userInput; Console.WriteLine(&quot;请输入0-5之间任意一个数字：&quot;); userInput = Console.ReadLine(); if (string.IsNullOrWhiteSpace(userInput)) &#123; break; &#125; if (int.TryParse(userInput, out int index)) &#123; if (index &lt; 0 || index &gt; 5) &#123; throw new IndexOutOfRangeException($&quot;你输入的数字是&#123;index&#125;&quot;); &#125; Console.WriteLine($&quot;你输入的数字是&#123;index&#125;&quot;); &#125; else &#123; throw new Exception(&quot;请输入数字&quot;); &#125; &#125; catch (IndexOutOfRangeException ex) &#123; Console.WriteLine($&quot;你输入的数字不在此范围内.&#123;ex.Message&#125;&quot;); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; finally &#123; Console.WriteLine(&quot;谢谢合作&quot;); &#125; &#125; &#125; &#125; ** 在此事例中，定义了两个catch块。如果输入的超过规定返回的数字，则会抛出超出范围的错误也就进入对应的catch块。而输入的非数字也就进入了另外一个catch块进行处理。** ** 下面我们看一看关于System.Exception属性。熟悉了解其中熟悉能更好的去观察理解抛出的异常错误。** 过滤异常、创建用户定义的异常 自从C#6开始就支持异常过滤器。Catch块仅在过滤器但会true时执行。捕获不同的异常类型时，可以有行为不同的代码块。在某些情况下，catch块基于异常的内容执行不同的操作。下面我们看下如何来使用异常过滤器吧： 1234567891011121314151617181920212223public class MyIndexOutOfException :SystemException &#123; public MyIndexOutOfException(string message) : base(message) &#123; &#125; public int ErrorCode &#123; get; set; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; try &#123; int steInput = 12; if (steInput &gt; 10) &#123; throw new MyIndexOutOfException(&quot;数据超出了范围&quot;) &#123; ErrorCode = 1 &#125;; &#125; &#125; catch (MyIndexOutOfException ex) when (ex.ErrorCode!=1) &#123; Console.WriteLine(&quot;出现了自定义错误&quot;); &#125; catch (MyIndexOutOfException ex) when (ex.ErrorCode == 1) &#123; Console.WriteLine(ex.Message); &#125; catch (Exception ex) &#123; throw; &#125; &#125; &#125; ** 上面例子中，自定义了一个异常处理，同时增加ErrorCode，以此来作为过滤条件，利用关键字When+条件来进行过滤。** 总结 本篇文章介绍了异常处理错误的情况及机制，我们不仅可以输出代码好难过的一般错误代码，也可以输出我们自己定义的特殊错误情况。无论编程技术有多好，程序都必须能处理可能出现的任何错误。对不同的错误采取相应的应对措施，才是正确编码的其中一步。 ** 不是井里没有水，而是你挖的不够深。不是成功来得慢，而是你努力的不够多。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 安装部署Sql Server]]></title>
    <url>%2F2019%2F08%2F12%2FDocker%20%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Sql%20Server%2F</url>
    <content type="text"><![CDATA[前言 在如今，容器化概念越来越盛行，.Net Core项目也可以跨平台部署了，那么思考下Sql Server能不能呢？当然是可以的啦。本文今天就是介绍Docker部署配置和连接Sql Server。本文基于Centos7。 配置Docker链接Sql Server 前提条件（至少2 GB的磁盘空间。至少2 GB的RAM）。我们现在开始配置安装： ** 查询并找到Docker Hub 上Microsoft SQL Server的介绍。** 然后根据这个上docker拉取镜像 1docker pull mcr.microsoft.com/mssql/server:2017-latest 查看镜像并允许此镜像 12docker imagessudo docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;SA_PASSWORD=MyPassWord123&quot; -p 1433:1433 --name sql1 -d mcr.microsoft.com/mssql/server:2017-latest 然后查看是否允许成功 1Docker ps -a 出现下图这样既允许成功，显示UP(如果失败的话通过docker logs 容器名进行查看错误日志) 然后这里我们就配置了SQL Server，接下来我们实际进入容器内操作。 123sudo docker exec -it sql1 &quot;bash&quot;/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P &quot;MyPassWord123&quot; 然后现在就可以进行日常的数据库操作了，输入命令后执行Go结束 创建库 1CREATE DATABASE TestDB 使用库、创建表 123USE TestDBCREATE TABLE Inventory (id INT, LastName NVARCHAR(50), FirstName NVARCHAR(50)) 查询表 1Select * from Inventory 查询用户创建的表 1select name from sysobjects where type = &apos;U&apos; ** 系统表sysobjects保存的都是数据库对象,其中type表示各种对象的类型，具体包括:** ** U = 用户表** ** S = 系统表** ** C = CHECK 约束** ** D = 默认值或 DEFAULT 约束** ** F = FOREIGN KEY 约束** ** L = 日志** ** FN = 标量函数** ** IF = 内嵌表函数** ** P = 存储过程** ** PK = PRIMARY KEY 约束（类型是 K）** ** RF = 复制筛选存储过程** ** TF = 表函数** ** TR = 触发器** ** UQ = UNIQUE 约束（类型是 K）** ** V = 视图** ** X = 扩展存储过程及相关的对象信息。** 其他配置 一、更改sa的登录密码 1sudo docker exec -it sql1 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P &quot;MyPassWord123&quot; -Q &apos;ALTER LOGIN SA WITH PASSWORD=&quot;MyPassWord456&quot;&apos; 二、保留数据 将主机目录装载为数据卷 1docker run -e &apos;ACCEPT_EULA=Y&apos; -e &apos;MSSQL_SA_PASSWORD=MyPassWord456&apos; -p 1433:1433 -v /var/opt/mssql -d mcr.microsoft.com/mssql/server:2017-latest 使用数据卷容器 1docker run -e &apos;ACCEPT_EULA=Y&apos; -e &apos;MSSQL_SA_PASSWORD=MyPassWord456&apos; -p 1433:1433 -v sqlvolume:/var/opt/mssql -d mcr.microsoft.com/mssql/server:2017-latest 三、删除或退出容器 删除容器：docker rm 容器名 删除镜像：docker rmi 镜像名 退出容器;Ctrl+D 夫志当存高远，慕先贤，绝情欲，弃疑滞，使庶几之志，揭然有所存，恻然有所感；忍屈伸，去细碎，广咨问，除嫌吝，虽有淹留，何损于美趣，何患于不济。 ** 若志不强毅，意不慷慨，徒碌碌滞于俗，默默束于情，永窜伏于平庸，不免于下流矣。**]]></content>
      <categories>
        <category>基础系列</category>
        <category>Docker知识分享</category>
      </categories>
      <tags>
        <tag>.Net,Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正向代理与反向代理]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 使用Nginx做反向代理，部署负载均衡。为啥用Nginx做反向代理？反向代理是什么意思？那么又什么是正向代理呢？一连串的问题把我给整懵了。不该如何回答。现在有时间，就慢慢的解决一下这些问题吧。 正向代理及反向代理** 正向代理** 我们还是先搞清楚啥是正向代理。我们先说个简单而熟悉的事情吧，大家肯定都知道代购。代购是一个什么角色呢？处于消费者和生产者之间。更像一个纽带，一个中间商。在这里他叫”代购”，程序中可以叫他”代理”。每一个代购只针对某部分特殊的产品。然而通过代购去购买的人有是各式各样不同的人。其中原理就是我要买某某国外的化妆品，买不到，找到对应的代购，他去买了然后再给我。我们可以理解这在程序中是正向代理。 在程序当中，当我们需要访问某些网站但无法访问的时候，就比如访问国外的一些论坛，无法访问。这是我们可以再香港或者没过搭建一个服务器，然后通过搭建的服务器再去访问想要访问的网站，这就是所谓的正向代理了。（客户端-正向代理服务器-原始服务器。配合代购的例子，还是比较好理解的了。买不到某物，访问不到某网站，通过中间的代购或者服务器来达到我买到某物或者客户端访问某网站的目的，就可以说是代理了。） 比如我现在目前使用的Shadowsocks软件，就是通过配置美国那边的服务器配置来达到访问Google资源的目的，它这个工具就充当了一个正向代理的作用。 ** 反向代理** 说完正向代理再看反向代理，反向代理恰好和正向代理有点相反了。通过正向代理访问某些网站时，那些网站是不知道实际访问的客户端的，这里隐藏了真实的客户端。而反向代理，却是隐藏了真实的服务器，客户端通过反向代理去访问，并不知道访问的是哪一个服务器。 ** 这里当客户端访问服务器的时候先经过反向代理服务器，然后反向代理服务器转发请求给服务器，至于是服务器一还是服务器二还是服务器三的话，这个客户端就不知道了。客户端只要请求过来得到需要的东西就ok。这一过程也就是反向代理了。** 使用场景 上面我们详细介绍了反向代理及正向代理。那到底有什么用呢？有些地方为什么用反向代理呢？ 首先我们看正向代理，具体可以干啥： 访问原来无法访问的资源，通过Shadowsocks访问google资源 使用使用缓冲特性，可以做缓存，加速访问资源 对客户端访问授权，上网进行认证 那么反向代理呢？ 保护内网的安全，隐藏内网服务器地址，防止Web的攻击 部署负载均衡，通过反向代理部署负载均衡优化网站 Nginx反向代理 这里我们提一下Nginx，比较常见的就是使用Nginx做反向代理或者部署负载均衡。其中Nginx仅仅只是实现反向代理的工具而已，具体Nginx的安装及使用在之前的文章（Nginx安装与代理）有提过。Nginx (engine x) 是一个高性能的HTTP和反向代理服务器，Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件代理服务器。其特点是占有内存少，并发能力强。 总结 不过说实话反向代理正向代理都是其名词概念，实际上需要知道的是其内容，以及到底怎么用用来干啥的。不要每天喊着使用Nginx进行反向代理部署网站，到最后不知道啥是反向代理，啥是正向代理。这就有点小尴尬了。只有了解的更多一点才会用的更灵活一点。 振作低沉的士气，鼓舞消沉的信心，迸发澎湃的激情，舞动勤奋的双手，用努力去创造奇迹，用行动去开拓未来，精彩就一定会呈现！]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net,Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组（ArrayPool数组池、Span结构）]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%95%B0%E7%BB%84%EF%BC%88ArrayPool%E6%95%B0%E7%BB%84%E6%B1%A0_SpanT%E7%BB%93%E6%9E%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 如果需要使用相同的类型的多个对象，就可以使用集合和数组，这一节主要讲解数组，其中会重点涉及到Span结构和ArrayPool数组池。我们也会先涉及到简单的数组、多维数组、锯齿数组、Array类。 简单的数组、多维数组、锯齿数组** 简单的数组介绍** 数组的声明： 1font-family: &amp;quot;Courier New&amp;quot;; font-size: 12px; margin: 5px 8px; padding: 5px;&quot;&gt;Int [] myArray; 初始化： 1myArray=new int[4]; 还可以： 1Int [] myArray=new int []&#123;1,2,3,4&#125;; 访问数组： 1myArray[0]; ** 多维数组介绍** ** 一般的数组（也称一维数组）是用一个数字来索引，多维数组用两个或两个以上的数字进行索引。** 声明多维数组时中间以，隔开，我们下面声明一个二维数组。 12345int [,] twodim=new int [3,3] int[,] twodim = &#123; &#123; 1,2,3&#125;, &#123; 4,5,6&#125;, &#123; 7,8,9&#125; &#125;; 一个三维数组。 123456int[,,] threedim = &#123; &#123; &#123; 1,2&#125;,&#123; 3,4&#125; &#125;, &#123;&#123; 5,6&#125;,&#123; 7,8&#125; &#125;, &#123; &#123; 9,10&#125;,&#123; 11,12&#125; &#125; &#125;; Console.WriteLine(threedim[0,1,1]); ** 锯齿数组** 二维数组图形： 锯齿数组 ** 在声明锯齿数组的时候要依次放置左右括号。在初始化锯齿数组时，只对第一对方括号中设置该数组包含的行数，定义各行中元素个数的第二个方括号设为空，因为这类数组的每一行包含不同的元素个数。** int[][] jagged = new int[3][]; jagged[0] = new int[2] { 1, 2 }; jagged[1] = new int[4] { 3, 4, 5, 6 }; jagged[2] = new int[3] { 7, 8, 9 }; Array类** 创建数组：** 1234Array intArray1 = Array.CreateInstance(typeof(int), 5); for (int i = 0; i &lt; intArray1.Length; i++) &#123; intArray1.SetValue(33, i); &#125; 上面这段代码，描述了Array数组的创建以及设置值。CreateInstance**()方法第一个参数为元素的类型，第二个参数为定义数组的大小。SetValue**()方法设置值第一个参数为设置IDE值，第二个参数为设置的索引。 ** 复制数组：** 1int[] intArray1 = &#123; 1,2&#125;; int[] intArray2 = (int[])intArray1.Clone(); 因为数组是引用类型的，所以将一个数组的变量赋予另一个数组变量，就会得到两个引用同一个数组的变量，这是使用的是Clone()方法创建数组的浅表副本。使用Copy()方法也可以创建浅表副本，Clone()方法会创建一个数组，而Copy()方法必须传递阶数相同且有足够元素的已有数组。 ** 排序：** 123456789101112131415161718192021222324class Program &#123; static void Main(string[] args) &#123; int[] list = &#123; 34, 72, 13, 44, 25, 30, 10 &#125;; Console.Write(&quot;原始数组： &quot;); foreach (int i in list) &#123; Console.Write(i + &quot; &quot;); &#125; Console.WriteLine(); // 逆转数组 Array.Reverse(list); Console.Write(&quot;逆转数组： &quot;); foreach (int i in list) &#123; Console.Write(i + &quot; &quot;); &#125; Console.WriteLine(); // 排序数组 Array.Sort(list); Console.Write(&quot;排序数组： &quot;); foreach (int i in list) &#123; Console.Write(i + &quot; &quot;); &#125; Console.WriteLine(); &#125; &#125; 输出： 12原始数组： 34 72 13 44 25 30 10 逆转数组： 10 30 25 44 13 72 34 排序数组： 10 13 25 30 34 44 72` 在上述方法中Array.Sort()方法实现了数组的排序，而Array.Reverse()实现了数组的逆转 。 ArrayPool数组池** 接下来重点来了，本文的重点一，ArrayPool数组池。如果一个应用需要创建和销毁许多的数组，垃圾收集器就要花费很多的功夫来做这些工作，为了较少垃圾收集器的工作，这里我们可以使用ArrayPool类来使用数组池。ArrayPool管理一个数组池，数组可以再这里租借内存，并且返回到这里。需要引用usingSystem.Buffers;** ** 创建数组池：** 1ArrayPool&lt;int&gt; arrayPool = ArrayPool&lt;int&gt;.Create(maxArrayLength:40000, maxArraysPerBucket: 10); ** maxArrayLength的默认值是1024X10224字节（数组的长度），maxArraysPerBucket**默认值是50（数组的数量）。 ** 这里还可以使用以下方法来使用预定义的共享池。** 1ArrayPool&lt;int&gt; sharePool = ArrayPool&lt;int&gt;.Shared; ** 下面我们就一起看看如何去使用这个数组池吧：** 12345678910111213141516171819202122class Program &#123; static void Main(string[] args) &#123; //定义数组池 ArrayPool&lt;int&gt; arrayPool = ArrayPool&lt;int&gt;.Create(maxArrayLength: 10000, maxArraysPerBucket: 10); //定义使用数组的长度 int arrayLenght = 5; int[] array = arrayPool.Rent(arrayLenght); //输出数组的长度 Console.WriteLine($&quot;定义数组长度：&#123;arrayLenght&#125;，实际数组长度：&#123;array.Length&#125;&quot;); //对数组进行赋值 array[0] = 0; array[1] = 1; array[2] = 2; array[3] = 3; array[4] = 4; //输出数组的值 foreach (var item in array) &#123; Console.WriteLine(item); &#125; //将内存返回给数组池，clearArray设置True清除数组，下次调用时为空，设置False，保留数组，下次调用还是现在的值 arrayPool.Return(array, clearArray: true); foreach (var item in array) &#123; Console.WriteLine(item); &#125; &#125; &#125; 在上面事例中，我们使用Rent()方法请求池中的内存，Rent方法返回一个数组，其中至少包含所请求的元素个数。返回的数组可能会用到更多的内存，池中最少的请求为16个元素，紧接着是32,64,128以此类推。所以在上述例子中我们请求的长度为5，但是实际使用的元素个数为16个，多余的将根据类型对其赋值0或者null。 ** 我们使用Return()方法将数组返回到池中，这里使用了一个可选参数clearArray，指定是否清除该数组，不清除的话下一个从池中租用这个数组的人可以读取到其中的数据。清除数据可以避免这种情况，但是会消耗更多的CPU时间。** Span** Span介绍** 为了快速访问托管或非托管的连续内存，可以使用Spam结构。一个可以使用Span结构的例子就是数组，Span结构在后台保存在连续的内存中，另一个例子就是长字符串。 使用Span结构，可以直接访问数组元素。数组的元素没有复制，但是它们可以直接调用，并且比复制还快。 1234567class Program &#123; static void Main(string[] args) &#123; int[] arr1 = &#123; 3, 5, 7, 9, 11, 13, 15, 18, 19 &#125;; var span1 = new Span&lt;int&gt;(arr1); span1[1] = 11; Console.WriteLine(arr1[1]); &#125; &#125; 输出： 这里将创建的arr1数组传递给Span,同时Span类型提供了一个索引器，这里直接修改span1的第二个值，然后再输出arr1数组中的第二个值，也是被其修改过得值。 ** Span切片** Span它一个强大的特性是，可以使用它访问数组的部分或者切片，使用切片的时候不会复制数组元素，他们是从Span中直接访问的。下面代码介绍了创建切片的两种方法： 123456789101112131415161718class Program &#123; static void Main(string[] args) &#123; //定义简单的数组 int[] arr2 = &#123; 3, 5, 7, 9, 11, 13, 15, 18, 19, 20, 30, 40, 50, 60 &#125;; //Span&lt;T&gt;对数组进行切片，访问arr2数组，从第三个开始，取长度6个的一个数组。 var span3 = new Span&lt;int&gt;(arr2, start: 3, length: 6); //输出切片中的值 foreach (var item in span3) &#123; Console.WriteLine(item); &#125; Console.WriteLine(&quot;&quot;); Console.WriteLine(&quot;&quot;); Console.WriteLine(&quot;&quot;); //对span3进行切片处理，从第二个开始，去长度4个的一个数组 var span4 = span3.Slice(start: 2, length: 4); foreach (var item in span4) &#123; Console.WriteLine(item); &#125; &#125; &#125; ** 输出：** ** 使用Span改变值** 前面介绍了如何使用Span的索引器，更改数组的元素，下面介绍的将会有更多的选项，关于修改元素的值及复制。 123456789101112131415161718192021222324class Program &#123; static void Main(string[] args) &#123; //定义简单的数组 int[] arr = &#123; 3, 5, 7, 9, 11, 13, 15, 18, 19, 20, 30, 40, 50, 60 &#125;; //将数组传递给span var span = new Span&lt;int&gt;(arr); var span2 = new Span&lt;int&gt;(arr); //对span进行切片处理，从第四个开始 var span3 = span.Slice(start: 4 ); //调用clear方法，用0填充span3 span3.Clear(); foreach (var item in span3) &#123; Console.WriteLine(&quot;span3的值：&quot;+item); &#125; Console.WriteLine(&quot;span3的长度：&quot;+span3.Length); //创建新的切片span4，从span2开始，长度3 Span&lt;int&gt; span4 = span2.Slice(start: 3, length: 3); //调用Fill方法，用传入的值填充span4 span4.Fill(42); foreach (var item in span4) &#123; Console.WriteLine(&quot;span4的值&quot;+item); &#125; Console.WriteLine(&quot;span4的长度&quot;+span4.Length); //将span4复制给span，复制失败 span4.CopyTo(span); //将span复制给span3 复制失败 if (!span.TryCopyTo(span3)) &#123; Console.WriteLine(&quot;复制不了&quot;); &#125; &#125; &#125; 输出： 上面事例中，显示调用clear()方法，该方法用0填充Span，然后调用了Fill()方法，该方法用传递给Fill方法的值来填充Span，同时也可以将一个Span复制给另一个Span,这里先是采用的CopyTo,在这个方法中，如果另一个目标span不够大，就会复制失败，这里可以使用TryCopyTo来优化此功能，如果目标不够大，将会返回false。以此来判断是否复制成功。上面例子中span4长度为3，而span长度为14，这里是复制成功了，然后其下面的操作，因为span3的长度是10，span复制给span3失败了。因为span3不够大。 ** 上面事例中提供了改变值的一些方法，当我们不需要对值进行改变，只需要对数组进行读访问的时候，我们可以使用ReadOnlySpan。这里定义了只读的Span** 1ReadOnlySpan&lt;int&gt; readonlySpan = new ReadOnlySpan&lt;int&gt;(arr); 总结 在本篇文章中，重点介绍了ArrayPool数组池和Span结构，通过使用数组池，来降低数组创建和销毁时消耗的性能，减少垃圾回收器的工作，使用Span可以快速的访问托管及非托管代码，创建切片来对数组和长字符串进行一定的操作。更加高效的操作数组。 ** 青少年是一个美好而又是一去不可再得的时期，是将来一切光明和幸福的开端。——加里宁**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型协变与抗变（二）]]></title>
    <url>%2F2019%2F08%2F07%2F%E6%B3%9B%E5%9E%8B%E5%8D%8F%E5%8F%98%E4%B8%8E%E6%8A%97%E5%8F%98%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 在.NET 4之前，泛型接口是不变的。.NET 4通过协变和抗变为泛型接口和泛型委托添加了一个重要的扩展。协变和抗变指对参数和返回值的类型进行转换。 我们来看下到底什么是协变什么是抗变： 如果某个返回的类型可以由其基类替换，那么这个类型就是支持协变的 如果某个参数类型可以由其派生类替换，那么这个类型就是支持逆变（抗变）的。 函数的类型转换 在理解协变与抗变之前，我们看下面这个例子： 12345678class Program &#123; public static string Tmain(object o) &#123; return &quot;aaa&quot;; &#125; static void Main(string[] args) &#123; string a = &quot;aaa&quot;; object b = Tmain(a); &#125; &#125; 我们仔细看下这个传值和返回。注意其中发现了两次隐式转换。 1、向函数传值的时候 参数a从string类型转换成object类型 2、最后接收返回值的时候b由string类型转换成object类型 我们在返回函数来看。 1、 String Tmain(object o) 可以转换成string Tmain(string o) 2、 String Tmain(string o) 可以转换成 object Tmain(string o) 在这里，也就是说函数输入的时候输入类型可以从object转换成string。基类-派生类 在函数输出时，函数的输出类型（返回类型）从string转换成object。派生类-基类。 这里就比较接近泛型接口的协变和抗变的概念了。我们再看我们开头的概念 如果某个返回的类型可以由其基类替换，那么这个类型就是支持协变的 如果某个参数类型可以由其派生类替换，那么这个类型就是支持逆变（抗变）的。 理解泛型接口的协变和抗变（in、out） 我们下面来看看泛型接口的协变及抗变的例子： 首先我们看下协变，在C#高级编程（第十一版）中指出，如果泛型类型用out关键字标注，泛型接口就是协变的。这也就意味着返回类型只能是T。 123456789 /// &lt;summary&gt; /// 标识out，意味着返回类型只能是T /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; interface Itest&lt;out T&gt; &#123; T Tmain(object value); &#125; public class Test : Itest&lt;string&gt; &#123; public string Tmain(object value) &#123; return value.ToString(); &#125;&#125; 我们调用时： 12345static void Main(string[] args) &#123; Itest&lt;string&gt; itest = new Test(); Itest&lt;object&gt; itestObj = itest; &#125; 在这里，我们最后接收其返回值的时候，理应由string类型进行接收的，但是这里我们可以修改，由其基类object类型进行替换。也就是在某个返回类型可以由其基类替换的时候，也就是支持协变了。注意其关键点。返回类型、由基类替换派生类。 然后我们再看看那抗变也可称为逆变。在C#高级编程中指出的概念：如果泛型类型用in关键字标注，泛型接口就是抗变的。这样，接口只能把泛型类型T用作其方法的输入。 1234567891011121314 /// &lt;summary&gt; /// 标识in，意味着输入类型只能是T /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; interface Itest&lt;in T&gt; &#123; string Tmain(T value); &#125; public class Test : Itest&lt;object&gt; &#123; public string Tmain(object value) &#123; return value.ToString(); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Itest&lt;object&gt; itest = new Test(); Itest&lt;string&gt; itestStr= itest; &#125;&#125; 这里我们看上面这个例子，其中返回类型已经是固定的string类型了。而泛型接口中的泛型类型用来作为参数传递了。我们再看调用时，正常传入object类型的参数，，但是我们修改传入参数类型为string类型也是可以的。也就是我们在参入参数时，参数可以由其派生类替换的话，那么这个类也就是支持抗变（逆变）的。注意其中关键点。传入参数，派生类替换基类。 总结 其实在上述例子及其概念中，我们可以发现，泛型接口的协变及抗变，也就是将类型参数返回或者传入的情况，在这情况下进行其类型的隐式转换所遵循的规律。 协变：（使用关键字out）返回类型可以由其基类所替代的时候，就是支持协变的。 抗变（逆变）：（使用关键字in）传入参数类型可以由其派生类所代替的时候，就是支持抗变（逆变）的。 夫学须静也，才须学也，非学无以广才，非志无以成学——-诸葛亮]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型程序设计详解（一）]]></title>
    <url>%2F2019%2F08%2F07%2F%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 泛型是C#和.Net的一个重要概念，泛型不仅是C#编程语言中的一部分，而且与程序集中的IL(Intermediate Language)代码紧密的集成。 在平时编程过程中，常常会出现编写一些差不多的代码块，不同的仅是处理不同的数据类型。比如一个处理int数据的方法，现在新加了string类型的数据。是不是把之前的方法复制一遍，然后修改类型int为string。当然这样的方法是没有错的，那么后面又新增了其他的许多类型怎么办？还是复制修改吗？这样代码看上去很冗余，很复杂。这时候泛型就出现了。下面我们看下为何使用泛型吧。 优点 下面介绍下泛型的优点，尤其是下面几个： l 性能 l 类型安全 l 二进制代码重用 一、性能 ** 泛型的一个主要优点就是性能，在泛型集合类和非泛型集合类中，对值类型使用非泛型集合类，在把值类型转换为引用类型和把引用类型转换为值类型的时候，需要进行装箱和拆箱的操作（前面的文章中讲到了拆箱和装箱会造成一定的性能损失），当集合数据量大的时候造成的性能损失也就随之的增大了。** 使用非泛型集合时： 1234567var list = new ArrayList(); list.Add(100);//装箱 int-object int i = (int)list[0];//拆箱 object-int foreach (int item in list) &#123; Console.WriteLine(item);//遍历拆箱输出 &#125; 使用泛型集合类时： 1234567var list = new List&lt;int&gt;(); list.Add(100);//无装箱操作 int i = list[0];//无拆箱拆箱 foreach (int item in list) &#123; Console.WriteLine(item);//无拆箱操作 &#125; 减少装箱拆箱操作，节省了性能消耗。这也就是泛型的主要优点了。 二、类型安全 泛型另一个优点就是类型安全，这里我们还是使用非泛型集合类ArrayList()和泛型集合类List来做案例。 非泛型集合类ArrayList(): 1234567var list = new ArrayList(); list.Add(100);// 添加一个int类型 list.Add(&quot;string&quot;);//添加一个string类型 foreach (int item in list) &#123; Console.WriteLine(item);//遍历循环输出&#125; 这里允许输出和抛出异常： 1System.InvalidCastException:“Unable to cast object of type &apos;System.String&apos; to type &apos;System.Int32&apos;.” 无法强制把”string”转换成int类型。 我们再看泛型集合类： list 1234list.Add(100);// 添加一个int类型 list.Add(&quot;string&quot;);//添加一个string类型,编译器报错，无法从string转换到intforeach (int item in list)&#123; Console.WriteLine(item);//遍历循环输出 &#125; 在添加”string”类型的时候编译器报错，无法添加。这里也就杜绝了后续的错误。这也就是保证了类型的安全。 三、二进制代码重用 泛型允许更好的重用二进制代码，泛型类型可以定义一次，并且可以再许多不同的类型实例化，相比C++来说，不用每次访问源代码。 例如上面使用的泛型集合类，using System.Collections.Generic; 中的List类，可以用int，string，自定义类去实例化。 泛型类型还可以在一种语言定义，然后再其他任何.Net语言中使用。 泛型类的功能 这里我们可以来了解下创建泛型类了之后，泛型类有哪些功能呢？ l 默认值 l 约束 l 继承 l 静态成员 一、默认值 在我们定义了泛型类型之后如何赋值呢？ 123456public class Tclass&lt;T&gt; &#123; public static T Get() &#123; T a = default; return a; &#125; &#125; 因为在泛型中初始给值不好给，你说给null吧，null是给引用类型的，你是给0吧，这又是给值类型的，这时候出现了default，当时引用类型调用时就给null，当时值类型时就0。 二、约束 说到泛型类型的约束时，不得不提关键字where，where是用来限制参数的范围的，如果不符合where条件指定的参数范围，编译是不允许通过的。 这里泛型类型的约束主要可以分为以下6中 l Where T: class（类型参数必须是引用类型） l Where T:struct（类型参数必须是值类型） 1234public class Tclass&lt;T,U&gt; where T:class //类型参数为引用类型 where U:struct //类型参数为值类型 &#123;&#125; l Where T：&lt;接口名称&gt;（类型参数必须是指定的接口或者实现指定的接口） 1234567891011121314/// &lt;summary&gt; /// 接口 /// &lt;/summary&gt; interface Itest &#123; &#125; /// &lt;summary&gt; /// 定义一个字典类型 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;TK&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TV&quot;&gt;&lt;/typeparam&gt; class Dictionary&lt;TK, TV&gt; where TK : IComparable, IEnumerable where TV : Itest &#123; public void Add(TK key, TV val) &#123; &#125; &#125; l Where T:&lt;基类名&gt;（参数必须是指定的基类或者是派生自指定的基类） 1234class Ttest &#123; &#125; class Tclass&lt;T&gt; where T:Ttest &#123; &#125; l Where T:new ()（这是一个构造函数的约束，指定参数类型必须有一个默认构造函数，当与其他约束一起使用时必须放在其最后） 123 class EmployeeList&lt;T&gt; where T : Employee, IEmployee, System.IComparable&lt;T&gt;, new() &#123; // ... &#125; l Where T1:T2（这个约束指定类型T1派生自泛型类型T2，也就是说T1的参数类型要和T2一样） public class Tclass where T:IComparable { } 三、继承 泛型类型的继承与普通类的继承相似但不同。 12345678910/// &lt;summary&gt; /// 抽象基类，泛型类型 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; public abstract class Ttest&lt;T&gt; &#123; public abstract T Add(T x, T y); &#125; /// &lt;summary&gt; /// 继承抽象基类，实现int类型 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; class Tclass&lt;T&gt; : Ttest&lt;int&gt; &#123; public override int Add(int x, int y) =&gt; x + y; &#125; 四、静态成员 泛型类型的静态成员需要特殊的关注，泛型类的静态成员只能在类的一个实例中共享。 12345678910111213/// &lt;summary&gt; /// 泛型类型，静态字段x /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; public class Ttest&lt;T&gt; &#123; public static int x; &#125; class Program &#123; static void Main(string[] args) &#123; Ttest&lt;string&gt;.x = 111; Ttest&lt;int&gt;.x = 222; Console.WriteLine(Ttest&lt;string&gt;.x); &#125; &#125; 上面事例中最后输出的为111， 总结 这里我们主要是介绍了泛型的优点及泛型类型的功能。在我们日常的编程中会发现很多地方可以使用泛型。提高代码的扩展性及重用性。同时也可以减少对object类型的使用，采用泛型类型的使用来替代。较少对性能的消耗。我们下一节主要是对泛型类型的协变及抗变进行一定的理解。 只要认为是对的就去做，坚持去做，不要在乎别人的看法，哪怕是错，至少你有去做过证明曾经你努力过。]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象三大特效————封装、继承、多态]]></title>
    <url>%2F2019%2F08%2F07%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7-----%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[前言 前面有文章写到了面向对象编程和面向对象设计的头五大原则(SOLID五大原则)。今天我们再来谈谈面向对象的三大特性–封装、继承、多态 封装 被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中”。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。**封装只公开某些对外接口，隐藏具体实现细节。增加了一定的安全性，防止信息的泄露以及破坏。** 讲到封装，我们又得提下访问修饰符了。 public：所有对象都可以访问； private：对象本身在对象内部可以访问； protected：只有该类对象及其子类对象可以访问 internal：同一个程序集的对象可以访问； protected internal：访问限于当前程序集或派生自包含类的类型。 继承** 继承是软件复用的一种形式。使用继承可以复用现有类的数据和行为，为其赋予新功能而创建出新类。** ** 在现有类（基类、父类）上建立新类（派生类、子类）的处理过程称为继承。派生类能自动获得基类的除了构造函数和析构函数以外的所有成员，可以在派生类中添加新的属性和方法扩展其功能。** ** 这里继承又可分为以下系列：** 单重继承：表示一个类可以派生自一个基类，C#采用此继承 多重继承：多重继承允许一个类派生自多个类，C#不支持多重继承，但允许接口的多重继承 多层继承：多层继承允许有更大的层此结构，类B派生自类A，类C派生自类B，其中，类B也称为中间基类，C#支持它，也很常用。 接口继承：允许接口多重继承 多态** 多态指在程序设计中存在同名不同方法的存在，主要通过子类对父类的覆盖来实现多态，设计原则之一就是要依赖于抽象，而不依赖于具体，增加灵活性。多态就是为了体现这一原则。** 实例讲解 这里我们假设一个场景，对图形的面积进行计算。在这里我们就抽象一个基类，形状。然后其他的设计都来继承它。 ** 类设计** 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt; /// 抽象类 /// &lt;/summary&gt; public abstract class Shape &#123; private string ShapeName &#123; get; set; &#125; public Shape(string shapeName) &#123; this.ShapeName = shapeName; &#125; /// &lt;summary&gt; /// 计算面积 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public abstract double CalculateArea(); &#125; /// &lt;summary&gt; /// 长方形 /// &lt;/summary&gt; public class Rectangle:Shape &#123; /// &lt;summary&gt; /// 长 /// &lt;/summary&gt; public double Longm &#123; get; set; &#125; /// &lt;summary&gt; /// 宽 /// &lt;/summary&gt; public double Widem &#123; get; set; &#125; public Rectangle():base(&quot;Rectangle&quot;) &#123; Longm = 0; Widem=0; &#125; public override double CalculateArea() &#123; return Longm * Widem; &#125; &#125; /// &lt;summary&gt; /// 圆形 /// &lt;/summary&gt; public class Circle: Shape &#123; /// &lt;summary&gt; /// 半径 /// &lt;/summary&gt; public double R &#123; get; set; &#125; public Circle(): base(&quot;Circle &quot;) &#123; R = 0; &#125; public override double CalculateArea() &#123; return Math.PI*R*R; &#125; &#125; 调用 12345678910111213141516171819202122232425262728293031class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;请选择计算面积的图形：长方形（A）/圆形（B）&quot;); string answer = Console.ReadLine(); if (answer==&quot;A&quot;) &#123; double longm=0; double widem = 0; try &#123; Console.WriteLine(&quot;请输入长：&quot;); longm = double.Parse(Console.ReadLine()); Console.WriteLine(&quot;请输入宽：&quot;); widem = double.Parse(Console.ReadLine()); &#125; catch (Exception) &#123; Console.WriteLine(&quot;请输入数字!&quot;); &#125; Rectangle rectangle = new Rectangle(); rectangle.Longm = longm; rectangle.Widem = widem; Console.WriteLine($&quot;此长方形的面积是&#123;rectangle.CalculateArea()&#125;&quot;); &#125; else &#123; double r=0; try &#123; Console.WriteLine(&quot;请输入半径：&quot;); r = int.Parse(Console.ReadLine()); &#125; catch (Exception) &#123; Console.WriteLine(&quot;请输入数字!&quot;); &#125; Circle circle = new Circle(); circle.R = r; Console.WriteLine($&quot;此圆形的面积是&#123;circle.CalculateArea()&#125;&quot;); &#125; &#125; &#125; 总结 本个案例实际作用不是很大，主要是方便讲解理解封装继承多态，在实例中，对图形的名称封装，抽象一个抽象类图形基类，圆形和长方形继承此基类。override 重写实现面积计算的多态。更多的还是需要在实际项目中实际运用的。 ** 再长的路，一步步也能走完，再短的路，不迈开双脚也无法到达。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托与事件-委托详解（三）]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6-%E5%A7%94%E6%89%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 这两天一直在想如何结合实际案例来结束委托与事件的讲解，下面讲解两个事例，用来加深对委托及事件的理解。 事例一（分页功能） 本场景是用来讲解使用的，具体内容功能需自行填补实现。用委托加事件来实现分页功能的通用。按上一节讲解中的逻辑处理，分为订阅者和发布者，一样的可以先定义订阅者感兴趣的对象，然后发布者，订阅者。再就是主程序调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 /// &lt;summary&gt; /// 首先定义订阅者感兴趣的对象，本例感兴趣的是上一页下一页等方法。这里使用Action抽象 /// &lt;/summary&gt; public class PageChangeEventArgs : EventArgs &#123; public string Action &#123; get; set; &#125; public int PageIndex &#123; get; set; &#125; public PageChangeEventArgs() &#123; &#125; public PageChangeEventArgs(string action, int pageIndex) &#123; this.Action = action; this.PageIndex = pageIndex; &#125; &#125; /// &lt;summary&gt; /// 定义发布者 /// &lt;/summary&gt; public class PageActionPubliser &#123; //定义委托 public delegate void PageActionEventHandler(object sender, PageChangeEventArgs e); //定义委托类型的事件 public event PageActionEventHandler PageAction; //定义保护方法判断委托事件是否为空,传入参数e类型为EventArgs protected void OnPageAction(PageChangeEventArgs e) &#123; if (PageAction != null) &#123; PageAction(this, e); &#125; //PageAction?.Invoke(this, e);也可这样写&#125; //编写触发事件、上一页 public void PreviousClick( PageChangeEventArgs e) &#123; OnPageAction(new PageChangeEventArgs(&quot;Previous&quot;,e.PageIndex)); &#125; //下一页 public void NextClick( PageChangeEventArgs e) &#123; OnPageAction(new PageChangeEventArgs(&quot;Next&quot;,e.PageIndex)); &#125; &#125; /// &lt;summary&gt; /// 定义订阅者 /// &lt;/summary&gt; public class Recevice &#123; /// &lt;summary&gt; /// 具体分页内容的实现，订阅者 /// &lt;/summary&gt; public static void BindPage(object sender, PageChangeEventArgs e) &#123; //假设最大页数为10 int MaxIndex = 10; if (e.PageIndex == 0 &amp;&amp; e.Action == &quot;Previous&quot;) &#123; //当前0页，不能上一页&#125; if (e.PageIndex == MaxIndex - 1 &amp;&amp; e.Action == &quot;Next&quot;) &#123; //已是最后一页，不能下一页&#125; switch (e.Action) &#123; case &quot;Previous&quot;: e.PageIndex--; break; default: e.PageIndex++; break; &#125; Console.WriteLine($&quot;已跳转到第&#123;e.PageIndex&#125;页&quot;); &#125; &#125; /// &lt;summary&gt; /// 这里使用的是控制台应用程序进行模拟 /// &lt;/summary&gt; /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt; class Program &#123; static void Main(string[] args) &#123; //绑定注册事件 PageActionPubliser pageActionPubliser = new PageActionPubliser(); pageActionPubliser.PageAction += Recevice.BindPage; Console.WriteLine(&quot;请选择上一页或者下一页：上一页(A)/下一页（B）&quot;); string answer=Console.ReadLine(); PageChangeEventArgs pageChangeEventArgs = new PageChangeEventArgs(); //假设当前页为5 pageChangeEventArgs.PageIndex = 5; if (answer==&quot;A&quot;) &#123; pageActionPubliser.PreviousClick(pageChangeEventArgs); &#125; else &#123; pageActionPubliser.NextClick(pageChangeEventArgs); &#125; &#125; &#125; 在这里委托加事件的分页功能实现完成了。其实原理很简单的，当点击上一页或者下一页的时候，这时候因为因为已经绑定注册了这个事件。 它就会具体执行其中的操作。还是要具体去实践编写操作调试一下，就很快知道它的执行顺序、也能很快的掌握的。 事例二（新车到达提醒） 这个案例，简要的表述就是在车库中新到达了车辆时会对管理者发送通知。首先我们也先分析下。订阅者是管理者。订阅者感兴趣的对象是啥呢？感兴趣的对象是有没有新车达到。 然后，我们开始这个的一个设计。 123456789101112131415161718192021222324252627282930313233343536373839 /// &lt;summary&gt; /// 定义订阅者感兴趣的对象 /// &lt;/summary&gt; public class NewCarsEventArgs : EventArgs &#123; public string NewCardName &#123; get; set; &#125; public NewCarsEventArgs() &#123; &#125; public NewCarsEventArgs(string newCardName) &#123; this.NewCardName = newCardName; &#125; &#125; /// &lt;summary&gt; /// 定义发布者 /// &lt;/summary&gt; public class NewCarsPublisher &#123; public delegate void CarsEventHandler(object sender ,NewCarsEventArgs e); public event CarsEventHandler Cars; private void OnCars(NewCarsEventArgs e) &#123; if (Cars!=null) &#123; Cars(this,e); &#125; &#125; public void NewCarsArrivals(NewCarsEventArgs e) &#123; OnCars(e); &#125; &#125; public class NewCarsRecevie &#123; public static void Manager(object sender,NewCarsEventArgs e) &#123; Console.WriteLine($&quot;通知：新车&#123;e.NewCardName&#125;到了!&quot;); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; NewCarsPublisher newCarsPublisher = new NewCarsPublisher(); newCarsPublisher.Cars += NewCarsRecevie.Manager; Console.WriteLine(&quot;请输入到达车辆的名称：&quot;); string name=Console.ReadLine(); Console.WriteLine(&quot;到达车辆是否是新车（Y/N）：&quot;); string answer = Console.ReadLine(); if (answer==&quot;Y&quot;) &#123; NewCarsEventArgs newCarsEventArgs = new NewCarsEventArgs() &#123; NewCardName=name&#125;; newCarsPublisher.NewCarsArrivals(newCarsEventArgs); &#125; else &#123; Console.WriteLine(&quot;不是新车不对订阅者发送通知!&quot;); &#125; &#125;&#125; 谨记，事件基于委托，为委托提供了一种发布/订阅机制。理解发布订阅机制就会容易多了。一旦理清楚，发现好像也并不是很难的。多多消化一下，自己动手去想一下实例。去写一下。很快能掌握的。 总结 委托与事件到这里就大结局了。一些列的问题也解决了。心中的疑惑也揭开了。下面我们就接着基础系列写其他的了。 ** 再长的路，一步步也能走完，再短的路，不迈开双脚也无法到达。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托与事件-委托详解（二）]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6-%E5%A7%94%E6%89%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 上一节我们了解学习了委托，委托是类型安全的类，它定义了返回类型和参数的类型。委托类不仅包含对方法的引用，也可以包含对多个方法的引用。 理解委托的一种好的方式是把委托视为是给方法的签名和返回类型指定名称。 今天我们继续来了解委托和事件，现在我们来了解学习一下事件详解。 事件 事件基于委托，为委托提供了一种发布/订阅机制，在.Net中随处可见到这种事件，例如在应用程序中，Button类提供了Click事件，这类事件就是委托。 既然事件是为委托提供了发布/订阅机制，那么肯定设计到两个角色，发布者以及订阅者。 ** 事件发布者（Publisher）–事件的发布者就是一个对象，这个对象维护自身的状态信息，一旦自身的状态信息发生了改变，那么便触发一个事件** ** 事件订阅者（Subscriber）–对事件感兴趣的对象，也可以叫做Receiver，可以注册感兴趣的事件，在触发一个事件后自动执行这段代码。** ** 到底事件的一个怎么运行过程呢？在介绍此过程中我们先看下委托与事件的微软编码规范吧。** 一、上一节讲了委托的命名需以EventHandler结束 ** 二、委托原型的定义是一个void返回值而且有两个参数，一个object类型，一个EventArgs类型（或者继承此类型的）** ** 三、事件的命令是委托去掉后缀EventHandler** ** 四、继承了EventArgs需以EventArgs结尾** ** 下面我们一起来看一个简单的委托与事件案例** 委托与事件简单实例讲解 假设现在电信公司提供一个话费流量查询的功能，但是其中小明仅关心流量，小红仅关心话费，小李关心话费和流量。现在设计一段他们查询流量和话费的功能。 分析下，他们关心感兴趣的是流量多少，话费多少。–订阅者 输入查询触发事件，反馈流量多少，话费多少。–发布者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 /// &lt;summary&gt; /// 所有订阅者（Subscriber）感兴趣的对象，本列中订阅者感兴趣的对象是流量话费及多少 /// &lt;/summary&gt; public class PubEventArgs : EventArgs &#123; /// &lt;summary&gt; /// 话费或者流量具体值 /// &lt;/summary&gt; public readonly string mobleType; public PubEventArgs() &#123; &#125; public PubEventArgs(string mobleType) &#123; this.mobleType = mobleType; &#125; &#125; /// &lt;summary&gt; /// 发布者（publiser） /// &lt;/summary&gt; public class Publiser &#123; //先定义委托 public delegate void PublishEventHandler(object sender,PubEventArgs e); /// &lt;summary&gt; /// 定义事件，命名为委托去除EventHandler /// &lt;/summary&gt; public event PublishEventHandler Publish; /// &lt;summary&gt; /// 执行函数 /// &lt;/summary&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; public void OnPublish(PubEventArgs e) &#123; if (Publish!=null) &#123; this.Publish(this,e); &#125; &#125; /// &lt;summary&gt; /// 事件的触发 /// &lt;/summary&gt; /// &lt;param name=&quot;mobleType&quot;&gt;&lt;/param&gt; public void Use( string mobleType) &#123; OnPublish(new PubEventArgs(mobleType)); &#125; &#125; /// &lt;summary&gt; /// 订阅者（Subscriber）小明 /// &lt;/summary&gt; public class XiaoMing &#123; public static void Receive(object sender, PubEventArgs e) &#123; Console.WriteLine($&quot;您的&#123;e.mobleType&#125;剩余100G&quot;); &#125; &#125; public class XiaoHong &#123; public static void Receive(object sender,PubEventArgs e) &#123; Console.WriteLine($&quot;您的&#123;e.mobleType&#125;余额为100元&quot;); &#125; &#125; public class XiaoLi &#123; public static void Receive(object sender, PubEventArgs e) &#123; Console.WriteLine($&quot;您的流量剩余100G,您的话费余额为100元&quot;); &#125; &#125; /// &lt;summary&gt; /// 小明订阅了流量 小红订阅了话费 小李订阅了话费流量。分别查询自己所订阅的,主流程编写 /// &lt;/summary&gt; class Program &#123; static void Main(string[] args) &#123; //实例化一个发布者 Publiser publiser = new Publiser(); Console.WriteLine(&quot;请输入您需要查询的业务：&quot;); string mobleType=Console.ReadLine(); if (mobleType==&quot;流量&quot;) &#123; //事件注册 publiser.Publish += XiaoMing.Receive; &#125; else if (mobleType==&quot;话费&quot;) &#123; publiser.Publish += XiaoHong.Receive; &#125; else &#123; publiser.Publish += XiaoLi.Receive; &#125; //调用触发事件publiser.Use(mobleType); &#125; &#125; 在Main函数中，进行一个事件的注册，例如小明，进来Main函数，实例化一个发布者，在发布者中绑定了小明的订阅事件，然后调用发布者触发事件的方法。 发布者： 一、声明一个委托 二、基于委托声明一个事件 三、一个判断事件是否为空，然后开始执行处理事件 四、一个调用用来触发事件的方法 1234567//先定义委托 public delegate void PublishEventHandler(object sender,PubEventArgs e); /// &lt;summary&gt; /// 定义事件，命名为委托去除EventHandler /// &lt;/summary&gt; public event PublishEventHandler Publish; //事件注册 publiser.Publish += XiaoMing.Receive; 订阅者： 感兴趣的事件，最后的输出。 订阅者感兴趣的对象： 用来保存处理订阅者感兴趣的对象。 总结 我们仔细考虑下这整个委托与事件，事件的本质也就是对委托的一种使用。看我们事件注册绑定和多播委托的用法是一样的，事件的声明也是使用的委托类。 大家好好想想其中的奥妙，然后理解消化下。其实它们也没有那么难的。 下一节我们对委托和事件进行深入解析外加实际案例。 ** 再长的路，一步步也能走完，再短的路，不迈开双脚也无法到达。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托与事件-委托详解（一）]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6-%E5%A7%94%E6%89%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 说起委托和事件，我就想起了再学校的时候，当时死记硬背去记什么是委托什么是事件。记得当时蝼某人问我，委托是什么？但是只知道一点点，就跟他说:打个比方，我要喝水，但是我不去买，我委托你去帮我买水。这就是委托，够直白简单了吧。 委托语法使用** 语法： public delegate void BuyWater EventHandler();** ** 其中 delegate 是关键字，声明委托的时候命名时后缀加入 EventHandle** 这就是一个简单的委托，就是这么简单。我们相对于平时使用的方法有什么区别吧 ** 方法：** 123public static string BuyWaterSlef() &#123; return &quot;自己去买水&quot;; &#125; 我们看方法，是实现买水这个功能的，而委托是委托你去帮我买水的。方法是具体做事实现功能，委托只是命令而已。 我们具体使用委托来实现刚刚那个委托蝼某人去买水的程序设计。 12345678910111213141516171819202122232425/// &lt;summary&gt; /// 蝼某人去买水的类 /// &lt;/summary&gt; public class LouBuy &#123; /// &lt;summary&gt; /// 蝼某人买水的方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string LouBuyWater() &#123; return &quot;蝼某人去买水&quot;; &#125; &#125; /// &lt;summary&gt; /// 定义买水的委托 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public delegate string BuyWater(); /// &lt;summary&gt; /// 买水委托实现的类 /// &lt;/summary&gt; public class MainBuy &#123; /// &lt;summary&gt; /// 实现委托 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string BuyFun() &#123; /// 委托中加入蝼某人的方法 BuyWater buyWater = new BuyWater(LouBuy.LouBuyWater); ///返回结果 return buyWater(); &#125; &#125; 最后这里输出的是”蝼某人去买水” ** BuyWater buyWater = new BuyWater(LouBuy.LouBuyWater);** ** 这里声明委托方法， BuyWater 委托中加入 LouBuy.LouBuyWater 买水的方法，**这个方法参数必须加入，因为委托的构造函数参数不为空。同时需要注意委托参数的返回类型都是要和具体委托方法一样的。 ** 在这个例子中都是返回的string，都是无参数的** 委托链（多播委托） 上面我们简单的介绍了下委托及其用法，这里我们可以了解一下委托链，顾名思义，委托链也就是委托连续，啥意思呢？继续上面的例子，我委托蝼某人去买水，然后顺带买包辣条。 123456789101112131415161718192021222324252627282930313233 /// &lt;summary&gt; /// 蝼某人去买水的类 /// &lt;/summary&gt; public class LouBuy &#123; /// &lt;summary&gt; /// 蝼某人买水的方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static void LouBuyWater() &#123; Console.WriteLine (&quot;蝼某人去买水&quot;;) &#125; /// &lt;summary&gt; /// 楼某人买辣条方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static void LouBuyLT() &#123; Console.WriteLine (&quot;楼某人又买了辣条&quot;;) &#125; &#125; /// &lt;summary&gt; /// 定义买水的委托 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public delegate void BuyWater(); /// &lt;summary&gt; /// 买水委托实现的类 /// &lt;/summary&gt; public class MainBuy &#123; /// &lt;summary&gt; /// 实现委托 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static void BuyFun() &#123; /// 委托中加入蝼某人的方法 BuyWater buyWater = new BuyWater(LouBuy.LouBuyWater); buyWater += LouBuy.LouBuyLT; ///返回结果Console.WriteLine (buyWater();) &#125; &#125; 这里就相当于我委托蝼某人做了两件事情，先去买水然后顺带买了辣条，委托链（多播委托）可以使用+=来增加委托中调用的方法，同理也可使用-=来删除委托中调用的方法. ** 注意，委托链（多播委托）–委托的签名必须返回void，否则就只能得到委托调用的最后一个方法的结果。同时委托链（多播委托）中注意不要调用一些必须有特定顺序的方法，因为委托中调用其方法链的顺序并未正式定义。** ** 委托链（多播委托）还可能出现一个非常严重的问题，也就是在委托中多个方法调用时，一旦出现了异常报错，则整个迭代都会停止。** 123456789101112131415161718192021class Pragram &#123; static void One() &#123; Console.WriteLine(&quot;one&quot;); throw new Exception(&quot;抛出异常报错&quot;); &#125; static void Two() &#123; Console.WriteLine(&quot;two&quot;); &#125; public delegate void ActionMain(); static void Main() &#123; ActionMain actionMain = One; actionMain += Two; try &#123; actionMain(); &#125; catch (Exception) &#123; Console.WriteLine(&quot;异常报错&quot;); &#125; &#125; &#125; 123456789101112131415161718192021class Pragram &#123; static void One() &#123; Console.WriteLine(&quot;one&quot;); throw new Exception(&quot;抛出异常报错&quot;); &#125; static void Two() &#123; Console.WriteLine(&quot;two&quot;); &#125; public delegate void ActionMain(); static void Main() &#123; ActionMain actionMain = One; actionMain += Two; try &#123; actionMain(); &#125; catch (Exception) &#123; Console.WriteLine(&quot;异常报错&quot;); &#125; &#125; &#125; 123456789101112131415161718192021class Pragram &#123; static void One() &#123; Console.WriteLine(&quot;one&quot;); throw new Exception(&quot;抛出异常报错&quot;); &#125; static void Two() &#123; Console.WriteLine(&quot;two&quot;); &#125; public delegate void ActionMain(); static void Main() &#123; ActionMain actionMain = One; actionMain += Two; try &#123; actionMain(); &#125; catch (Exception) &#123; Console.WriteLine(&quot;异常报错&quot;); &#125; &#125; &#125; 123456789101112131415161718192021class Pragram&#123; static void One() &#123; Console.WriteLine(&quot;one&quot;); throw new Exception(&quot;抛出异常报错&quot;); &#125; static void Two() &#123; Console.WriteLine(&quot;two&quot;); &#125; public delegate void ActionMain(); static void Main() &#123; ActionMain actionMain = One; actionMain += Two; try &#123; actionMain(); &#125; catch (Exception) &#123; Console.WriteLine(&quot;异常报错&quot;); &#125; &#125;&#125; 123456789101112131415161718192021class Pragram &#123; static void One() &#123; Console.WriteLine(&quot;one&quot;); throw new Exception(&quot;抛出异常报错&quot;); &#125; static void Two() &#123; Console.WriteLine(&quot;two&quot;); &#125; public delegate void ActionMain(); static void Main() &#123; ActionMain actionMain = One; actionMain += Two; try &#123; actionMain(); &#125; catch (Exception) &#123; Console.WriteLine(&quot;异常报错&quot;); &#125; &#125; &#125; 在这个委托调用中，遇到抛出异常错误时就会停止迭代。最终返回结果为 123one抛出异常报错 扩展延伸一、解决多播委托问题 上面讲到多播委托中一个调用抛出异常，整个迭代都会停止。下面讲解一个解决此问题的方法。在Delegate类中定义了GetInvocationList()方法，它返回的是Delegate对象数组，现在可以使用这个委托调用与委托直接相关的方法，捕获异常，并继续下一次迭代。 1234567891011121314151617181920212223class Pragram &#123; static void One() &#123; Console.WriteLine(&quot;one&quot;); throw new Exception(&quot;抛出异常报错&quot;); &#125; static void Two() &#123; Console.WriteLine(&quot;two&quot;); &#125; public delegate void ActionMain(); static void Main() &#123; ActionMain actionMain = One; actionMain += Two; Delegate[] delegates = actionMain.GetInvocationList(); foreach (ActionMain item in delegates) &#123; try &#123; item(); &#125; catch (Exception) &#123; Console.WriteLine(&quot;抛出异常&quot;); &#125; &#125; &#125; &#125; 再看我们对出现问题的代码进行修改，这里抛出异常之后会继续迭代，并不会停止，返回的结果是 12345one抛出异常错误Two 二、委托其他写法（Action委托和Fun委托） 我们上面介绍到委托 123public delegate void BuyWater(string a);BuyWater buyWater = new BuyWater(LouBuy.LouBuyWater); 下面我们介绍另外两种委托形式，Action委托和Fun委托 ** Action委托表示引用一个void返回类型的方法，可以没有参数，也可以有很多参数,一个参数Action,l两个参数Action&lt;in T1,in T2&gt;** 1Action&lt;string&gt; action=LouBuy.LouBuyWater; ** Fun委托表示可以调用允许带返回类型的参数，Fun表示委托类型可以调用带返回类型且无参数的方法，Fun&lt;in T,out TResult&gt;调用带返回类型带参数的方法** 1Func&lt;string, string&gt; buyWater = LouBuy.LouBuyWater;//表示返回string类型，参数也是string类型的一个方法 总结 以前总在说委托与事件，都没有一次去了解熟悉它，现在得好好巩固一下了。到这里就介绍完了委托，看上去也挺简单的。我们下一节继续看Event事件。然后结合委托一起看看委托加事件如何运用的。 ** 再长的路，一步步也能走完，再短的路，不迈开双脚也无法到达。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Net集合详解]]></title>
    <url>%2F2019%2F08%2F02%2FNet%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言 前面几篇文章讲了泛型、讲了数组，都有提到集合，这一节重点对集合进行详细解说。本文主要使用各种集合类型。以至于评估其性能，针对不同的场景选择不同的集合使用。 集合分类详解一、列表** 列表的创建** 1var intList=new List&lt;int&gt;(); ** 创建一个容量为10 的集合** 1List&lt;int&gt; intList=new List&lt;int&gt;(10); ** 列表初始值设定项** 1var intList = new List&lt;int&gt;() &#123; 1,2&#125;; ** 添加元素(通过使用Add方法进行元素添加)** 12345var intList=new List&lt;int&gt;();inList.Add(1); var intList = new List&lt;int&gt;();intList.AddRange(new List&lt;int&gt;()&#123; 1,2,3&#125;); ** 插入元素(使用insert方法插入元素)** 12345var intList = new List&lt;int&gt;();intList.Insert(3, 3); var intList = new List&lt;int&gt;();intList.InsertRange(3, new List&lt;int&gt;() &#123; 1,2,3&#125;); ** 访问元素(通过下表去实现访问或者循环遍历)** 123456789var intList = new List&lt;int&gt;(); intList.AddRange( new List&lt;int&gt;() &#123; 1,2,3&#125;); var answer = intList[2]; foreach (var item in intList) &#123; Console.WriteLine(item); &#125; ** 删除元素(通过RemoveAt指定删除某一位置的值)** 12345var intList = new List&lt;int&gt;();intList.AddRange( new List&lt;int&gt;() &#123; 1,2,3,4&#125;);intList.RemoveAt(3); ** 搜索(通过IndexOf访问指定位置的值，可以使用的方法IndexOf()、LastIndexOf()、FindLastIndex()、Find()、FindLast())** 123var intList = new List&lt;int&gt;();intList.AddRange( new List&lt;int&gt;() &#123; 1,2,3,4&#125;); int indenx = intList.IndexOf(3); 二、队列 队列是其元素以先进先出（FirstIn，FirstOut，FIFO）的方式来处理的集合，先放入队列中的元素会先读取。队列的例子比比皆是。排队买票，食堂排队打饭，先到先买，先到先打饭。 队列使用System.Collections.Generic命名空间中的泛型类Queue来实现的。这个类型类似于List。队列类使用Enqueue()方法在队列的一段插入元素，使用Dequeue()方法在另一端读取元素并删除。 12345Queue&lt;string&gt; qa = new Queue&lt;string&gt;(); qa.Enqueue(&quot;第一个进&quot;);qa.Dequeue(); 其中使用Count()返回队列中的元素总数，使用Peek()方法从队列头部读取一个元素，但不删除它。使用TrimExcess()方法重新设置队列的容量，Dequeue()虽然删除了元素，但不会重新设置容量。要从队列头部去除空元素，应使用TrimExcess()方法 三、栈 栈是与队列非常相似的另一个容器，知识使用不同的方法访问栈，而且栈的元素属于最后添加的元素最先读取也就是后进先出（LastIn,FirstOut,LIFO）。 与Queue类似，栈使用Stack来实现，其中Push()在栈中添加元素，用Pop()方法获取最近添加的元素。 12345Stack&lt;string&gt; qa = new Stack&lt;string&gt;();qa.Push(&quot;第一个进&quot;);qa.Pop(); 其中其他方法与Queue类似，使用Count()返回队列中的元素总数，使用Peek()方法从队列头部读取一个元素，但不删除它。使用Contains()确定某个元素是否存在于栈中，存在则返回True 四、有序列表 如果需要基于键对所需的集合进行排序，就可以使用SortedList&lt;TKey,TValue&gt;类。这个类按照键给的元素排序，这个集合中的值和键都可以使用任意类型。 下面先创建一个空列表，然后通过Add()方法进行添加元素。然后输出结果。我们看下图可以发现自动帮我们已经排序好了然后输出的。 1234567891011121314151617static void Main(string[] args) &#123; var test = new SortedList&lt;string, string&gt;(); test.Add(&quot;First&quot;,&quot;Code1&quot;); test.Add(&quot;Two&quot;, &quot;Code2&quot;); test.Add(&quot;A&quot;, &quot;Code3&quot;); foreach (var item in test) &#123; Console.WriteLine(item.Key+&quot;:&quot;+ item.Value); &#125; &#125; 五、字典 字典表示一种复杂的数据结构，这种数据结构允许按照某个键来访问元素。字典也称为映射或散列表。字典的主要特性是能根据键快速查找值。也可以自由添加和删除元素，这有点像List，但没有在内存中移动后续元素的性能开销。 字典的初始化： 1var dict = new Dictionary&lt;int, string&gt;() &#123; &#123;1,&quot;第一个&quot; &#125;,&#123;2,&quot;第二&quot; &#125; &#125;; 添加和输出访问 1234567 dict.Add( 3,&quot;第一个&quot; ); foreach (var item in dict) &#123; Console.WriteLine(&quot;Key:&quot;+item.Key+&quot; Value:&quot;+ item.Value);&#125; 有序字典SortedDictionary&lt;TKey,TValue&gt;是一个二叉搜索树，其中的元素根据建排序。和前面讲的SortedList&lt;TKey,TValue&gt;的功能类似。但是SortedList&lt;TKey,TValue&gt;是基于数组的列表，而有序字典类为一个字典。多以它们也有不同之处： SortedList&lt;TKey,TValue&gt;使用的内存比SortedDictionary&lt;TKey,TValue&gt;少 SortedDictionary&lt;TKey,TValue&gt;的元素插入和删除比较快 在用已排好序的数据填充集合时，若不需要修改容量，SortedList&lt;TKey,TValue&gt;就比较快 六、集 包含不重复元素的的集合称为”集(set)”，.Net Core 包含两个集(HashSet**和SortedSet)**，它们都实现ISet接口，HashSet集包含不重复元素的无序列表，SortedSet集包含不重复元素的有序列表。 ISet接口提供的方法可以创建合集、交集，或者给出一个集是另一个集的超集或子集的信息。 1234567891011121314151617181920static void Main(string[] args) &#123; var teams = new HashSet&lt;string&gt;() &#123; &quot;one&quot;,&quot;two&quot;,&quot;three&quot;&#125;; var teams1= new HashSet&lt;string&gt;() &#123; &quot;开始&quot;,&quot;one&quot;, &quot;two&quot;, &quot;three&quot; &#125;; //Add方法如果集中存在该元素则不添加，返回bool值 if (!teams.Add(&quot;one&quot;)) &#123; Console.WriteLine(&quot;one 已经存在集中&quot;); &#125; //IsSubsetOf方法判断teams集合中的元素是否都包含在teams1中，返回bool值 if (teams.IsSubsetOf(teams1)) &#123; Console.WriteLine(&quot;teams中的值都包含在teams1中&quot;); &#125; //IsSupersetOf方法判断teams1集合是否是teams集合超集，返回bool值 if (teams1.IsSupersetOf(teams)) &#123; Console.WriteLine(&quot;teams1是teams的超集&quot;); &#125; //Overlaps方法判断teams集合与teams是否存在重叠的元素，返回bool值 if (teams.Overlaps(teams1)) &#123; Console.WriteLine(&quot;teams与teams1有重叠元素&quot;); &#125; &#125; 总结 许多的集合都提供了相同的功能，例如SortedList类与SortedDictionary类的功能几乎完全相同。但是其性能常常差别非常巨大，一个集合使用的内存少，另一个元素检索起来速度快，在MSDN文档中，集合的方法常常有性能的提示，给出以O记号表示的操作时间： * ** O(1)** * ** O(log n)** * ** O(n)** O(1)表示无论集合中有多少数据项，这个操作需要的时间都不变，例如，ArrayList类的Add()方法就具有这个行为，无论列表有多少个集合，在列表末尾添加一个新元素的时间都相同。 O(n)表示对于集合执行一个操作需要的时间最坏的情况是N，如果需要重新给集合分配内存，ArrayList类的Add()方法就是一个O(n)操作。改变容量，需要复制列表，复制的时间随元素的增加而线性的增加。 O(log n)表示操作需要的时间随集合中元素的增加而增加，但每个元素要增加的时间不是线性的，而是呈对数曲线。在集合中执行插入操作时，SortedDictionary&lt;TKey,TValue&gt;集合类具有O(log n)行为，而SortedList&lt;TKey,TValue&gt;集合具有O(n)行为，这里SortedDictionary&lt;TKey,TValue&gt;集合类就要快的多，因为树形结构中插入元素的效率比列表高的多。 下面表格中则列出了集合类及其执行不同操作的性能。可以使用这个表选择性能最佳的集合类进行使用。 最糟糕的是人们在生活中经常受到错误志向的阻碍而不自知，真到摆脱了那些阻碍时才能明白过来。——歌德]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类及接口详解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%8A%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、前言 在上一节中我们讲到抽象类和接口之间的异同，我们一起回顾下其异同。 ** 同：** 1、都不可以被实例化 2、都含有声明但未实现的方法 3、都可以被继承 4、其子类必须实现其声明未实现的方法 ** 异：** 1、接口是多继承，抽象类是单继承（一个类仅能继承一个抽象类，但可以继承多个接口） 2、抽象类可以包含实现的方法，接口不能包含实现的方法 3、接口支持回调，抽象类不支持 4、抽象类更多的定义在一些类关系紧密的类间，接口则定义在实现其某一种功能之间 抽象类和接口的异同我们再次熟悉了一遍，今天我们主要讲的是抽象类和接口使用场景及详讲抽象类的使用方法及接口的使用方法 二、使用场景 抽象类、普通类、接口。我们到底什么时候使用哪一个呢？这就很头痛了，不是一直使用一个就是好的。每一个都有每一个的使用场景。下面我们看看到底啥事时候用啥东西吧。 我们现在假设一个场景，现在需要设计一个程序，用来描述各个动物的一些生活习性，这里我们就有猪、猫、狗。 不使用抽象类也不使用接口。我们设计他们三个的各个习性，就是猪的类里面就包含自己的习性，猫类里面包含自己的习性，狗类里面包含自己的习性。如果各个习性较多但也有相同的。这样的类看起来非常的冗余。 我们加入抽象类（设计实现大的功能单元），定义一个抽象类-哺乳动物类，其中定义了共同的习性，走路的方法，呼吸的方法，繁衍下一代的方法。但是叫声不一样。我们又声明一个叫声的方法不实现（抽象方法）。这样再我们去定义猪类或者狗类的时候只需要写出不一样的地方即可。这样看起来代码也简洁，清楚 我们现在改用接口（设计实现小而简练的功能），我们把这些动物可以做什么列出来，然后统一使用接口去定义公共的。比如叫声，行走。这些功能，我们就可以使用接口来定义声明。然后继承再去实现。 到了这里，我们总结下到底我们编写程序为什么需要使用抽象类呢？为什么需要使用接口呢？单一用一个普通的类不好吗？简单又容易。其实不然。存在即合理。我们一起看看到底为什么要使用吧 ** 为什么使用抽象类？** ** 抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象`。这样来说如果一个类设计就是为了给其他类继承的，它代表一类对象所具有的公共属性或方法，我们就使用抽象类。就像上门的这个例子，把一些动物共同的属性或者方法提取出来，定义一个抽象类。代码变的易懂，代码冗余减少，变得简洁明了。实现了代码复用性。** ** 那么为什么使用接口呢？** ** 通俗点讲就是为了降低代码的耦合度。接口的意义在于抽象，不拘细节，从而使同类事物在在同一高度具有通用性及可替代性。上面的例子来讲，规定好了这个叫声这个方法，那么继承的就去实现这个叫声方法就好了。如果某天加入了一个新的动物，这样我们也不需要修改其他的任何方面，仅继承一下接口修改本身即可，不需要修改或改变其他的类或者接口。系统的灵活性增加了。** ** 这里可能会有个问题了。既然有了抽象类为什么还要用接口呢？这会不会有点多余？** ** 答案肯定是不会的。那么有了抽象类为什么还要使用接口呢？我们看看抽象类和接口的异同就很快能明白了。** 1、接口提供的事统一的行为规范，供其他调用，而抽象类具有接口的特性同时还可以有自己的具体实现 2、抽象类只能有一个父类，可以实现多个接口 ** 那么我们如何使用抽象类和接口呢？** 三、抽象类及接口使用 就拿我们上面举的那个例子来编写一段代码： 12345678910111213141516171819202122232425262728293031323334353637/// &lt;summary&gt; /// 叫声的接口定义 /// &lt;/summary&gt; public interface ICry &#123; string Cry(); &#125; /// &lt;summary&gt; /// 说话的接口定义 /// &lt;/summary&gt; public interface ISay &#123; string Say(); &#125; /// &lt;summary&gt; /// 动物抽象的抽象类 /// &lt;/summary&gt; public abstract class Animale &#123; /// &lt;summary&gt; /// 包含的实现了的方法、呼吸、走路 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Breathe() &#123; return &quot;呼吸一样&quot;; &#125; public static string Run() &#123; return &quot;走路一样&quot;; &#125; /// &lt;summary&gt; /// 未实现的抽象方法睡觉方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public abstract string Sleep(); &#125; /// &lt;summary&gt; /// 普通的类 继承了抽象类及两个接口 /// &lt;/summary&gt; public class Dog: Animale,ICry, ISay &#123; /// &lt;summary&gt; /// 实现重写抽象方法睡觉 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override string Sleep() &#123; return &quot;睡觉&quot;; &#125; /// &lt;summary&gt; /// 实现叫声接口方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string Cry() &#123; return &quot;旺旺&quot;; &#125; /// &lt;summary&gt; /// 实现说话接口方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string Say() &#123; return &quot;说话&quot;; &#125; &#125; 在上面的代码中，我们列举出了接口的定义及抽象类、抽象方法的定义及使用。在最下面一个普通类中，我们继承了一个抽象类及两个接口，可以实现多个接口但是只能有一个抽象父类。如果继承两个抽象类的话会报错的。 ** 抽象类关键字**–abstract ** 接口关键字–interface** 四、扩展延伸（密封类） 讲到抽象类，我们也可以一起看看密封类，密封类不能作为基类，禁止派生。如果重写了某些功能会导致编译错误或者为了防止第三方进行扩展重写，这个时候我们就可以使用到密封类。 ** 重点注意**： ** 1、密封类中不能包含虚方法（Virtual）和抽象方法（abstract）。因为密封类是不能被继承的也就没有派生类，就不具备实现抽象方法和虚方法的机会。** ** 2、在使用密封类（sealed）的时候，密封类将限制它的使用，现在及未来都将受到影响** ** 3、如果实例方法包含了sealed修饰符，那么它也必须包含override修饰符，其父类方法必须包含virtual修饰符** 123456789101112131415161718/// &lt;summary&gt; /// 普通动物类 /// &lt;/summary&gt; public class Animals &#123; /// &lt;summary&gt; /// 动物的叫声方法，因为其派生类重写了次方法，所以必须使用virtual修饰符 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public virtual string Cry() &#123; return &quot;叫声&quot;; &#125; &#125; /// &lt;summary&gt; /// 动物狗类密封类，无法产生派生类，不能作为基类，继承了动物类 /// &lt;/summary&gt; public sealed class Dog : Animals &#123; /// &lt;summary&gt; /// 重写了动物叫的方法，同时标记为了密封方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override sealed string Cry() &#123; return &quot;旺旺&quot;; &#125; &#125; ** 在使用密封类的时候我们需要考虑的因素需要更加的全面，更加的谨慎，以防后面重新推翻重写。每个东西都没有绝对的好，只有你用的恰到好处。多思考多选择才是智者。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ的介绍及使用进阶（Docker+.Net Core）]]></title>
    <url>%2F2019%2F08%2F02%2FRabbitMQ%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%EF%BC%88Docker%2B.Net%20Core%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： ** 一、什么是RabbitMQ** ** 二、RabbitMQ运用场景** ** 三、RabbitMQ优势及特点** ** 四、Centos7中Docker安装RabbitMQ** ** 五、.Net Core 中使用RabbitMQ** 一、什么是RabbitMQ RabbitMQ是什么? –”RabbitMQ是基于AMQP协议的队列服务“,. 什么是AMQP?– Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。 可以理解RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（也可以叫面向消息的中间件） 二、RabbitMQ运用场景 消息通讯—因为其本身就是基于AMQP协议的队列服务，也就可以用于单纯的消息通讯，实现点对点的消息通讯或者聊天。 提速提性能—异步处理，不需要及时同步处理并且比较耗时，减少请求响应时间 流量削峰—流量过大，应用容易挂掉，可使用队列来处理。 三、RabbitMQ优势及特点 可靠—RabbitMQ具有持久化，传输确认，发布确认等机制。保证了消息的安全性，一旦发送了消息，就算接收者接收不到，它也会保存信息，一直到接收者接收消息为止 复用性—RabbitMQ可以发送多种类型消息 异步处理（提速）—把消息传给中间件，中间件后续慢慢处理，同时也可达到削峰的效果 解耦–防止引入过多的API给系统的稳定性带来风险；调用方使用不当会给被调用方系统造成压力，被调用方处理不当会降低调用方系统的响应能力。 四、Centos7中Docker安装RabbitMQ ** 如何在Linux中安装可以看前段时间的一篇文章–https://www.cnblogs.com/hulizhong/p/10702367.html** 先拉取镜像（选择带有mangement的版本） 1docker pull rabbitmq:management 然后查看镜像拉取情况 1docker images 启动容器同时设置账号密码 1docker run --name=rabbit -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -d rabbitmq:management 查看容器运行情况 1docker ps 运行成功，然后我们就去浏览器看看能否访问ip:15672 然后输入刚刚输入的账号密码登入进去就可以查看消息队列的整体情况，到这里RabbitMQ已经安装好了，接下来我们看看如何在.Net Core中使用RabbitMQ. 五、.Net Core 中使用RabbitMQ RabbitMQ使用的话可以分为三个步骤 1、 创建RabbitMQ的连接 1234567891011public class ConnectionMQ &#123; /// &lt;summary&gt; /// 创建MQ连接 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IConnection Connection() &#123; //创建连接工厂 ConnectionFactory factory = new ConnectionFactory &#123; UserName = “admin”,//用户名 Password =” admin”,//密码 HostName = “127.0.0.1”//rabbitmq ip &#125;; //创建连接 var connection = factory.CreateConnection(); return connection; &#125; &#125; 2、 RabbitMQ发送消息 1234567891011121314151617181920 public class PushMQ &#123; /// &lt;summary&gt; /// 发送MQ消息 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;queueName&quot;&gt;&lt;/param&gt; public static void SendMQ&lt;T&gt;(T item,string queueName) &#123; string input = Newtonsoft.Json.JsonConvert.SerializeObject(item); using (var channel = ConnectionMQ.Connection().CreateModel()) &#123; //声明一个队列 channel.QueueDeclare( queue: queueName,//队列名称 durable: true,//队列是否持久化 exclusive: false,//是否排外的 autoDelete: false,//是否自动删除 arguments: null//消息什么时候自动 ); var sendBytes=Encoding.UTF8.GetBytes(input); var properties = new BasicProperties(); properties.DeliveryMode = 2;// 设置消息是否持久化，1： 非持久化 2：持久化 //发布消息 channel.BasicPublish( exchange: &quot;&quot;, routingKey: queueName, mandatory: true, basicProperties: properties, body: sendBytes); &#125; &#125;&#125; 在这里连接的ConnectionMQ.Connection().CreateModel()是可以进行重写的，自己定义如何去连接 3、 RabbitMQ接收消息 123456789101112131415161718public class ReceiveMQ &#123; /// &lt;summary&gt; /// 接收MQ消息 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;func&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;queueName&quot;&gt;&lt;/param&gt; public static void GetMQ&lt;T&gt;(Func&lt;T,bool&gt; func,string queueName) &#123; //创建连接 var connection = ConnectionMQ.Connection(); //创建通道 var channel = connection.CreateModel(); //事件基本消费者 EventingBasicConsumer consumer = new EventingBasicConsumer(channel); //接收到消息事件 consumer.Received += (ch, ea) =&gt; &#123; var message = Encoding.UTF8.GetString(ea.Body); try &#123; var item = JsonConvert.DeserializeObject&lt;T&gt;(message); func(item); &#125; catch (Exception ex) &#123; LogHelp.Error(ex); &#125; //确认该消息已被消费 channel.BasicAck(ea.DeliveryTag, false); &#125;; //启动消费者 设置为手动应答消息 channel.BasicConsum、e(queueName, false, consumer); &#125; &#125; 4、查看消息 在这里我们发送消息，然后我们去ip+15672看看是否有未消费的消息。 发现有一条未消费的信息，队列名称是Test，正好是我们刚刚发送的消息。 然后我们去消费这一条信息，再次进入ip+15672看看 刚刚的一条消息的确被消费掉了。其中GetInfo方法可以穿插自己的很多的业务逻辑的处理。到这里也就简单的介绍了下如何在.Net Core中使用RabbitMQ,还有一些其他的属性必要之时都可以加入进来的。可以高度扩展的。`]]></content>
      <categories>
        <category>Docker知识分享</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows+docker 运行.NetCore]]></title>
    <url>%2F2019%2F08%2F02%2FWindows%2Bdocker%20%E8%BF%90%E8%A1%8C.NetCore%2F</url>
    <content type="text"><![CDATA[今天我们来说下如何在windows下使用docker运行.net core，既然是docker，那么我们首先得在windows上安装docker。 在Windows安装 docker 有两种选择： 1、docker for windows 2、docker toolbox 区别： docker for windows-64位Windows 10、必须开启 Hyper-V docker toolbox -有virtualbox即可 今天只给大家介绍 docker for windows安装 地址：https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe 我们下载按照步骤一步步安装就ok了，安装之后打开可能会出现一个错误，如果没有出现那肯定万事大吉咯！ Hyper-V 没开不能启动： 以管理员身份打开 PowerShell 控制台。 运行以下命令： 1Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All 现在我们再来启动即可，在右下角也会有一个图标，悬浮上去显示 docker desk is running，表示已经安装成功（这个会提示我们登录，不过登录不登录问题都不是太大，登录之后可以连接到(Docker Hub） 接下来正式进入我们今天的主题，如何而使用 docker for windows 来运行 .netcore（Start） 首先我们创建一个.net core web项目 然后我们去项目根目录去看，会发现有一个Dockerfile的文件，同样我们需要在项目当中修改Dockerfile文件的属性，修改为较新则复制。 我们可以运行一下.net core看一下出来的页面效果，到现在我们需要的.net core的事例已经准备好了，我们现在开始在docker 中部署了。 我们打开PowerShell ，输入 docker info 出现下面的界面的样子证明docker 一切正常。 我们进入到我们刚刚创建的.net core 项目的根目录，然后开始构建docker镜像，要注意命令后面的那个 . ，意思是当前目录 1docker build -t demotest . 然后我们发现在执行到第六步的时候报错了，说什么在该路径找不到该文件 我也卡在这里卡了很久，最后发现路径拼接起来不对。我们仔细检查下Dockerfile文件的第六步发现文件路径是dockertest/dockertest.csproj，再结合我们当前路径是E:\Docker\dockertest \dockertest，组合一来看，多了一个dockertest，然后我们修改Dockerfile文件中的路径去掉这个多的dockertest/ 然后我们再来执行docker build -t demotest .然后发现我们在第10步的时候又出错了，说这个程序不包含适合入口点的静态’Main’方法，我们继续检查下Dockerfile文件，发现第9步那个工作路径 是/src/dockertest，我们拼接一下发现，又多了一个/dockertest，我们接着继续去掉这个，然后继续运行docker build -t demotest . 这一次终于不负众望。它完整的运行完成了所有的步骤并且提示了 123Successfully built eaa8cea8fcf4Successfully tagged demotest:latest 我们来看看构建镜像是否真的成功了吧 1docker images 我们发现了这一个，是我们刚刚创建的demotest,既然镜像我们已经创建成功了，那我们正式运行起来看看是否可用。 1docekr run --name=demotest -p7778:80-d demotest--name：指定容器名称-p：指定容器端口-d：指定容器 后台运行 然后出现了一串字符串，说明我们启动成功了，然后我们查看一下我们正在运行的容器 1docker ps 然后我们去浏览器输入ip+7778，看到如下页面证明这次docker for windows +.net core 成功运行了。 那么到这里我们的第一的windows+docker运行.netcore算是正式完工了，然后在给大家介绍一些较为常用的docker命令（命令） 123456789101112131415161718192021docker build -t demotest . 构建 demotest镜像docker images 查看当前所有的镜像docker inspect demotest 查看 运行容器的详情docker ps 查看当前运行的容器docker ps -a 查看当前所有的容器docker stop demotest 停止运行demotest容器docker start demotest 开启运行demotest容器docker rm demotest 删除demotest容器docker rmi demotest 删除demotest镜像docker rm $(docker ps -aq) 删除所有容器docker rmi $(docker images -q) 删除所有镜像]]></content>
      <categories>
        <category>Docker知识分享</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识详解系列目录]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[摘要：这个系列是本人在学习与复习当中所遇到或尚且未知的一些知识点，目前逐步学习并详细解读。 目录索引：一、c#类型详解上 二、基础类型详解下 三、抽象类与接口 四、委托与事件-委托详解（一） 五、委托与事件-事件详解（二） 六、委托与事件-委托事件案例（三） 七、面向对象三大特性—–封装、继承、多态 八、泛型程序设计详解（一） 九、泛型协变与抗变（二） 十、数组（ArrayPool数组池、Span结构） 十一、集合（正在编写中） 十二、LINQ（正在编写中） 十三、错误异常处理（正在编写中） 十四、异步编程（正在编写中） 十五、反射、元数据和动态编程（正在编写中） 十六、托管和非托管内存（正在编写中） 总结：** 本人知识尚且有限，一旦出现误解或者少解还请各位慷慨解囊。** ** 清风飒爽柳姿还在，一片轻云漫飞天。涟漪泛湖荷叶拂舟，一曲和音绕指柔。对镜描妆素面朝天，一记浅笑去无痕。凭栏怅望凝眸思量，一片清秋气自爽。和音题文，一把辛酸暂埋藏，寻音倚歌，一帘惆怅浅卷起。但凭楼兰，倾泻柔情，不慢不躁，雅致清秋，莫使伤愁锁清秋。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础类型详解下]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[前言在上一节中，我们讲到在c#中所有的类都继承一个基类–System.Object。然后其下又分为俩大类–值类型及引用类型。这一节我们详细讲解值类型和引用类型包含了那些东西及内存的分配 堆和栈在我们讲解类型前，我们得先去了解堆和栈是什么，及其区别。我们可以先知道值类型和引用类型的引用都是分配在栈中的，而引用类型的对象分配在堆中的。我们详细看看堆和栈有啥区别及其原理吧 堆（heap）–堆的分配空间是自下到上的，已占用的空间在自由空间下面，C#中引用类型的对象及分配在堆中的，内存的分配是连续的。内存对象释放是受垃圾回收机制管理的，所有在引用对象释放时会消耗更多的性能。效率相对于栈来说是较低的。 栈（stack）–栈的分配空间是自上到下的，遵循先进先出的原则，依次释放分配的内存空间。分配的内存空间是连续的，C#中的值类型及引用类型的引用都是存放在栈中的。 当一个类的实例创建对象的的时候，这个对象的不同的成员将被分配到不用的内存空间，值类型及引用类型的引用分配到栈中，引用类型对象分配到堆中，静态成员被分配到全局数据区。这个时候栈上的指针会指向堆中实际的对象，在对象使用完成后，指针和对象会切开联系，从而使对象进入冬眠期，因为栈具有自我维护性，内存管理通过操作系统完成，而堆中的冬眠对象将有垃圾回收机制进行回收，释放对象所占的内存。 值类型及引用类型值类型： 结构体：struct（直接派生于System.ValueType） 数值类型：整型、浮点型、decimal型、bool型 枚举：enum（派生于System.Enum） 引用类型： 数组：Array（派生于System.Array） 类：class（派生于System.Object） 接口：interface 委托：delegate（派生于System.Delegate） 字符串：string(System.String) 在此特别强调：.Net中所有的元素在使用前都必须初始化，在调用new创建实例的时候，编译器会隐式的调用无参构造函数进行初始化。所有的值类型的值都为0（char为’0’），所有引用类型为null。 在此可调用IsValueType来判断类型是否为值类型 1234567StringBuilder strSql = new StringBuilder(); if (strSql.GetType().IsValueType) &#123;&#125; 引用类型中尤为注意的事string类型，它具有一特效–恒定不变性，什么意思呢？也就是说string类型一旦赋值，一旦在Heap堆中分配了内存存储对象，则再也无法改变其对象的内容。我们看下面这个例子 123String a=”aaa”;a=”bbb”; 在这个例子中先是对象a创建在堆中分配内存存储’aaa’，然后又给a对象重新赋值’bbb’,其中并不是修改堆内存中对象aaa为bbb，实则是重新创建了一个堆内存对象存储’bbb’，然后把它的引用地址指向a，原来的堆内存对象’aaa’还继续保存在堆内存中，不曾修改。只有当GC垃圾回收机制处理回收，才会消失。]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c#类型详解]]></title>
    <url>%2F2019%2F07%2F31%2FC%23%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、类型成员类成员定义有（public、private、internal、protected）。 Public–对任何类和成员都是公开的，无限制 Private–是私有的，仅能由类内部代码访问，如果没有声明，默认使用此关键字 Internal–仅能在所属命名空间内部访问 Protected–可以由类或者其派生类中的代码访问 类成员–字段、方法、属性 12345678910public class MyClass &#123; public int MyInt = 2019;//字段 public static string MyMain() &#123; return &quot;这是方法&quot;; &#125; public int MyProperty &#123; get; set; &#125;//属性&#125; 字段–一个只读、可读/写的数据值 方法–对类型或对象状态数据操作的一个过程实现 属性–它可以像方法一样操作类或对象的状态数据，但看上去却像字段一样的书写方式 二、类型操作（隐式转换、显示转换、装箱、拆箱）隐式转换–对于内置数值类型，如果要存储的值无需截断或四舍五入即可适应变量，则可以进行隐式转换、小精度数据转大精度也可进行隐式转换 123Int Num=100;Long Bignum= Num;&lt;/pre&gt; 显示转换–显示转换也称为强制转换，强制转换是显式告知编译器你打算进行转换且你知道可能会发生数据丢失的一种方式。 12345Double Num=100.1;Int a;a=int.Parse(Num);&lt;/pre&gt; 显示转换存在一定的风险性，如若出现失误可能会抛出异常或者影响整个结果的精确性。假如在不知a的类型的情况下进行显示转换，但是转换失败则会引起程序抛出异常。 1var a = &quot;yi&quot;; int b = int.Parse(a);&lt;/pre&gt; 这是可以尝试使用TryParse，这里返回的是一个bool，转换成功则True 1var a = &quot;yi&quot;; int b; int.TryParse(a, out b);&lt;/pre&gt; 类型操作转换–装箱、拆箱 123456789public void Test() &#123; //装箱 int a = 1; object obj = a; //拆箱 object obj2 = 2; int b = (int)obj2;&#125; 首先我们得了解，值类型是分配在线程栈中的，不受垃圾回收机制管理。而引用类型分配在托管堆中的。 装箱–简单来说值类型转换引用类型是装箱，详细来说是。先在托管内存中分配内存，然后将值类型的值复制到内存堆中，然后返回新对象的地址，这一过程为装箱。 拆箱–拆箱并不是装箱的逆过程，简单说也是引用类型转换为值类型为拆箱，详细来说拆箱是获取为装箱部分的指针，然后将未装箱部分的值复制到堆栈中。 三、类型转换(Is,As)类型转换操作符–is、as as–是将一个对象从一种类型转换为另一种类型，如果转换成功则返回该类型，否则返回null 123A a=new A();B b= A as B;//转换正常则返回B类型，转换失败则返回null&lt;/pre&gt; is–是判断一种类型转换为另一种类型，如果转换成功则返回True，否则返回False。 123456A a=new A();If(B is A)//返回True False &#123;&#125; 保险起见可以先用is对类型转换进行判断然后再使用as进行类型转换。当然这样的话可能会造成更新的性能消耗。 更简单的一次验证并安全的操作： 123A a=new A();B b= A as B; if(B!=null)&#123;&#125; else&#123;&#125; 四、类型分类一切皆对象，每一个对象都对应一个类，所有的类都有一个基类–Object-System.Object 然后其下又可分为值类型(基本数据类型)、引用类型。 值类型：整型、浮点型、字符型、布尔型、结构体、枚举 引用类型：数组、字符串、类、接口、委托 关于类型的详解将在下一节中详细讲出。 五、扩展延伸（抽象类、类）在这里我们详细讲解下类以及抽象类。同时与接口直接的区别和相同。 类-抽象类： 1、都可被继承 2、抽象类不能被实例化，只是用来继承的，普通类可以实例化 3、抽象类只含有方法声明，没有方法体。并且只能存在于抽象类中 4、继承抽象类的子类必须实现抽象方法，除非子类也是抽象类 5、抽象类中可以包含抽象方法和实例方法 接口-抽象类： 相同 1、都可被继承 2、都可以有声明不实现的方法 3、都不可被实例化 4、子类必须实现其声明的方法 不同： 1、一个类可以继承多个接口，但是仅能继承一个抽象类 2、抽象类可包含实例方法，接口不可包含 3、接口支持回调，抽象类不支持 既然有类、抽象类、接口，那么他们分别在什么时候使用呢？ 类不用说了吧，普通情况下使用即可。 抽象类–如果需要设计大的功能单元，则使用抽象类。抽象类主要用于关系密切的对象。 接口–如果设计小而简练的功能块的话可以使用接口，接口适合为不想关的类提供通用功能 举个例子：一个围栏之间有很多的小动物，猪、狗、鸡、猫。针对这个我们设计一段程序，猪、狗、鸡、猫其都是动物，根据抽象类-设计大的功能单元。我们可以设计一个动物类的抽象类。然后在各自继承下去写自己的具体类（猪类、狗类、鸡类、猫类）。那么我们要研究他们的叫声，这里设计小的功能模块。我们就可以使用接口来设计一个叫声。然后每个每个东西去实现不同的叫声（猪叫、狗叫、鸡叫、猫叫）。设计实现大的功能单元我们选择抽象类，设计实现小而简练的功能块我们选择使用接口。 总结:c#基础知识详解系列]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
</search>
