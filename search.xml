<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[抽象类及接口详解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%8A%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、前言 在上一节中我们讲到抽象类和接口之间的异同，我们一起回顾下其异同。 ** 同：** 1、都不可以被实例化 2、都含有声明但未实现的方法 3、都可以被继承 4、其子类必须实现其声明未实现的方法 ** 异：** 1、接口是多继承，抽象类是单继承（一个类仅能继承一个抽象类，但可以继承多个接口） 2、抽象类可以包含实现的方法，接口不能包含实现的方法 3、接口支持回调，抽象类不支持 4、抽象类更多的定义在一些类关系紧密的类间，接口则定义在实现其某一种功能之间 抽象类和接口的异同我们再次熟悉了一遍，今天我们主要讲的是抽象类和接口使用场景及详讲抽象类的使用方法及接口的使用方法 二、使用场景 抽象类、普通类、接口。我们到底什么时候使用哪一个呢？这就很头痛了，不是一直使用一个就是好的。每一个都有每一个的使用场景。下面我们看看到底啥事时候用啥东西吧。 我们现在假设一个场景，现在需要设计一个程序，用来描述各个动物的一些生活习性，这里我们就有猪、猫、狗。 不使用抽象类也不使用接口。我们设计他们三个的各个习性，就是猪的类里面就包含自己的习性，猫类里面包含自己的习性，狗类里面包含自己的习性。如果各个习性较多但也有相同的。这样的类看起来非常的冗余。 我们加入抽象类（设计实现大的功能单元），定义一个抽象类-哺乳动物类，其中定义了共同的习性，走路的方法，呼吸的方法，繁衍下一代的方法。但是叫声不一样。我们又声明一个叫声的方法不实现（抽象方法）。这样再我们去定义猪类或者狗类的时候只需要写出不一样的地方即可。这样看起来代码也简洁，清楚 我们现在改用接口（设计实现小而简练的功能），我们把这些动物可以做什么列出来，然后统一使用接口去定义公共的。比如叫声，行走。这些功能，我们就可以使用接口来定义声明。然后继承再去实现。 到了这里，我们总结下到底我们编写程序为什么需要使用抽象类呢？为什么需要使用接口呢？单一用一个普通的类不好吗？简单又容易。其实不然。存在即合理。我们一起看看到底为什么要使用吧 ** 为什么使用抽象类？** ** 抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象`。这样来说如果一个类设计就是为了给其他类继承的，它代表一类对象所具有的公共属性或方法，我们就使用抽象类。就像上门的这个例子，把一些动物共同的属性或者方法提取出来，定义一个抽象类。代码变的易懂，代码冗余减少，变得简洁明了。实现了代码复用性。** ** 那么为什么使用接口呢？** ** 通俗点讲就是为了降低代码的耦合度。接口的意义在于抽象，不拘细节，从而使同类事物在在同一高度具有通用性及可替代性。上面的例子来讲，规定好了这个叫声这个方法，那么继承的就去实现这个叫声方法就好了。如果某天加入了一个新的动物，这样我们也不需要修改其他的任何方面，仅继承一下接口修改本身即可，不需要修改或改变其他的类或者接口。系统的灵活性增加了。** ** 这里可能会有个问题了。既然有了抽象类为什么还要用接口呢？这会不会有点多余？** ** 答案肯定是不会的。那么有了抽象类为什么还要使用接口呢？我们看看抽象类和接口的异同就很快能明白了。** 1、接口提供的事统一的行为规范，供其他调用，而抽象类具有接口的特性同时还可以有自己的具体实现 2、抽象类只能有一个父类，可以实现多个接口 ** 那么我们如何使用抽象类和接口呢？** 三、抽象类及接口使用 就拿我们上面举的那个例子来编写一段代码： 12345678910111213141516171819202122232425262728293031323334353637/// &lt;summary&gt; /// 叫声的接口定义 /// &lt;/summary&gt; public interface ICry &#123; string Cry(); &#125; /// &lt;summary&gt; /// 说话的接口定义 /// &lt;/summary&gt; public interface ISay &#123; string Say(); &#125; /// &lt;summary&gt; /// 动物抽象的抽象类 /// &lt;/summary&gt; public abstract class Animale &#123; /// &lt;summary&gt; /// 包含的实现了的方法、呼吸、走路 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Breathe() &#123; return &quot;呼吸一样&quot;; &#125; public static string Run() &#123; return &quot;走路一样&quot;; &#125; /// &lt;summary&gt; /// 未实现的抽象方法睡觉方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public abstract string Sleep(); &#125; /// &lt;summary&gt; /// 普通的类 继承了抽象类及两个接口 /// &lt;/summary&gt; public class Dog: Animale,ICry, ISay &#123; /// &lt;summary&gt; /// 实现重写抽象方法睡觉 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override string Sleep() &#123; return &quot;睡觉&quot;; &#125; /// &lt;summary&gt; /// 实现叫声接口方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string Cry() &#123; return &quot;旺旺&quot;; &#125; /// &lt;summary&gt; /// 实现说话接口方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string Say() &#123; return &quot;说话&quot;; &#125; &#125; 在上面的代码中，我们列举出了接口的定义及抽象类、抽象方法的定义及使用。在最下面一个普通类中，我们继承了一个抽象类及两个接口，可以实现多个接口但是只能有一个抽象父类。如果继承两个抽象类的话会报错的。 ** 抽象类关键字**–abstract ** 接口关键字–interface** 四、扩展延伸（密封类） 讲到抽象类，我们也可以一起看看密封类，密封类不能作为基类，禁止派生。如果重写了某些功能会导致编译错误或者为了防止第三方进行扩展重写，这个时候我们就可以使用到密封类。 ** 重点注意**： ** 1、密封类中不能包含虚方法（Virtual）和抽象方法（abstract）。因为密封类是不能被继承的也就没有派生类，就不具备实现抽象方法和虚方法的机会。** ** 2、在使用密封类（sealed）的时候，密封类将限制它的使用，现在及未来都将受到影响** ** 3、如果实例方法包含了sealed修饰符，那么它也必须包含override修饰符，其父类方法必须包含virtual修饰符** 123456789101112131415161718/// &lt;summary&gt; /// 普通动物类 /// &lt;/summary&gt; public class Animals &#123; /// &lt;summary&gt; /// 动物的叫声方法，因为其派生类重写了次方法，所以必须使用virtual修饰符 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public virtual string Cry() &#123; return &quot;叫声&quot;; &#125; &#125; /// &lt;summary&gt; /// 动物狗类密封类，无法产生派生类，不能作为基类，继承了动物类 /// &lt;/summary&gt; public sealed class Dog : Animals &#123; /// &lt;summary&gt; /// 重写了动物叫的方法，同时标记为了密封方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override sealed string Cry() &#123; return &quot;旺旺&quot;; &#125; &#125; ** 在使用密封类的时候我们需要考虑的因素需要更加的全面，更加的谨慎，以防后面重新推翻重写。每个东西都没有绝对的好，只有你用的恰到好处。多思考多选择才是智者。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ的介绍及使用进阶（Docker+.Net Core）]]></title>
    <url>%2F2019%2F08%2F02%2FRabbitMQ%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%EF%BC%88Docker%2B.Net%20Core%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： ** 一、什么是RabbitMQ** ** 二、RabbitMQ运用场景** ** 三、RabbitMQ优势及特点** ** 四、Centos7中Docker安装RabbitMQ** ** 五、.Net Core 中使用RabbitMQ** 一、什么是RabbitMQ RabbitMQ是什么? –”RabbitMQ是基于AMQP协议的队列服务“,. 什么是AMQP?– Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。 可以理解RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（也可以叫面向消息的中间件） 二、RabbitMQ运用场景 消息通讯—因为其本身就是基于AMQP协议的队列服务，也就可以用于单纯的消息通讯，实现点对点的消息通讯或者聊天。 提速提性能—异步处理，不需要及时同步处理并且比较耗时，减少请求响应时间 流量削峰—流量过大，应用容易挂掉，可使用队列来处理。 三、RabbitMQ优势及特点 可靠—RabbitMQ具有持久化，传输确认，发布确认等机制。保证了消息的安全性，一旦发送了消息，就算接收者接收不到，它也会保存信息，一直到接收者接收消息为止 复用性—RabbitMQ可以发送多种类型消息 异步处理（提速）—把消息传给中间件，中间件后续慢慢处理，同时也可达到削峰的效果 解耦–防止引入过多的API给系统的稳定性带来风险；调用方使用不当会给被调用方系统造成压力，被调用方处理不当会降低调用方系统的响应能力。 四、Centos7中Docker安装RabbitMQ ** 如何在Linux中安装可以看前段时间的一篇文章–https://www.cnblogs.com/hulizhong/p/10702367.html** 先拉取镜像（选择带有mangement的版本） 1docker pull rabbitmq:management 然后查看镜像拉取情况 1docker images 启动容器同时设置账号密码 1docker run --name=rabbit -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -d rabbitmq:management 查看容器运行情况 1docker ps 运行成功，然后我们就去浏览器看看能否访问ip:15672 然后输入刚刚输入的账号密码登入进去就可以查看消息队列的整体情况，到这里RabbitMQ已经安装好了，接下来我们看看如何在.Net Core中使用RabbitMQ. 五、.Net Core 中使用RabbitMQ RabbitMQ使用的话可以分为三个步骤 1、 创建RabbitMQ的连接 1234567891011public class ConnectionMQ &#123; /// &lt;summary&gt; /// 创建MQ连接 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IConnection Connection() &#123; //创建连接工厂 ConnectionFactory factory = new ConnectionFactory &#123; UserName = “admin”,//用户名 Password =” admin”,//密码 HostName = “127.0.0.1”//rabbitmq ip &#125;; //创建连接 var connection = factory.CreateConnection(); return connection; &#125; &#125; 2、 RabbitMQ发送消息 1234567891011121314151617181920 public class PushMQ &#123; /// &lt;summary&gt; /// 发送MQ消息 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;queueName&quot;&gt;&lt;/param&gt; public static void SendMQ&lt;T&gt;(T item,string queueName) &#123; string input = Newtonsoft.Json.JsonConvert.SerializeObject(item); using (var channel = ConnectionMQ.Connection().CreateModel()) &#123; //声明一个队列 channel.QueueDeclare( queue: queueName,//队列名称 durable: true,//队列是否持久化 exclusive: false,//是否排外的 autoDelete: false,//是否自动删除 arguments: null//消息什么时候自动 ); var sendBytes=Encoding.UTF8.GetBytes(input); var properties = new BasicProperties(); properties.DeliveryMode = 2;// 设置消息是否持久化，1： 非持久化 2：持久化 //发布消息 channel.BasicPublish( exchange: &quot;&quot;, routingKey: queueName, mandatory: true, basicProperties: properties, body: sendBytes); &#125; &#125;&#125; 在这里连接的ConnectionMQ.Connection().CreateModel()是可以进行重写的，自己定义如何去连接 3、 RabbitMQ接收消息 123456789101112131415161718public class ReceiveMQ &#123; /// &lt;summary&gt; /// 接收MQ消息 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;func&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;queueName&quot;&gt;&lt;/param&gt; public static void GetMQ&lt;T&gt;(Func&lt;T,bool&gt; func,string queueName) &#123; //创建连接 var connection = ConnectionMQ.Connection(); //创建通道 var channel = connection.CreateModel(); //事件基本消费者 EventingBasicConsumer consumer = new EventingBasicConsumer(channel); //接收到消息事件 consumer.Received += (ch, ea) =&gt; &#123; var message = Encoding.UTF8.GetString(ea.Body); try &#123; var item = JsonConvert.DeserializeObject&lt;T&gt;(message); func(item); &#125; catch (Exception ex) &#123; LogHelp.Error(ex); &#125; //确认该消息已被消费 channel.BasicAck(ea.DeliveryTag, false); &#125;; //启动消费者 设置为手动应答消息 channel.BasicConsum、e(queueName, false, consumer); &#125; &#125; 4、查看消息 在这里我们发送消息，然后我们去ip+15672看看是否有未消费的消息。 发现有一条未消费的信息，队列名称是Test，正好是我们刚刚发送的消息。 然后我们去消费这一条信息，再次进入ip+15672看看 刚刚的一条消息的确被消费掉了。其中GetInfo方法可以穿插自己的很多的业务逻辑的处理。到这里也就简单的介绍了下如何在.Net Core中使用RabbitMQ,还有一些其他的属性必要之时都可以加入进来的。可以高度扩展的。`]]></content>
      <categories>
        <category>Docker知识分享</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows+docker 运行.NetCore]]></title>
    <url>%2F2019%2F08%2F02%2FWindows%2Bdocker%20%E8%BF%90%E8%A1%8C.NetCore%2F</url>
    <content type="text"><![CDATA[今天我们来说下如何在windows下使用docker运行.net core，既然是docker，那么我们首先得在windows上安装docker。 在Windows安装 docker 有两种选择： 1、docker for windows 2、docker toolbox 区别： docker for windows-64位Windows 10、必须开启 Hyper-V docker toolbox -有virtualbox即可 今天只给大家介绍 docker for windows安装 地址：https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe 我们下载按照步骤一步步安装就ok了，安装之后打开可能会出现一个错误，如果没有出现那肯定万事大吉咯！ Hyper-V 没开不能启动： 以管理员身份打开 PowerShell 控制台。 运行以下命令： 1Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All 现在我们再来启动即可，在右下角也会有一个图标，悬浮上去显示 docker desk is running，表示已经安装成功（这个会提示我们登录，不过登录不登录问题都不是太大，登录之后可以连接到(Docker Hub） 接下来正式进入我们今天的主题，如何而使用 docker for windows 来运行 .netcore（Start） 首先我们创建一个.net core web项目 然后我们去项目根目录去看，会发现有一个Dockerfile的文件，同样我们需要在项目当中修改Dockerfile文件的属性，修改为较新则复制。 我们可以运行一下.net core看一下出来的页面效果，到现在我们需要的.net core的事例已经准备好了，我们现在开始在docker 中部署了。 我们打开PowerShell ，输入 docker info 出现下面的界面的样子证明docker 一切正常。 我们进入到我们刚刚创建的.net core 项目的根目录，然后开始构建docker镜像，要注意命令后面的那个 . ，意思是当前目录 1docker build -t demotest . 然后我们发现在执行到第六步的时候报错了，说什么在该路径找不到该文件 我也卡在这里卡了很久，最后发现路径拼接起来不对。我们仔细检查下Dockerfile文件的第六步发现文件路径是dockertest/dockertest.csproj，再结合我们当前路径是E:\Docker\dockertest \dockertest，组合一来看，多了一个dockertest，然后我们修改Dockerfile文件中的路径去掉这个多的dockertest/ 然后我们再来执行docker build -t demotest .然后发现我们在第10步的时候又出错了，说这个程序不包含适合入口点的静态’Main’方法，我们继续检查下Dockerfile文件，发现第9步那个工作路径 是/src/dockertest，我们拼接一下发现，又多了一个/dockertest，我们接着继续去掉这个，然后继续运行docker build -t demotest . 这一次终于不负众望。它完整的运行完成了所有的步骤并且提示了 123Successfully built eaa8cea8fcf4Successfully tagged demotest:latest 我们来看看构建镜像是否真的成功了吧 1docker images 我们发现了这一个，是我们刚刚创建的demotest,既然镜像我们已经创建成功了，那我们正式运行起来看看是否可用。 1docekr run --name=demotest -p7778:80-d demotest--name：指定容器名称-p：指定容器端口-d：指定容器 后台运行 然后出现了一串字符串，说明我们启动成功了，然后我们查看一下我们正在运行的容器 1docker ps 然后我们去浏览器输入ip+7778，看到如下页面证明这次docker for windows +.net core 成功运行了。 那么到这里我们的第一的windows+docker运行.netcore算是正式完工了，然后在给大家介绍一些较为常用的docker命令（命令） 123456789101112131415161718192021docker build -t demotest . 构建 demotest镜像docker images 查看当前所有的镜像docker inspect demotest 查看 运行容器的详情docker ps 查看当前运行的容器docker ps -a 查看当前所有的容器docker stop demotest 停止运行demotest容器docker start demotest 开启运行demotest容器docker rm demotest 删除demotest容器docker rmi demotest 删除demotest镜像docker rm $(docker ps -aq) 删除所有容器docker rmi $(docker images -q) 删除所有镜像]]></content>
      <categories>
        <category>Docker知识分享</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识详解系列目录]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[摘要：这个系列是本人在学习与复习当中所遇到或尚且未知的一些知识点，目前逐步学习并详细解读。 目录索引：一、c#类型详解上 二、基础类型详解下 三、抽象类与接口 四、委托与事件-委托详解（一） 五、委托与事件-事件详解（二） 六、委托与事件-委托事件案例（三） 七、面向对象三大特性—–封装、继承、多态 八、泛型程序设计详解（一） 九、泛型协变与抗变（二） 十、数组（ArrayPool数组池、Span结构） 十一、集合（正在编写中） 十二、LINQ（正在编写中） 十三、错误异常处理（正在编写中） 十四、异步编程（正在编写中） 十五、反射、元数据和动态编程（正在编写中） 十六、托管和非托管内存（正在编写中） 总结：** 本人知识尚且有限，一旦出现误解或者少解还请各位慷慨解囊。** ** 清风飒爽柳姿还在，一片轻云漫飞天。涟漪泛湖荷叶拂舟，一曲和音绕指柔。对镜描妆素面朝天，一记浅笑去无痕。凭栏怅望凝眸思量，一片清秋气自爽。和音题文，一把辛酸暂埋藏，寻音倚歌，一帘惆怅浅卷起。但凭楼兰，倾泻柔情，不慢不躁，雅致清秋，莫使伤愁锁清秋。**]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c#类型详解]]></title>
    <url>%2F2019%2F07%2F31%2FC%23%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、类型成员类成员定义有（public、private、internal、protected）。 Public–对任何类和成员都是公开的，无限制 Private–是私有的，仅能由类内部代码访问，如果没有声明，默认使用此关键字 Internal–仅能在所属命名空间内部访问 Protected–可以由类或者其派生类中的代码访问 类成员–字段、方法、属性 12345678910public class MyClass &#123; public int MyInt = 2019;//字段 public static string MyMain() &#123; return &quot;这是方法&quot;; &#125; public int MyProperty &#123; get; set; &#125;//属性&#125; 字段–一个只读、可读/写的数据值 方法–对类型或对象状态数据操作的一个过程实现 属性–它可以像方法一样操作类或对象的状态数据，但看上去却像字段一样的书写方式 二、类型操作（隐式转换、显示转换、装箱、拆箱）隐式转换–对于内置数值类型，如果要存储的值无需截断或四舍五入即可适应变量，则可以进行隐式转换、小精度数据转大精度也可进行隐式转换 123Int Num=100;Long Bignum= Num;&lt;/pre&gt; 显示转换–显示转换也称为强制转换，强制转换是显式告知编译器你打算进行转换且你知道可能会发生数据丢失的一种方式。 12345Double Num=100.1;Int a;a=int.Parse(Num);&lt;/pre&gt; 显示转换存在一定的风险性，如若出现失误可能会抛出异常或者影响整个结果的精确性。假如在不知a的类型的情况下进行显示转换，但是转换失败则会引起程序抛出异常。 1var a = &quot;yi&quot;; int b = int.Parse(a);&lt;/pre&gt; 这是可以尝试使用TryParse，这里返回的是一个bool，转换成功则True 1var a = &quot;yi&quot;; int b; int.TryParse(a, out b);&lt;/pre&gt; 类型操作转换–装箱、拆箱 123456789public void Test() &#123; //装箱 int a = 1; object obj = a; //拆箱 object obj2 = 2; int b = (int)obj2;&#125; 首先我们得了解，值类型是分配在线程栈中的，不受垃圾回收机制管理。而引用类型分配在托管堆中的。 装箱–简单来说值类型转换引用类型是装箱，详细来说是。先在托管内存中分配内存，然后将值类型的值复制到内存堆中，然后返回新对象的地址，这一过程为装箱。 拆箱–拆箱并不是装箱的逆过程，简单说也是引用类型转换为值类型为拆箱，详细来说拆箱是获取为装箱部分的指针，然后将未装箱部分的值复制到堆栈中。 三、类型转换(Is,As)类型转换操作符–is、as as–是将一个对象从一种类型转换为另一种类型，如果转换成功则返回该类型，否则返回null 123A a=new A();B b= A as B;//转换正常则返回B类型，转换失败则返回null&lt;/pre&gt; is–是判断一种类型转换为另一种类型，如果转换成功则返回True，否则返回False。 123456A a=new A();If(B is A)//返回True False &#123;&#125; 保险起见可以先用is对类型转换进行判断然后再使用as进行类型转换。当然这样的话可能会造成更新的性能消耗。 更简单的一次验证并安全的操作： 123A a=new A();B b= A as B; if(B!=null)&#123;&#125; else&#123;&#125; 四、类型分类一切皆对象，每一个对象都对应一个类，所有的类都有一个基类–Object-System.Object 然后其下又可分为值类型(基本数据类型)、引用类型。 值类型：整型、浮点型、字符型、布尔型、结构体、枚举 引用类型：数组、字符串、类、接口、委托 关于类型的详解将在下一节中详细讲出。 五、扩展延伸（抽象类、类）在这里我们详细讲解下类以及抽象类。同时与接口直接的区别和相同。 类-抽象类： 1、都可被继承 2、抽象类不能被实例化，只是用来继承的，普通类可以实例化 3、抽象类只含有方法声明，没有方法体。并且只能存在于抽象类中 4、继承抽象类的子类必须实现抽象方法，除非子类也是抽象类 5、抽象类中可以包含抽象方法和实例方法 接口-抽象类： 相同 1、都可被继承 2、都可以有声明不实现的方法 3、都不可被实例化 4、子类必须实现其声明的方法 不同： 1、一个类可以继承多个接口，但是仅能继承一个抽象类 2、抽象类可包含实例方法，接口不可包含 3、接口支持回调，抽象类不支持 既然有类、抽象类、接口，那么他们分别在什么时候使用呢？ 类不用说了吧，普通情况下使用即可。 抽象类–如果需要设计大的功能单元，则使用抽象类。抽象类主要用于关系密切的对象。 接口–如果设计小而简练的功能块的话可以使用接口，接口适合为不想关的类提供通用功能 举个例子：一个围栏之间有很多的小动物，猪、狗、鸡、猫。针对这个我们设计一段程序，猪、狗、鸡、猫其都是动物，根据抽象类-设计大的功能单元。我们可以设计一个动物类的抽象类。然后在各自继承下去写自己的具体类（猪类、狗类、鸡类、猫类）。那么我们要研究他们的叫声，这里设计小的功能模块。我们就可以使用接口来设计一个叫声。然后每个每个东西去实现不同的叫声（猪叫、狗叫、鸡叫、猫叫）。设计实现大的功能单元我们选择抽象类，设计实现小而简练的功能块我们选择使用接口。 总结:c#基础知识详解系列]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础类型详解下]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[前言在上一节中，我们讲到在c#中所有的类都继承一个基类–System.Object。然后其下又分为俩大类–值类型及引用类型。这一节我们详细讲解值类型和引用类型包含了那些东西及内存的分配 堆和栈在我们讲解类型前，我们得先去了解堆和栈是什么，及其区别。我们可以先知道值类型和引用类型的引用都是分配在栈中的，而引用类型的对象分配在堆中的。我们详细看看堆和栈有啥区别及其原理吧 堆（heap）–堆的分配空间是自下到上的，已占用的空间在自由空间下面，C#中引用类型的对象及分配在堆中的，内存的分配是连续的。内存对象释放是受垃圾回收机制管理的，所有在引用对象释放时会消耗更多的性能。效率相对于栈来说是较低的。 栈（stack）–栈的分配空间是自上到下的，遵循先进先出的原则，依次释放分配的内存空间。分配的内存空间是连续的，C#中的值类型及引用类型的引用都是存放在栈中的。 当一个类的实例创建对象的的时候，这个对象的不同的成员将被分配到不用的内存空间，值类型及引用类型的引用分配到栈中，引用类型对象分配到堆中，静态成员被分配到全局数据区。这个时候栈上的指针会指向堆中实际的对象，在对象使用完成后，指针和对象会切开联系，从而使对象进入冬眠期，因为栈具有自我维护性，内存管理通过操作系统完成，而堆中的冬眠对象将有垃圾回收机制进行回收，释放对象所占的内存。 值类型及引用类型值类型： 结构体：struct（直接派生于System.ValueType） 数值类型：整型、浮点型、decimal型、bool型 枚举：enum（派生于System.Enum） 引用类型： 数组：Array（派生于System.Array） 类：class（派生于System.Object） 接口：interface 委托：delegate（派生于System.Delegate） 字符串：string(System.String) 在此特别强调：.Net中所有的元素在使用前都必须初始化，在调用new创建实例的时候，编译器会隐式的调用无参构造函数进行初始化。所有的值类型的值都为0（char为’0’），所有引用类型为null。 在此可调用IsValueType来判断类型是否为值类型 1234567StringBuilder strSql = new StringBuilder(); if (strSql.GetType().IsValueType) &#123;&#125; 引用类型中尤为注意的事string类型，它具有一特效–恒定不变性，什么意思呢？也就是说string类型一旦赋值，一旦在Heap堆中分配了内存存储对象，则再也无法改变其对象的内容。我们看下面这个例子 123String a=”aaa”;a=”bbb”; 在这个例子中先是对象a创建在堆中分配内存存储’aaa’，然后又给a对象重新赋值’bbb’,其中并不是修改堆内存中对象aaa为bbb，实则是重新创建了一个堆内存对象存储’bbb’，然后把它的引用地址指向a，原来的堆内存对象’aaa’还继续保存在堆内存中，不曾修改。只有当GC垃圾回收机制处理回收，才会消失。]]></content>
      <categories>
        <category>基础系列</category>
      </categories>
      <tags>
        <tag>.Net</tag>
      </tags>
  </entry>
</search>
